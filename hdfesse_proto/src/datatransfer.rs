// This file is generated by rust-protobuf 2.23.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `datatransfer.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_23_0;

#[derive(PartialEq,Clone,Default)]
pub struct DataTransferEncryptorMessageProto {
    // message fields
    status: ::std::option::Option<DataTransferEncryptorMessageProto_DataTransferEncryptorStatus>,
    payload: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    message: ::protobuf::SingularField<::std::string::String>,
    pub cipherOption: ::protobuf::RepeatedField<super::hdfs::CipherOptionProto>,
    pub handshakeSecret: ::protobuf::SingularPtrField<HandshakeSecretProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataTransferEncryptorMessageProto {
    fn default() -> &'a DataTransferEncryptorMessageProto {
        <DataTransferEncryptorMessageProto as ::protobuf::Message>::default_instance()
    }
}

impl DataTransferEncryptorMessageProto {
    pub fn new() -> DataTransferEncryptorMessageProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.DataTransferEncryptorMessageProto.DataTransferEncryptorStatus status = 1;


    pub fn get_status(&self) -> DataTransferEncryptorMessageProto_DataTransferEncryptorStatus {
        self.status.unwrap_or(DataTransferEncryptorMessageProto_DataTransferEncryptorStatus::SUCCESS)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: DataTransferEncryptorMessageProto_DataTransferEncryptorStatus) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional bytes payload = 2;


    pub fn get_payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload.set_default();
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string message = 3;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .hadoop.hdfs.CipherOptionProto cipherOption = 4;


    pub fn get_cipherOption(&self) -> &[super::hdfs::CipherOptionProto] {
        &self.cipherOption
    }
    pub fn clear_cipherOption(&mut self) {
        self.cipherOption.clear();
    }

    // Param is passed by value, moved
    pub fn set_cipherOption(&mut self, v: ::protobuf::RepeatedField<super::hdfs::CipherOptionProto>) {
        self.cipherOption = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cipherOption(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::CipherOptionProto> {
        &mut self.cipherOption
    }

    // Take field
    pub fn take_cipherOption(&mut self) -> ::protobuf::RepeatedField<super::hdfs::CipherOptionProto> {
        ::std::mem::replace(&mut self.cipherOption, ::protobuf::RepeatedField::new())
    }

    // optional .hadoop.hdfs.HandshakeSecretProto handshakeSecret = 5;


    pub fn get_handshakeSecret(&self) -> &HandshakeSecretProto {
        self.handshakeSecret.as_ref().unwrap_or_else(|| <HandshakeSecretProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_handshakeSecret(&mut self) {
        self.handshakeSecret.clear();
    }

    pub fn has_handshakeSecret(&self) -> bool {
        self.handshakeSecret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handshakeSecret(&mut self, v: HandshakeSecretProto) {
        self.handshakeSecret = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handshakeSecret(&mut self) -> &mut HandshakeSecretProto {
        if self.handshakeSecret.is_none() {
            self.handshakeSecret.set_default();
        }
        self.handshakeSecret.as_mut().unwrap()
    }

    // Take field
    pub fn take_handshakeSecret(&mut self) -> HandshakeSecretProto {
        self.handshakeSecret.take().unwrap_or_else(|| HandshakeSecretProto::new())
    }
}

impl ::protobuf::Message for DataTransferEncryptorMessageProto {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        for v in &self.cipherOption {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.handshakeSecret {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.payload)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cipherOption)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.handshakeSecret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.cipherOption {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.handshakeSecret.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.payload.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.cipherOption {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.handshakeSecret.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataTransferEncryptorMessageProto {
        DataTransferEncryptorMessageProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DataTransferEncryptorMessageProto_DataTransferEncryptorStatus>>(
                "status",
                |m: &DataTransferEncryptorMessageProto| { &m.status },
                |m: &mut DataTransferEncryptorMessageProto| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payload",
                |m: &DataTransferEncryptorMessageProto| { &m.payload },
                |m: &mut DataTransferEncryptorMessageProto| { &mut m.payload },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &DataTransferEncryptorMessageProto| { &m.message },
                |m: &mut DataTransferEncryptorMessageProto| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::CipherOptionProto>>(
                "cipherOption",
                |m: &DataTransferEncryptorMessageProto| { &m.cipherOption },
                |m: &mut DataTransferEncryptorMessageProto| { &mut m.cipherOption },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HandshakeSecretProto>>(
                "handshakeSecret",
                |m: &DataTransferEncryptorMessageProto| { &m.handshakeSecret },
                |m: &mut DataTransferEncryptorMessageProto| { &mut m.handshakeSecret },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataTransferEncryptorMessageProto>(
                "DataTransferEncryptorMessageProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataTransferEncryptorMessageProto {
        static instance: ::protobuf::rt::LazyV2<DataTransferEncryptorMessageProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataTransferEncryptorMessageProto::new)
    }
}

impl ::protobuf::Clear for DataTransferEncryptorMessageProto {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.payload.clear();
        self.message.clear();
        self.cipherOption.clear();
        self.handshakeSecret.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataTransferEncryptorMessageProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataTransferEncryptorMessageProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DataTransferEncryptorMessageProto_DataTransferEncryptorStatus {
    SUCCESS = 0,
    ERROR_UNKNOWN_KEY = 1,
    ERROR = 2,
}

impl ::protobuf::ProtobufEnum for DataTransferEncryptorMessageProto_DataTransferEncryptorStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataTransferEncryptorMessageProto_DataTransferEncryptorStatus> {
        match value {
            0 => ::std::option::Option::Some(DataTransferEncryptorMessageProto_DataTransferEncryptorStatus::SUCCESS),
            1 => ::std::option::Option::Some(DataTransferEncryptorMessageProto_DataTransferEncryptorStatus::ERROR_UNKNOWN_KEY),
            2 => ::std::option::Option::Some(DataTransferEncryptorMessageProto_DataTransferEncryptorStatus::ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataTransferEncryptorMessageProto_DataTransferEncryptorStatus] = &[
            DataTransferEncryptorMessageProto_DataTransferEncryptorStatus::SUCCESS,
            DataTransferEncryptorMessageProto_DataTransferEncryptorStatus::ERROR_UNKNOWN_KEY,
            DataTransferEncryptorMessageProto_DataTransferEncryptorStatus::ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DataTransferEncryptorMessageProto_DataTransferEncryptorStatus>("DataTransferEncryptorMessageProto.DataTransferEncryptorStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DataTransferEncryptorMessageProto_DataTransferEncryptorStatus {
}

impl ::std::default::Default for DataTransferEncryptorMessageProto_DataTransferEncryptorStatus {
    fn default() -> Self {
        DataTransferEncryptorMessageProto_DataTransferEncryptorStatus::SUCCESS
    }
}

impl ::protobuf::reflect::ProtobufValue for DataTransferEncryptorMessageProto_DataTransferEncryptorStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HandshakeSecretProto {
    // message fields
    secret: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    bpid: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HandshakeSecretProto {
    fn default() -> &'a HandshakeSecretProto {
        <HandshakeSecretProto as ::protobuf::Message>::default_instance()
    }
}

impl HandshakeSecretProto {
    pub fn new() -> HandshakeSecretProto {
        ::std::default::Default::default()
    }

    // required bytes secret = 1;


    pub fn get_secret(&self) -> &[u8] {
        match self.secret.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    pub fn has_secret(&self) -> bool {
        self.secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: ::std::vec::Vec<u8>) {
        self.secret = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.secret.is_none() {
            self.secret.set_default();
        }
        self.secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_secret(&mut self) -> ::std::vec::Vec<u8> {
        self.secret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required string bpid = 2;


    pub fn get_bpid(&self) -> &str {
        match self.bpid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_bpid(&mut self) {
        self.bpid.clear();
    }

    pub fn has_bpid(&self) -> bool {
        self.bpid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bpid(&mut self, v: ::std::string::String) {
        self.bpid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bpid(&mut self) -> &mut ::std::string::String {
        if self.bpid.is_none() {
            self.bpid.set_default();
        }
        self.bpid.as_mut().unwrap()
    }

    // Take field
    pub fn take_bpid(&mut self) -> ::std::string::String {
        self.bpid.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for HandshakeSecretProto {
    fn is_initialized(&self) -> bool {
        if self.secret.is_none() {
            return false;
        }
        if self.bpid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.secret)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bpid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.secret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.bpid.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.secret.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.bpid.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HandshakeSecretProto {
        HandshakeSecretProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "secret",
                |m: &HandshakeSecretProto| { &m.secret },
                |m: &mut HandshakeSecretProto| { &mut m.secret },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bpid",
                |m: &HandshakeSecretProto| { &m.bpid },
                |m: &mut HandshakeSecretProto| { &mut m.bpid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HandshakeSecretProto>(
                "HandshakeSecretProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HandshakeSecretProto {
        static instance: ::protobuf::rt::LazyV2<HandshakeSecretProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HandshakeSecretProto::new)
    }
}

impl ::protobuf::Clear for HandshakeSecretProto {
    fn clear(&mut self) {
        self.secret.clear();
        self.bpid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HandshakeSecretProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandshakeSecretProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BaseHeaderProto {
    // message fields
    pub block: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    pub token: ::protobuf::SingularPtrField<super::Security::TokenProto>,
    pub traceInfo: ::protobuf::SingularPtrField<DataTransferTraceInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BaseHeaderProto {
    fn default() -> &'a BaseHeaderProto {
        <BaseHeaderProto as ::protobuf::Message>::default_instance()
    }
}

impl BaseHeaderProto {
    pub fn new() -> BaseHeaderProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ExtendedBlockProto block = 1;


    pub fn get_block(&self) -> &super::hdfs::ExtendedBlockProto {
        self.block.as_ref().unwrap_or_else(|| <super::hdfs::ExtendedBlockProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    // optional .hadoop.common.TokenProto token = 2;


    pub fn get_token(&self) -> &super::Security::TokenProto {
        self.token.as_ref().unwrap_or_else(|| <super::Security::TokenProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: super::Security::TokenProto) {
        self.token = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut super::Security::TokenProto {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> super::Security::TokenProto {
        self.token.take().unwrap_or_else(|| super::Security::TokenProto::new())
    }

    // optional .hadoop.hdfs.DataTransferTraceInfoProto traceInfo = 3;


    pub fn get_traceInfo(&self) -> &DataTransferTraceInfoProto {
        self.traceInfo.as_ref().unwrap_or_else(|| <DataTransferTraceInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_traceInfo(&mut self) {
        self.traceInfo.clear();
    }

    pub fn has_traceInfo(&self) -> bool {
        self.traceInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_traceInfo(&mut self, v: DataTransferTraceInfoProto) {
        self.traceInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_traceInfo(&mut self) -> &mut DataTransferTraceInfoProto {
        if self.traceInfo.is_none() {
            self.traceInfo.set_default();
        }
        self.traceInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_traceInfo(&mut self) -> DataTransferTraceInfoProto {
        self.traceInfo.take().unwrap_or_else(|| DataTransferTraceInfoProto::new())
    }
}

impl ::protobuf::Message for BaseHeaderProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.token {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.traceInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.token)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.traceInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.token.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.traceInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.token.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.traceInfo.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BaseHeaderProto {
        BaseHeaderProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                "block",
                |m: &BaseHeaderProto| { &m.block },
                |m: &mut BaseHeaderProto| { &mut m.block },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Security::TokenProto>>(
                "token",
                |m: &BaseHeaderProto| { &m.token },
                |m: &mut BaseHeaderProto| { &mut m.token },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataTransferTraceInfoProto>>(
                "traceInfo",
                |m: &BaseHeaderProto| { &m.traceInfo },
                |m: &mut BaseHeaderProto| { &mut m.traceInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BaseHeaderProto>(
                "BaseHeaderProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BaseHeaderProto {
        static instance: ::protobuf::rt::LazyV2<BaseHeaderProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BaseHeaderProto::new)
    }
}

impl ::protobuf::Clear for BaseHeaderProto {
    fn clear(&mut self) {
        self.block.clear();
        self.token.clear();
        self.traceInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BaseHeaderProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BaseHeaderProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DataTransferTraceInfoProto {
    // message fields
    traceId: ::std::option::Option<u64>,
    parentId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataTransferTraceInfoProto {
    fn default() -> &'a DataTransferTraceInfoProto {
        <DataTransferTraceInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl DataTransferTraceInfoProto {
    pub fn new() -> DataTransferTraceInfoProto {
        ::std::default::Default::default()
    }

    // required uint64 traceId = 1;


    pub fn get_traceId(&self) -> u64 {
        self.traceId.unwrap_or(0)
    }
    pub fn clear_traceId(&mut self) {
        self.traceId = ::std::option::Option::None;
    }

    pub fn has_traceId(&self) -> bool {
        self.traceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_traceId(&mut self, v: u64) {
        self.traceId = ::std::option::Option::Some(v);
    }

    // required uint64 parentId = 2;


    pub fn get_parentId(&self) -> u64 {
        self.parentId.unwrap_or(0)
    }
    pub fn clear_parentId(&mut self) {
        self.parentId = ::std::option::Option::None;
    }

    pub fn has_parentId(&self) -> bool {
        self.parentId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parentId(&mut self, v: u64) {
        self.parentId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DataTransferTraceInfoProto {
    fn is_initialized(&self) -> bool {
        if self.traceId.is_none() {
            return false;
        }
        if self.parentId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.traceId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.parentId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.traceId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.parentId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.traceId {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.parentId {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataTransferTraceInfoProto {
        DataTransferTraceInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "traceId",
                |m: &DataTransferTraceInfoProto| { &m.traceId },
                |m: &mut DataTransferTraceInfoProto| { &mut m.traceId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "parentId",
                |m: &DataTransferTraceInfoProto| { &m.parentId },
                |m: &mut DataTransferTraceInfoProto| { &mut m.parentId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataTransferTraceInfoProto>(
                "DataTransferTraceInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataTransferTraceInfoProto {
        static instance: ::protobuf::rt::LazyV2<DataTransferTraceInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataTransferTraceInfoProto::new)
    }
}

impl ::protobuf::Clear for DataTransferTraceInfoProto {
    fn clear(&mut self) {
        self.traceId = ::std::option::Option::None;
        self.parentId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataTransferTraceInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataTransferTraceInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientOperationHeaderProto {
    // message fields
    pub baseHeader: ::protobuf::SingularPtrField<BaseHeaderProto>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientOperationHeaderProto {
    fn default() -> &'a ClientOperationHeaderProto {
        <ClientOperationHeaderProto as ::protobuf::Message>::default_instance()
    }
}

impl ClientOperationHeaderProto {
    pub fn new() -> ClientOperationHeaderProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.BaseHeaderProto baseHeader = 1;


    pub fn get_baseHeader(&self) -> &BaseHeaderProto {
        self.baseHeader.as_ref().unwrap_or_else(|| <BaseHeaderProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_baseHeader(&mut self) {
        self.baseHeader.clear();
    }

    pub fn has_baseHeader(&self) -> bool {
        self.baseHeader.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseHeader(&mut self, v: BaseHeaderProto) {
        self.baseHeader = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_baseHeader(&mut self) -> &mut BaseHeaderProto {
        if self.baseHeader.is_none() {
            self.baseHeader.set_default();
        }
        self.baseHeader.as_mut().unwrap()
    }

    // Take field
    pub fn take_baseHeader(&mut self) -> BaseHeaderProto {
        self.baseHeader.take().unwrap_or_else(|| BaseHeaderProto::new())
    }

    // required string clientName = 2;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ClientOperationHeaderProto {
    fn is_initialized(&self) -> bool {
        if self.baseHeader.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        for v in &self.baseHeader {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.baseHeader)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.baseHeader.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.baseHeader.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientOperationHeaderProto {
        ClientOperationHeaderProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BaseHeaderProto>>(
                "baseHeader",
                |m: &ClientOperationHeaderProto| { &m.baseHeader },
                |m: &mut ClientOperationHeaderProto| { &mut m.baseHeader },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientName",
                |m: &ClientOperationHeaderProto| { &m.clientName },
                |m: &mut ClientOperationHeaderProto| { &mut m.clientName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientOperationHeaderProto>(
                "ClientOperationHeaderProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientOperationHeaderProto {
        static instance: ::protobuf::rt::LazyV2<ClientOperationHeaderProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientOperationHeaderProto::new)
    }
}

impl ::protobuf::Clear for ClientOperationHeaderProto {
    fn clear(&mut self) {
        self.baseHeader.clear();
        self.clientName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientOperationHeaderProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientOperationHeaderProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CachingStrategyProto {
    // message fields
    dropBehind: ::std::option::Option<bool>,
    readahead: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CachingStrategyProto {
    fn default() -> &'a CachingStrategyProto {
        <CachingStrategyProto as ::protobuf::Message>::default_instance()
    }
}

impl CachingStrategyProto {
    pub fn new() -> CachingStrategyProto {
        ::std::default::Default::default()
    }

    // optional bool dropBehind = 1;


    pub fn get_dropBehind(&self) -> bool {
        self.dropBehind.unwrap_or(false)
    }
    pub fn clear_dropBehind(&mut self) {
        self.dropBehind = ::std::option::Option::None;
    }

    pub fn has_dropBehind(&self) -> bool {
        self.dropBehind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dropBehind(&mut self, v: bool) {
        self.dropBehind = ::std::option::Option::Some(v);
    }

    // optional int64 readahead = 2;


    pub fn get_readahead(&self) -> i64 {
        self.readahead.unwrap_or(0)
    }
    pub fn clear_readahead(&mut self) {
        self.readahead = ::std::option::Option::None;
    }

    pub fn has_readahead(&self) -> bool {
        self.readahead.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readahead(&mut self, v: i64) {
        self.readahead = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CachingStrategyProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dropBehind = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.readahead = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dropBehind {
            my_size += 2;
        }
        if let Some(v) = self.readahead {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dropBehind {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.readahead {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CachingStrategyProto {
        CachingStrategyProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "dropBehind",
                |m: &CachingStrategyProto| { &m.dropBehind },
                |m: &mut CachingStrategyProto| { &mut m.dropBehind },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "readahead",
                |m: &CachingStrategyProto| { &m.readahead },
                |m: &mut CachingStrategyProto| { &mut m.readahead },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CachingStrategyProto>(
                "CachingStrategyProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CachingStrategyProto {
        static instance: ::protobuf::rt::LazyV2<CachingStrategyProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CachingStrategyProto::new)
    }
}

impl ::protobuf::Clear for CachingStrategyProto {
    fn clear(&mut self) {
        self.dropBehind = ::std::option::Option::None;
        self.readahead = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CachingStrategyProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CachingStrategyProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpReadBlockProto {
    // message fields
    pub header: ::protobuf::SingularPtrField<ClientOperationHeaderProto>,
    offset: ::std::option::Option<u64>,
    len: ::std::option::Option<u64>,
    sendChecksums: ::std::option::Option<bool>,
    pub cachingStrategy: ::protobuf::SingularPtrField<CachingStrategyProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpReadBlockProto {
    fn default() -> &'a OpReadBlockProto {
        <OpReadBlockProto as ::protobuf::Message>::default_instance()
    }
}

impl OpReadBlockProto {
    pub fn new() -> OpReadBlockProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ClientOperationHeaderProto header = 1;


    pub fn get_header(&self) -> &ClientOperationHeaderProto {
        self.header.as_ref().unwrap_or_else(|| <ClientOperationHeaderProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ClientOperationHeaderProto) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ClientOperationHeaderProto {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ClientOperationHeaderProto {
        self.header.take().unwrap_or_else(|| ClientOperationHeaderProto::new())
    }

    // required uint64 offset = 2;


    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }
    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    // required uint64 len = 3;


    pub fn get_len(&self) -> u64 {
        self.len.unwrap_or(0)
    }
    pub fn clear_len(&mut self) {
        self.len = ::std::option::Option::None;
    }

    pub fn has_len(&self) -> bool {
        self.len.is_some()
    }

    // Param is passed by value, moved
    pub fn set_len(&mut self, v: u64) {
        self.len = ::std::option::Option::Some(v);
    }

    // optional bool sendChecksums = 4;


    pub fn get_sendChecksums(&self) -> bool {
        self.sendChecksums.unwrap_or(true)
    }
    pub fn clear_sendChecksums(&mut self) {
        self.sendChecksums = ::std::option::Option::None;
    }

    pub fn has_sendChecksums(&self) -> bool {
        self.sendChecksums.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sendChecksums(&mut self, v: bool) {
        self.sendChecksums = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.CachingStrategyProto cachingStrategy = 5;


    pub fn get_cachingStrategy(&self) -> &CachingStrategyProto {
        self.cachingStrategy.as_ref().unwrap_or_else(|| <CachingStrategyProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cachingStrategy(&mut self) {
        self.cachingStrategy.clear();
    }

    pub fn has_cachingStrategy(&self) -> bool {
        self.cachingStrategy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cachingStrategy(&mut self, v: CachingStrategyProto) {
        self.cachingStrategy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cachingStrategy(&mut self) -> &mut CachingStrategyProto {
        if self.cachingStrategy.is_none() {
            self.cachingStrategy.set_default();
        }
        self.cachingStrategy.as_mut().unwrap()
    }

    // Take field
    pub fn take_cachingStrategy(&mut self) -> CachingStrategyProto {
        self.cachingStrategy.take().unwrap_or_else(|| CachingStrategyProto::new())
    }
}

impl ::protobuf::Message for OpReadBlockProto {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        if self.len.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cachingStrategy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.len = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sendChecksums = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cachingStrategy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.len {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sendChecksums {
            my_size += 2;
        }
        if let Some(ref v) = self.cachingStrategy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.len {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.sendChecksums {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.cachingStrategy.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpReadBlockProto {
        OpReadBlockProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientOperationHeaderProto>>(
                "header",
                |m: &OpReadBlockProto| { &m.header },
                |m: &mut OpReadBlockProto| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "offset",
                |m: &OpReadBlockProto| { &m.offset },
                |m: &mut OpReadBlockProto| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "len",
                |m: &OpReadBlockProto| { &m.len },
                |m: &mut OpReadBlockProto| { &mut m.len },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sendChecksums",
                |m: &OpReadBlockProto| { &m.sendChecksums },
                |m: &mut OpReadBlockProto| { &mut m.sendChecksums },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachingStrategyProto>>(
                "cachingStrategy",
                |m: &OpReadBlockProto| { &m.cachingStrategy },
                |m: &mut OpReadBlockProto| { &mut m.cachingStrategy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpReadBlockProto>(
                "OpReadBlockProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpReadBlockProto {
        static instance: ::protobuf::rt::LazyV2<OpReadBlockProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpReadBlockProto::new)
    }
}

impl ::protobuf::Clear for OpReadBlockProto {
    fn clear(&mut self) {
        self.header.clear();
        self.offset = ::std::option::Option::None;
        self.len = ::std::option::Option::None;
        self.sendChecksums = ::std::option::Option::None;
        self.cachingStrategy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpReadBlockProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpReadBlockProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChecksumProto {
    // message fields
    field_type: ::std::option::Option<super::hdfs::ChecksumTypeProto>,
    bytesPerChecksum: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChecksumProto {
    fn default() -> &'a ChecksumProto {
        <ChecksumProto as ::protobuf::Message>::default_instance()
    }
}

impl ChecksumProto {
    pub fn new() -> ChecksumProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ChecksumTypeProto type = 1;


    pub fn get_field_type(&self) -> super::hdfs::ChecksumTypeProto {
        self.field_type.unwrap_or(super::hdfs::ChecksumTypeProto::CHECKSUM_NULL)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: super::hdfs::ChecksumTypeProto) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // required uint32 bytesPerChecksum = 2;


    pub fn get_bytesPerChecksum(&self) -> u32 {
        self.bytesPerChecksum.unwrap_or(0)
    }
    pub fn clear_bytesPerChecksum(&mut self) {
        self.bytesPerChecksum = ::std::option::Option::None;
    }

    pub fn has_bytesPerChecksum(&self) -> bool {
        self.bytesPerChecksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesPerChecksum(&mut self, v: u32) {
        self.bytesPerChecksum = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ChecksumProto {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        if self.bytesPerChecksum.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bytesPerChecksum = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.bytesPerChecksum {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.bytesPerChecksum {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChecksumProto {
        ChecksumProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::ChecksumTypeProto>>(
                "type",
                |m: &ChecksumProto| { &m.field_type },
                |m: &mut ChecksumProto| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "bytesPerChecksum",
                |m: &ChecksumProto| { &m.bytesPerChecksum },
                |m: &mut ChecksumProto| { &mut m.bytesPerChecksum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChecksumProto>(
                "ChecksumProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChecksumProto {
        static instance: ::protobuf::rt::LazyV2<ChecksumProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChecksumProto::new)
    }
}

impl ::protobuf::Clear for ChecksumProto {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.bytesPerChecksum = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChecksumProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChecksumProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpWriteBlockProto {
    // message fields
    pub header: ::protobuf::SingularPtrField<ClientOperationHeaderProto>,
    pub targets: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>,
    pub source: ::protobuf::SingularPtrField<super::hdfs::DatanodeInfoProto>,
    stage: ::std::option::Option<OpWriteBlockProto_BlockConstructionStage>,
    pipelineSize: ::std::option::Option<u32>,
    minBytesRcvd: ::std::option::Option<u64>,
    maxBytesRcvd: ::std::option::Option<u64>,
    latestGenerationStamp: ::std::option::Option<u64>,
    pub requestedChecksum: ::protobuf::SingularPtrField<ChecksumProto>,
    pub cachingStrategy: ::protobuf::SingularPtrField<CachingStrategyProto>,
    storageType: ::std::option::Option<super::hdfs::StorageTypeProto>,
    pub targetStorageTypes: ::std::vec::Vec<super::hdfs::StorageTypeProto>,
    allowLazyPersist: ::std::option::Option<bool>,
    pinning: ::std::option::Option<bool>,
    pub targetPinnings: ::std::vec::Vec<bool>,
    storageId: ::protobuf::SingularField<::std::string::String>,
    pub targetStorageIds: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpWriteBlockProto {
    fn default() -> &'a OpWriteBlockProto {
        <OpWriteBlockProto as ::protobuf::Message>::default_instance()
    }
}

impl OpWriteBlockProto {
    pub fn new() -> OpWriteBlockProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ClientOperationHeaderProto header = 1;


    pub fn get_header(&self) -> &ClientOperationHeaderProto {
        self.header.as_ref().unwrap_or_else(|| <ClientOperationHeaderProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ClientOperationHeaderProto) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ClientOperationHeaderProto {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ClientOperationHeaderProto {
        self.header.take().unwrap_or_else(|| ClientOperationHeaderProto::new())
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto targets = 2;


    pub fn get_targets(&self) -> &[super::hdfs::DatanodeInfoProto] {
        &self.targets
    }
    pub fn clear_targets(&mut self) {
        self.targets.clear();
    }

    // Param is passed by value, moved
    pub fn set_targets(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>) {
        self.targets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targets(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.targets
    }

    // Take field
    pub fn take_targets(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        ::std::mem::replace(&mut self.targets, ::protobuf::RepeatedField::new())
    }

    // optional .hadoop.hdfs.DatanodeInfoProto source = 3;


    pub fn get_source(&self) -> &super::hdfs::DatanodeInfoProto {
        self.source.as_ref().unwrap_or_else(|| <super::hdfs::DatanodeInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: super::hdfs::DatanodeInfoProto) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut super::hdfs::DatanodeInfoProto {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> super::hdfs::DatanodeInfoProto {
        self.source.take().unwrap_or_else(|| super::hdfs::DatanodeInfoProto::new())
    }

    // required .hadoop.hdfs.OpWriteBlockProto.BlockConstructionStage stage = 4;


    pub fn get_stage(&self) -> OpWriteBlockProto_BlockConstructionStage {
        self.stage.unwrap_or(OpWriteBlockProto_BlockConstructionStage::PIPELINE_SETUP_APPEND)
    }
    pub fn clear_stage(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_stage(&self) -> bool {
        self.stage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stage(&mut self, v: OpWriteBlockProto_BlockConstructionStage) {
        self.stage = ::std::option::Option::Some(v);
    }

    // required uint32 pipelineSize = 5;


    pub fn get_pipelineSize(&self) -> u32 {
        self.pipelineSize.unwrap_or(0)
    }
    pub fn clear_pipelineSize(&mut self) {
        self.pipelineSize = ::std::option::Option::None;
    }

    pub fn has_pipelineSize(&self) -> bool {
        self.pipelineSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pipelineSize(&mut self, v: u32) {
        self.pipelineSize = ::std::option::Option::Some(v);
    }

    // required uint64 minBytesRcvd = 6;


    pub fn get_minBytesRcvd(&self) -> u64 {
        self.minBytesRcvd.unwrap_or(0)
    }
    pub fn clear_minBytesRcvd(&mut self) {
        self.minBytesRcvd = ::std::option::Option::None;
    }

    pub fn has_minBytesRcvd(&self) -> bool {
        self.minBytesRcvd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minBytesRcvd(&mut self, v: u64) {
        self.minBytesRcvd = ::std::option::Option::Some(v);
    }

    // required uint64 maxBytesRcvd = 7;


    pub fn get_maxBytesRcvd(&self) -> u64 {
        self.maxBytesRcvd.unwrap_or(0)
    }
    pub fn clear_maxBytesRcvd(&mut self) {
        self.maxBytesRcvd = ::std::option::Option::None;
    }

    pub fn has_maxBytesRcvd(&self) -> bool {
        self.maxBytesRcvd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxBytesRcvd(&mut self, v: u64) {
        self.maxBytesRcvd = ::std::option::Option::Some(v);
    }

    // required uint64 latestGenerationStamp = 8;


    pub fn get_latestGenerationStamp(&self) -> u64 {
        self.latestGenerationStamp.unwrap_or(0)
    }
    pub fn clear_latestGenerationStamp(&mut self) {
        self.latestGenerationStamp = ::std::option::Option::None;
    }

    pub fn has_latestGenerationStamp(&self) -> bool {
        self.latestGenerationStamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latestGenerationStamp(&mut self, v: u64) {
        self.latestGenerationStamp = ::std::option::Option::Some(v);
    }

    // required .hadoop.hdfs.ChecksumProto requestedChecksum = 9;


    pub fn get_requestedChecksum(&self) -> &ChecksumProto {
        self.requestedChecksum.as_ref().unwrap_or_else(|| <ChecksumProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_requestedChecksum(&mut self) {
        self.requestedChecksum.clear();
    }

    pub fn has_requestedChecksum(&self) -> bool {
        self.requestedChecksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requestedChecksum(&mut self, v: ChecksumProto) {
        self.requestedChecksum = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_requestedChecksum(&mut self) -> &mut ChecksumProto {
        if self.requestedChecksum.is_none() {
            self.requestedChecksum.set_default();
        }
        self.requestedChecksum.as_mut().unwrap()
    }

    // Take field
    pub fn take_requestedChecksum(&mut self) -> ChecksumProto {
        self.requestedChecksum.take().unwrap_or_else(|| ChecksumProto::new())
    }

    // optional .hadoop.hdfs.CachingStrategyProto cachingStrategy = 10;


    pub fn get_cachingStrategy(&self) -> &CachingStrategyProto {
        self.cachingStrategy.as_ref().unwrap_or_else(|| <CachingStrategyProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cachingStrategy(&mut self) {
        self.cachingStrategy.clear();
    }

    pub fn has_cachingStrategy(&self) -> bool {
        self.cachingStrategy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cachingStrategy(&mut self, v: CachingStrategyProto) {
        self.cachingStrategy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cachingStrategy(&mut self) -> &mut CachingStrategyProto {
        if self.cachingStrategy.is_none() {
            self.cachingStrategy.set_default();
        }
        self.cachingStrategy.as_mut().unwrap()
    }

    // Take field
    pub fn take_cachingStrategy(&mut self) -> CachingStrategyProto {
        self.cachingStrategy.take().unwrap_or_else(|| CachingStrategyProto::new())
    }

    // optional .hadoop.hdfs.StorageTypeProto storageType = 11;


    pub fn get_storageType(&self) -> super::hdfs::StorageTypeProto {
        self.storageType.unwrap_or(super::hdfs::StorageTypeProto::DISK)
    }
    pub fn clear_storageType(&mut self) {
        self.storageType = ::std::option::Option::None;
    }

    pub fn has_storageType(&self) -> bool {
        self.storageType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageType(&mut self, v: super::hdfs::StorageTypeProto) {
        self.storageType = ::std::option::Option::Some(v);
    }

    // repeated .hadoop.hdfs.StorageTypeProto targetStorageTypes = 12;


    pub fn get_targetStorageTypes(&self) -> &[super::hdfs::StorageTypeProto] {
        &self.targetStorageTypes
    }
    pub fn clear_targetStorageTypes(&mut self) {
        self.targetStorageTypes.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetStorageTypes(&mut self, v: ::std::vec::Vec<super::hdfs::StorageTypeProto>) {
        self.targetStorageTypes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targetStorageTypes(&mut self) -> &mut ::std::vec::Vec<super::hdfs::StorageTypeProto> {
        &mut self.targetStorageTypes
    }

    // Take field
    pub fn take_targetStorageTypes(&mut self) -> ::std::vec::Vec<super::hdfs::StorageTypeProto> {
        ::std::mem::replace(&mut self.targetStorageTypes, ::std::vec::Vec::new())
    }

    // optional bool allowLazyPersist = 13;


    pub fn get_allowLazyPersist(&self) -> bool {
        self.allowLazyPersist.unwrap_or(false)
    }
    pub fn clear_allowLazyPersist(&mut self) {
        self.allowLazyPersist = ::std::option::Option::None;
    }

    pub fn has_allowLazyPersist(&self) -> bool {
        self.allowLazyPersist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowLazyPersist(&mut self, v: bool) {
        self.allowLazyPersist = ::std::option::Option::Some(v);
    }

    // optional bool pinning = 14;


    pub fn get_pinning(&self) -> bool {
        self.pinning.unwrap_or(false)
    }
    pub fn clear_pinning(&mut self) {
        self.pinning = ::std::option::Option::None;
    }

    pub fn has_pinning(&self) -> bool {
        self.pinning.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pinning(&mut self, v: bool) {
        self.pinning = ::std::option::Option::Some(v);
    }

    // repeated bool targetPinnings = 15;


    pub fn get_targetPinnings(&self) -> &[bool] {
        &self.targetPinnings
    }
    pub fn clear_targetPinnings(&mut self) {
        self.targetPinnings.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetPinnings(&mut self, v: ::std::vec::Vec<bool>) {
        self.targetPinnings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targetPinnings(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.targetPinnings
    }

    // Take field
    pub fn take_targetPinnings(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.targetPinnings, ::std::vec::Vec::new())
    }

    // optional string storageId = 16;


    pub fn get_storageId(&self) -> &str {
        match self.storageId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_storageId(&mut self) {
        self.storageId.clear();
    }

    pub fn has_storageId(&self) -> bool {
        self.storageId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageId(&mut self, v: ::std::string::String) {
        self.storageId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageId(&mut self) -> &mut ::std::string::String {
        if self.storageId.is_none() {
            self.storageId.set_default();
        }
        self.storageId.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageId(&mut self) -> ::std::string::String {
        self.storageId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string targetStorageIds = 17;


    pub fn get_targetStorageIds(&self) -> &[::std::string::String] {
        &self.targetStorageIds
    }
    pub fn clear_targetStorageIds(&mut self) {
        self.targetStorageIds.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetStorageIds(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.targetStorageIds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targetStorageIds(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.targetStorageIds
    }

    // Take field
    pub fn take_targetStorageIds(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.targetStorageIds, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OpWriteBlockProto {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        if self.stage.is_none() {
            return false;
        }
        if self.pipelineSize.is_none() {
            return false;
        }
        if self.minBytesRcvd.is_none() {
            return false;
        }
        if self.maxBytesRcvd.is_none() {
            return false;
        }
        if self.latestGenerationStamp.is_none() {
            return false;
        }
        if self.requestedChecksum.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.targets {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.requestedChecksum {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cachingStrategy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.targets)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.stage, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pipelineSize = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.minBytesRcvd = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.maxBytesRcvd = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.latestGenerationStamp = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.requestedChecksum)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cachingStrategy)?;
                },
                11 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.storageType, 11, &mut self.unknown_fields)?
                },
                12 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.targetStorageTypes, 12, &mut self.unknown_fields)?
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allowLazyPersist = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pinning = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.targetPinnings)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storageId)?;
                },
                17 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.targetStorageIds)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.targets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.stage {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.pipelineSize {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minBytesRcvd {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxBytesRcvd {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.latestGenerationStamp {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.requestedChecksum.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cachingStrategy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.storageType {
            my_size += ::protobuf::rt::enum_size(11, v);
        }
        for value in &self.targetStorageTypes {
            my_size += ::protobuf::rt::enum_size(12, *value);
        };
        if let Some(v) = self.allowLazyPersist {
            my_size += 2;
        }
        if let Some(v) = self.pinning {
            my_size += 2;
        }
        my_size += 2 * self.targetPinnings.len() as u32;
        if let Some(ref v) = self.storageId.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        for value in &self.targetStorageIds {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.targets {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.stage {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.pipelineSize {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.minBytesRcvd {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.maxBytesRcvd {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.latestGenerationStamp {
            os.write_uint64(8, v)?;
        }
        if let Some(ref v) = self.requestedChecksum.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cachingStrategy.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.storageType {
            os.write_enum(11, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.targetStorageTypes {
            os.write_enum(12, ::protobuf::ProtobufEnum::value(v))?;
        };
        if let Some(v) = self.allowLazyPersist {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.pinning {
            os.write_bool(14, v)?;
        }
        for v in &self.targetPinnings {
            os.write_bool(15, *v)?;
        };
        if let Some(ref v) = self.storageId.as_ref() {
            os.write_string(16, &v)?;
        }
        for v in &self.targetStorageIds {
            os.write_string(17, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpWriteBlockProto {
        OpWriteBlockProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientOperationHeaderProto>>(
                "header",
                |m: &OpWriteBlockProto| { &m.header },
                |m: &mut OpWriteBlockProto| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                "targets",
                |m: &OpWriteBlockProto| { &m.targets },
                |m: &mut OpWriteBlockProto| { &mut m.targets },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                "source",
                |m: &OpWriteBlockProto| { &m.source },
                |m: &mut OpWriteBlockProto| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OpWriteBlockProto_BlockConstructionStage>>(
                "stage",
                |m: &OpWriteBlockProto| { &m.stage },
                |m: &mut OpWriteBlockProto| { &mut m.stage },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "pipelineSize",
                |m: &OpWriteBlockProto| { &m.pipelineSize },
                |m: &mut OpWriteBlockProto| { &mut m.pipelineSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "minBytesRcvd",
                |m: &OpWriteBlockProto| { &m.minBytesRcvd },
                |m: &mut OpWriteBlockProto| { &mut m.minBytesRcvd },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "maxBytesRcvd",
                |m: &OpWriteBlockProto| { &m.maxBytesRcvd },
                |m: &mut OpWriteBlockProto| { &mut m.maxBytesRcvd },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "latestGenerationStamp",
                |m: &OpWriteBlockProto| { &m.latestGenerationStamp },
                |m: &mut OpWriteBlockProto| { &mut m.latestGenerationStamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChecksumProto>>(
                "requestedChecksum",
                |m: &OpWriteBlockProto| { &m.requestedChecksum },
                |m: &mut OpWriteBlockProto| { &mut m.requestedChecksum },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachingStrategyProto>>(
                "cachingStrategy",
                |m: &OpWriteBlockProto| { &m.cachingStrategy },
                |m: &mut OpWriteBlockProto| { &mut m.cachingStrategy },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::StorageTypeProto>>(
                "storageType",
                |m: &OpWriteBlockProto| { &m.storageType },
                |m: &mut OpWriteBlockProto| { &mut m.storageType },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::StorageTypeProto>>(
                "targetStorageTypes",
                |m: &OpWriteBlockProto| { &m.targetStorageTypes },
                |m: &mut OpWriteBlockProto| { &mut m.targetStorageTypes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allowLazyPersist",
                |m: &OpWriteBlockProto| { &m.allowLazyPersist },
                |m: &mut OpWriteBlockProto| { &mut m.allowLazyPersist },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "pinning",
                |m: &OpWriteBlockProto| { &m.pinning },
                |m: &mut OpWriteBlockProto| { &mut m.pinning },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "targetPinnings",
                |m: &OpWriteBlockProto| { &m.targetPinnings },
                |m: &mut OpWriteBlockProto| { &mut m.targetPinnings },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storageId",
                |m: &OpWriteBlockProto| { &m.storageId },
                |m: &mut OpWriteBlockProto| { &mut m.storageId },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "targetStorageIds",
                |m: &OpWriteBlockProto| { &m.targetStorageIds },
                |m: &mut OpWriteBlockProto| { &mut m.targetStorageIds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpWriteBlockProto>(
                "OpWriteBlockProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpWriteBlockProto {
        static instance: ::protobuf::rt::LazyV2<OpWriteBlockProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpWriteBlockProto::new)
    }
}

impl ::protobuf::Clear for OpWriteBlockProto {
    fn clear(&mut self) {
        self.header.clear();
        self.targets.clear();
        self.source.clear();
        self.stage = ::std::option::Option::None;
        self.pipelineSize = ::std::option::Option::None;
        self.minBytesRcvd = ::std::option::Option::None;
        self.maxBytesRcvd = ::std::option::Option::None;
        self.latestGenerationStamp = ::std::option::Option::None;
        self.requestedChecksum.clear();
        self.cachingStrategy.clear();
        self.storageType = ::std::option::Option::None;
        self.targetStorageTypes.clear();
        self.allowLazyPersist = ::std::option::Option::None;
        self.pinning = ::std::option::Option::None;
        self.targetPinnings.clear();
        self.storageId.clear();
        self.targetStorageIds.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpWriteBlockProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpWriteBlockProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OpWriteBlockProto_BlockConstructionStage {
    PIPELINE_SETUP_APPEND = 0,
    PIPELINE_SETUP_APPEND_RECOVERY = 1,
    DATA_STREAMING = 2,
    PIPELINE_SETUP_STREAMING_RECOVERY = 3,
    PIPELINE_CLOSE = 4,
    PIPELINE_CLOSE_RECOVERY = 5,
    PIPELINE_SETUP_CREATE = 6,
    TRANSFER_RBW = 7,
    TRANSFER_FINALIZED = 8,
}

impl ::protobuf::ProtobufEnum for OpWriteBlockProto_BlockConstructionStage {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OpWriteBlockProto_BlockConstructionStage> {
        match value {
            0 => ::std::option::Option::Some(OpWriteBlockProto_BlockConstructionStage::PIPELINE_SETUP_APPEND),
            1 => ::std::option::Option::Some(OpWriteBlockProto_BlockConstructionStage::PIPELINE_SETUP_APPEND_RECOVERY),
            2 => ::std::option::Option::Some(OpWriteBlockProto_BlockConstructionStage::DATA_STREAMING),
            3 => ::std::option::Option::Some(OpWriteBlockProto_BlockConstructionStage::PIPELINE_SETUP_STREAMING_RECOVERY),
            4 => ::std::option::Option::Some(OpWriteBlockProto_BlockConstructionStage::PIPELINE_CLOSE),
            5 => ::std::option::Option::Some(OpWriteBlockProto_BlockConstructionStage::PIPELINE_CLOSE_RECOVERY),
            6 => ::std::option::Option::Some(OpWriteBlockProto_BlockConstructionStage::PIPELINE_SETUP_CREATE),
            7 => ::std::option::Option::Some(OpWriteBlockProto_BlockConstructionStage::TRANSFER_RBW),
            8 => ::std::option::Option::Some(OpWriteBlockProto_BlockConstructionStage::TRANSFER_FINALIZED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OpWriteBlockProto_BlockConstructionStage] = &[
            OpWriteBlockProto_BlockConstructionStage::PIPELINE_SETUP_APPEND,
            OpWriteBlockProto_BlockConstructionStage::PIPELINE_SETUP_APPEND_RECOVERY,
            OpWriteBlockProto_BlockConstructionStage::DATA_STREAMING,
            OpWriteBlockProto_BlockConstructionStage::PIPELINE_SETUP_STREAMING_RECOVERY,
            OpWriteBlockProto_BlockConstructionStage::PIPELINE_CLOSE,
            OpWriteBlockProto_BlockConstructionStage::PIPELINE_CLOSE_RECOVERY,
            OpWriteBlockProto_BlockConstructionStage::PIPELINE_SETUP_CREATE,
            OpWriteBlockProto_BlockConstructionStage::TRANSFER_RBW,
            OpWriteBlockProto_BlockConstructionStage::TRANSFER_FINALIZED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OpWriteBlockProto_BlockConstructionStage>("OpWriteBlockProto.BlockConstructionStage", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OpWriteBlockProto_BlockConstructionStage {
}

impl ::std::default::Default for OpWriteBlockProto_BlockConstructionStage {
    fn default() -> Self {
        OpWriteBlockProto_BlockConstructionStage::PIPELINE_SETUP_APPEND
    }
}

impl ::protobuf::reflect::ProtobufValue for OpWriteBlockProto_BlockConstructionStage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpTransferBlockProto {
    // message fields
    pub header: ::protobuf::SingularPtrField<ClientOperationHeaderProto>,
    pub targets: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>,
    pub targetStorageTypes: ::std::vec::Vec<super::hdfs::StorageTypeProto>,
    pub targetStorageIds: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpTransferBlockProto {
    fn default() -> &'a OpTransferBlockProto {
        <OpTransferBlockProto as ::protobuf::Message>::default_instance()
    }
}

impl OpTransferBlockProto {
    pub fn new() -> OpTransferBlockProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ClientOperationHeaderProto header = 1;


    pub fn get_header(&self) -> &ClientOperationHeaderProto {
        self.header.as_ref().unwrap_or_else(|| <ClientOperationHeaderProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ClientOperationHeaderProto) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ClientOperationHeaderProto {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ClientOperationHeaderProto {
        self.header.take().unwrap_or_else(|| ClientOperationHeaderProto::new())
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto targets = 2;


    pub fn get_targets(&self) -> &[super::hdfs::DatanodeInfoProto] {
        &self.targets
    }
    pub fn clear_targets(&mut self) {
        self.targets.clear();
    }

    // Param is passed by value, moved
    pub fn set_targets(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>) {
        self.targets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targets(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.targets
    }

    // Take field
    pub fn take_targets(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        ::std::mem::replace(&mut self.targets, ::protobuf::RepeatedField::new())
    }

    // repeated .hadoop.hdfs.StorageTypeProto targetStorageTypes = 3;


    pub fn get_targetStorageTypes(&self) -> &[super::hdfs::StorageTypeProto] {
        &self.targetStorageTypes
    }
    pub fn clear_targetStorageTypes(&mut self) {
        self.targetStorageTypes.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetStorageTypes(&mut self, v: ::std::vec::Vec<super::hdfs::StorageTypeProto>) {
        self.targetStorageTypes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targetStorageTypes(&mut self) -> &mut ::std::vec::Vec<super::hdfs::StorageTypeProto> {
        &mut self.targetStorageTypes
    }

    // Take field
    pub fn take_targetStorageTypes(&mut self) -> ::std::vec::Vec<super::hdfs::StorageTypeProto> {
        ::std::mem::replace(&mut self.targetStorageTypes, ::std::vec::Vec::new())
    }

    // repeated string targetStorageIds = 4;


    pub fn get_targetStorageIds(&self) -> &[::std::string::String] {
        &self.targetStorageIds
    }
    pub fn clear_targetStorageIds(&mut self) {
        self.targetStorageIds.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetStorageIds(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.targetStorageIds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targetStorageIds(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.targetStorageIds
    }

    // Take field
    pub fn take_targetStorageIds(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.targetStorageIds, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OpTransferBlockProto {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.targets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.targets)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.targetStorageTypes, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.targetStorageIds)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.targets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.targetStorageTypes {
            my_size += ::protobuf::rt::enum_size(3, *value);
        };
        for value in &self.targetStorageIds {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.targets {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.targetStorageTypes {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.targetStorageIds {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpTransferBlockProto {
        OpTransferBlockProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientOperationHeaderProto>>(
                "header",
                |m: &OpTransferBlockProto| { &m.header },
                |m: &mut OpTransferBlockProto| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                "targets",
                |m: &OpTransferBlockProto| { &m.targets },
                |m: &mut OpTransferBlockProto| { &mut m.targets },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::StorageTypeProto>>(
                "targetStorageTypes",
                |m: &OpTransferBlockProto| { &m.targetStorageTypes },
                |m: &mut OpTransferBlockProto| { &mut m.targetStorageTypes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "targetStorageIds",
                |m: &OpTransferBlockProto| { &m.targetStorageIds },
                |m: &mut OpTransferBlockProto| { &mut m.targetStorageIds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpTransferBlockProto>(
                "OpTransferBlockProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpTransferBlockProto {
        static instance: ::protobuf::rt::LazyV2<OpTransferBlockProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpTransferBlockProto::new)
    }
}

impl ::protobuf::Clear for OpTransferBlockProto {
    fn clear(&mut self) {
        self.header.clear();
        self.targets.clear();
        self.targetStorageTypes.clear();
        self.targetStorageIds.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpTransferBlockProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpTransferBlockProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpReplaceBlockProto {
    // message fields
    pub header: ::protobuf::SingularPtrField<BaseHeaderProto>,
    delHint: ::protobuf::SingularField<::std::string::String>,
    pub source: ::protobuf::SingularPtrField<super::hdfs::DatanodeInfoProto>,
    storageType: ::std::option::Option<super::hdfs::StorageTypeProto>,
    storageId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpReplaceBlockProto {
    fn default() -> &'a OpReplaceBlockProto {
        <OpReplaceBlockProto as ::protobuf::Message>::default_instance()
    }
}

impl OpReplaceBlockProto {
    pub fn new() -> OpReplaceBlockProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.BaseHeaderProto header = 1;


    pub fn get_header(&self) -> &BaseHeaderProto {
        self.header.as_ref().unwrap_or_else(|| <BaseHeaderProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: BaseHeaderProto) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut BaseHeaderProto {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> BaseHeaderProto {
        self.header.take().unwrap_or_else(|| BaseHeaderProto::new())
    }

    // required string delHint = 2;


    pub fn get_delHint(&self) -> &str {
        match self.delHint.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_delHint(&mut self) {
        self.delHint.clear();
    }

    pub fn has_delHint(&self) -> bool {
        self.delHint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delHint(&mut self, v: ::std::string::String) {
        self.delHint = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delHint(&mut self) -> &mut ::std::string::String {
        if self.delHint.is_none() {
            self.delHint.set_default();
        }
        self.delHint.as_mut().unwrap()
    }

    // Take field
    pub fn take_delHint(&mut self) -> ::std::string::String {
        self.delHint.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.DatanodeInfoProto source = 3;


    pub fn get_source(&self) -> &super::hdfs::DatanodeInfoProto {
        self.source.as_ref().unwrap_or_else(|| <super::hdfs::DatanodeInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: super::hdfs::DatanodeInfoProto) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut super::hdfs::DatanodeInfoProto {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> super::hdfs::DatanodeInfoProto {
        self.source.take().unwrap_or_else(|| super::hdfs::DatanodeInfoProto::new())
    }

    // optional .hadoop.hdfs.StorageTypeProto storageType = 4;


    pub fn get_storageType(&self) -> super::hdfs::StorageTypeProto {
        self.storageType.unwrap_or(super::hdfs::StorageTypeProto::DISK)
    }
    pub fn clear_storageType(&mut self) {
        self.storageType = ::std::option::Option::None;
    }

    pub fn has_storageType(&self) -> bool {
        self.storageType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageType(&mut self, v: super::hdfs::StorageTypeProto) {
        self.storageType = ::std::option::Option::Some(v);
    }

    // optional string storageId = 5;


    pub fn get_storageId(&self) -> &str {
        match self.storageId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_storageId(&mut self) {
        self.storageId.clear();
    }

    pub fn has_storageId(&self) -> bool {
        self.storageId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageId(&mut self, v: ::std::string::String) {
        self.storageId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageId(&mut self) -> &mut ::std::string::String {
        if self.storageId.is_none() {
            self.storageId.set_default();
        }
        self.storageId.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageId(&mut self) -> ::std::string::String {
        self.storageId.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for OpReplaceBlockProto {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        if self.delHint.is_none() {
            return false;
        }
        if self.source.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.delHint)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.storageType, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storageId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.delHint.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.storageType {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.storageId.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.delHint.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.storageType {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.storageId.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpReplaceBlockProto {
        OpReplaceBlockProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BaseHeaderProto>>(
                "header",
                |m: &OpReplaceBlockProto| { &m.header },
                |m: &mut OpReplaceBlockProto| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "delHint",
                |m: &OpReplaceBlockProto| { &m.delHint },
                |m: &mut OpReplaceBlockProto| { &mut m.delHint },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                "source",
                |m: &OpReplaceBlockProto| { &m.source },
                |m: &mut OpReplaceBlockProto| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::StorageTypeProto>>(
                "storageType",
                |m: &OpReplaceBlockProto| { &m.storageType },
                |m: &mut OpReplaceBlockProto| { &mut m.storageType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storageId",
                |m: &OpReplaceBlockProto| { &m.storageId },
                |m: &mut OpReplaceBlockProto| { &mut m.storageId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpReplaceBlockProto>(
                "OpReplaceBlockProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpReplaceBlockProto {
        static instance: ::protobuf::rt::LazyV2<OpReplaceBlockProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpReplaceBlockProto::new)
    }
}

impl ::protobuf::Clear for OpReplaceBlockProto {
    fn clear(&mut self) {
        self.header.clear();
        self.delHint.clear();
        self.source.clear();
        self.storageType = ::std::option::Option::None;
        self.storageId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpReplaceBlockProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpReplaceBlockProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpCopyBlockProto {
    // message fields
    pub header: ::protobuf::SingularPtrField<BaseHeaderProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpCopyBlockProto {
    fn default() -> &'a OpCopyBlockProto {
        <OpCopyBlockProto as ::protobuf::Message>::default_instance()
    }
}

impl OpCopyBlockProto {
    pub fn new() -> OpCopyBlockProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.BaseHeaderProto header = 1;


    pub fn get_header(&self) -> &BaseHeaderProto {
        self.header.as_ref().unwrap_or_else(|| <BaseHeaderProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: BaseHeaderProto) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut BaseHeaderProto {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> BaseHeaderProto {
        self.header.take().unwrap_or_else(|| BaseHeaderProto::new())
    }
}

impl ::protobuf::Message for OpCopyBlockProto {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpCopyBlockProto {
        OpCopyBlockProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BaseHeaderProto>>(
                "header",
                |m: &OpCopyBlockProto| { &m.header },
                |m: &mut OpCopyBlockProto| { &mut m.header },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpCopyBlockProto>(
                "OpCopyBlockProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpCopyBlockProto {
        static instance: ::protobuf::rt::LazyV2<OpCopyBlockProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpCopyBlockProto::new)
    }
}

impl ::protobuf::Clear for OpCopyBlockProto {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpCopyBlockProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpCopyBlockProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpBlockChecksumProto {
    // message fields
    pub header: ::protobuf::SingularPtrField<BaseHeaderProto>,
    pub blockChecksumOptions: ::protobuf::SingularPtrField<super::hdfs::BlockChecksumOptionsProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpBlockChecksumProto {
    fn default() -> &'a OpBlockChecksumProto {
        <OpBlockChecksumProto as ::protobuf::Message>::default_instance()
    }
}

impl OpBlockChecksumProto {
    pub fn new() -> OpBlockChecksumProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.BaseHeaderProto header = 1;


    pub fn get_header(&self) -> &BaseHeaderProto {
        self.header.as_ref().unwrap_or_else(|| <BaseHeaderProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: BaseHeaderProto) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut BaseHeaderProto {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> BaseHeaderProto {
        self.header.take().unwrap_or_else(|| BaseHeaderProto::new())
    }

    // optional .hadoop.hdfs.BlockChecksumOptionsProto blockChecksumOptions = 2;


    pub fn get_blockChecksumOptions(&self) -> &super::hdfs::BlockChecksumOptionsProto {
        self.blockChecksumOptions.as_ref().unwrap_or_else(|| <super::hdfs::BlockChecksumOptionsProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blockChecksumOptions(&mut self) {
        self.blockChecksumOptions.clear();
    }

    pub fn has_blockChecksumOptions(&self) -> bool {
        self.blockChecksumOptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockChecksumOptions(&mut self, v: super::hdfs::BlockChecksumOptionsProto) {
        self.blockChecksumOptions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockChecksumOptions(&mut self) -> &mut super::hdfs::BlockChecksumOptionsProto {
        if self.blockChecksumOptions.is_none() {
            self.blockChecksumOptions.set_default();
        }
        self.blockChecksumOptions.as_mut().unwrap()
    }

    // Take field
    pub fn take_blockChecksumOptions(&mut self) -> super::hdfs::BlockChecksumOptionsProto {
        self.blockChecksumOptions.take().unwrap_or_else(|| super::hdfs::BlockChecksumOptionsProto::new())
    }
}

impl ::protobuf::Message for OpBlockChecksumProto {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blockChecksumOptions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blockChecksumOptions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.blockChecksumOptions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.blockChecksumOptions.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpBlockChecksumProto {
        OpBlockChecksumProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BaseHeaderProto>>(
                "header",
                |m: &OpBlockChecksumProto| { &m.header },
                |m: &mut OpBlockChecksumProto| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::BlockChecksumOptionsProto>>(
                "blockChecksumOptions",
                |m: &OpBlockChecksumProto| { &m.blockChecksumOptions },
                |m: &mut OpBlockChecksumProto| { &mut m.blockChecksumOptions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpBlockChecksumProto>(
                "OpBlockChecksumProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpBlockChecksumProto {
        static instance: ::protobuf::rt::LazyV2<OpBlockChecksumProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpBlockChecksumProto::new)
    }
}

impl ::protobuf::Clear for OpBlockChecksumProto {
    fn clear(&mut self) {
        self.header.clear();
        self.blockChecksumOptions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpBlockChecksumProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpBlockChecksumProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpBlockGroupChecksumProto {
    // message fields
    pub header: ::protobuf::SingularPtrField<BaseHeaderProto>,
    pub datanodes: ::protobuf::SingularPtrField<super::hdfs::DatanodeInfosProto>,
    pub blockTokens: ::protobuf::RepeatedField<super::Security::TokenProto>,
    pub ecPolicy: ::protobuf::SingularPtrField<super::hdfs::ErasureCodingPolicyProto>,
    pub blockIndices: ::std::vec::Vec<u32>,
    requestedNumBytes: ::std::option::Option<u64>,
    pub blockChecksumOptions: ::protobuf::SingularPtrField<super::hdfs::BlockChecksumOptionsProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpBlockGroupChecksumProto {
    fn default() -> &'a OpBlockGroupChecksumProto {
        <OpBlockGroupChecksumProto as ::protobuf::Message>::default_instance()
    }
}

impl OpBlockGroupChecksumProto {
    pub fn new() -> OpBlockGroupChecksumProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.BaseHeaderProto header = 1;


    pub fn get_header(&self) -> &BaseHeaderProto {
        self.header.as_ref().unwrap_or_else(|| <BaseHeaderProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: BaseHeaderProto) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut BaseHeaderProto {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> BaseHeaderProto {
        self.header.take().unwrap_or_else(|| BaseHeaderProto::new())
    }

    // required .hadoop.hdfs.DatanodeInfosProto datanodes = 2;


    pub fn get_datanodes(&self) -> &super::hdfs::DatanodeInfosProto {
        self.datanodes.as_ref().unwrap_or_else(|| <super::hdfs::DatanodeInfosProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_datanodes(&mut self) {
        self.datanodes.clear();
    }

    pub fn has_datanodes(&self) -> bool {
        self.datanodes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datanodes(&mut self, v: super::hdfs::DatanodeInfosProto) {
        self.datanodes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_datanodes(&mut self) -> &mut super::hdfs::DatanodeInfosProto {
        if self.datanodes.is_none() {
            self.datanodes.set_default();
        }
        self.datanodes.as_mut().unwrap()
    }

    // Take field
    pub fn take_datanodes(&mut self) -> super::hdfs::DatanodeInfosProto {
        self.datanodes.take().unwrap_or_else(|| super::hdfs::DatanodeInfosProto::new())
    }

    // repeated .hadoop.common.TokenProto blockTokens = 3;


    pub fn get_blockTokens(&self) -> &[super::Security::TokenProto] {
        &self.blockTokens
    }
    pub fn clear_blockTokens(&mut self) {
        self.blockTokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockTokens(&mut self, v: ::protobuf::RepeatedField<super::Security::TokenProto>) {
        self.blockTokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blockTokens(&mut self) -> &mut ::protobuf::RepeatedField<super::Security::TokenProto> {
        &mut self.blockTokens
    }

    // Take field
    pub fn take_blockTokens(&mut self) -> ::protobuf::RepeatedField<super::Security::TokenProto> {
        ::std::mem::replace(&mut self.blockTokens, ::protobuf::RepeatedField::new())
    }

    // required .hadoop.hdfs.ErasureCodingPolicyProto ecPolicy = 4;


    pub fn get_ecPolicy(&self) -> &super::hdfs::ErasureCodingPolicyProto {
        self.ecPolicy.as_ref().unwrap_or_else(|| <super::hdfs::ErasureCodingPolicyProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ecPolicy(&mut self) {
        self.ecPolicy.clear();
    }

    pub fn has_ecPolicy(&self) -> bool {
        self.ecPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ecPolicy(&mut self, v: super::hdfs::ErasureCodingPolicyProto) {
        self.ecPolicy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ecPolicy(&mut self) -> &mut super::hdfs::ErasureCodingPolicyProto {
        if self.ecPolicy.is_none() {
            self.ecPolicy.set_default();
        }
        self.ecPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_ecPolicy(&mut self) -> super::hdfs::ErasureCodingPolicyProto {
        self.ecPolicy.take().unwrap_or_else(|| super::hdfs::ErasureCodingPolicyProto::new())
    }

    // repeated uint32 blockIndices = 5;


    pub fn get_blockIndices(&self) -> &[u32] {
        &self.blockIndices
    }
    pub fn clear_blockIndices(&mut self) {
        self.blockIndices.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockIndices(&mut self, v: ::std::vec::Vec<u32>) {
        self.blockIndices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blockIndices(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.blockIndices
    }

    // Take field
    pub fn take_blockIndices(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.blockIndices, ::std::vec::Vec::new())
    }

    // required uint64 requestedNumBytes = 6;


    pub fn get_requestedNumBytes(&self) -> u64 {
        self.requestedNumBytes.unwrap_or(0)
    }
    pub fn clear_requestedNumBytes(&mut self) {
        self.requestedNumBytes = ::std::option::Option::None;
    }

    pub fn has_requestedNumBytes(&self) -> bool {
        self.requestedNumBytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requestedNumBytes(&mut self, v: u64) {
        self.requestedNumBytes = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.BlockChecksumOptionsProto blockChecksumOptions = 7;


    pub fn get_blockChecksumOptions(&self) -> &super::hdfs::BlockChecksumOptionsProto {
        self.blockChecksumOptions.as_ref().unwrap_or_else(|| <super::hdfs::BlockChecksumOptionsProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blockChecksumOptions(&mut self) {
        self.blockChecksumOptions.clear();
    }

    pub fn has_blockChecksumOptions(&self) -> bool {
        self.blockChecksumOptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockChecksumOptions(&mut self, v: super::hdfs::BlockChecksumOptionsProto) {
        self.blockChecksumOptions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockChecksumOptions(&mut self) -> &mut super::hdfs::BlockChecksumOptionsProto {
        if self.blockChecksumOptions.is_none() {
            self.blockChecksumOptions.set_default();
        }
        self.blockChecksumOptions.as_mut().unwrap()
    }

    // Take field
    pub fn take_blockChecksumOptions(&mut self) -> super::hdfs::BlockChecksumOptionsProto {
        self.blockChecksumOptions.take().unwrap_or_else(|| super::hdfs::BlockChecksumOptionsProto::new())
    }
}

impl ::protobuf::Message for OpBlockGroupChecksumProto {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        if self.datanodes.is_none() {
            return false;
        }
        if self.ecPolicy.is_none() {
            return false;
        }
        if self.requestedNumBytes.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.datanodes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blockTokens {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ecPolicy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blockChecksumOptions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.datanodes)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blockTokens)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ecPolicy)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.blockIndices)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.requestedNumBytes = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blockChecksumOptions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.datanodes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.blockTokens {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.ecPolicy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.blockIndices {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.requestedNumBytes {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.blockChecksumOptions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.datanodes.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.blockTokens {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.ecPolicy.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.blockIndices {
            os.write_uint32(5, *v)?;
        };
        if let Some(v) = self.requestedNumBytes {
            os.write_uint64(6, v)?;
        }
        if let Some(ref v) = self.blockChecksumOptions.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpBlockGroupChecksumProto {
        OpBlockGroupChecksumProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BaseHeaderProto>>(
                "header",
                |m: &OpBlockGroupChecksumProto| { &m.header },
                |m: &mut OpBlockGroupChecksumProto| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfosProto>>(
                "datanodes",
                |m: &OpBlockGroupChecksumProto| { &m.datanodes },
                |m: &mut OpBlockGroupChecksumProto| { &mut m.datanodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Security::TokenProto>>(
                "blockTokens",
                |m: &OpBlockGroupChecksumProto| { &m.blockTokens },
                |m: &mut OpBlockGroupChecksumProto| { &mut m.blockTokens },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ErasureCodingPolicyProto>>(
                "ecPolicy",
                |m: &OpBlockGroupChecksumProto| { &m.ecPolicy },
                |m: &mut OpBlockGroupChecksumProto| { &mut m.ecPolicy },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "blockIndices",
                |m: &OpBlockGroupChecksumProto| { &m.blockIndices },
                |m: &mut OpBlockGroupChecksumProto| { &mut m.blockIndices },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "requestedNumBytes",
                |m: &OpBlockGroupChecksumProto| { &m.requestedNumBytes },
                |m: &mut OpBlockGroupChecksumProto| { &mut m.requestedNumBytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::BlockChecksumOptionsProto>>(
                "blockChecksumOptions",
                |m: &OpBlockGroupChecksumProto| { &m.blockChecksumOptions },
                |m: &mut OpBlockGroupChecksumProto| { &mut m.blockChecksumOptions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpBlockGroupChecksumProto>(
                "OpBlockGroupChecksumProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpBlockGroupChecksumProto {
        static instance: ::protobuf::rt::LazyV2<OpBlockGroupChecksumProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpBlockGroupChecksumProto::new)
    }
}

impl ::protobuf::Clear for OpBlockGroupChecksumProto {
    fn clear(&mut self) {
        self.header.clear();
        self.datanodes.clear();
        self.blockTokens.clear();
        self.ecPolicy.clear();
        self.blockIndices.clear();
        self.requestedNumBytes = ::std::option::Option::None;
        self.blockChecksumOptions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpBlockGroupChecksumProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpBlockGroupChecksumProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShortCircuitShmIdProto {
    // message fields
    hi: ::std::option::Option<i64>,
    lo: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShortCircuitShmIdProto {
    fn default() -> &'a ShortCircuitShmIdProto {
        <ShortCircuitShmIdProto as ::protobuf::Message>::default_instance()
    }
}

impl ShortCircuitShmIdProto {
    pub fn new() -> ShortCircuitShmIdProto {
        ::std::default::Default::default()
    }

    // required int64 hi = 1;


    pub fn get_hi(&self) -> i64 {
        self.hi.unwrap_or(0)
    }
    pub fn clear_hi(&mut self) {
        self.hi = ::std::option::Option::None;
    }

    pub fn has_hi(&self) -> bool {
        self.hi.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hi(&mut self, v: i64) {
        self.hi = ::std::option::Option::Some(v);
    }

    // required int64 lo = 2;


    pub fn get_lo(&self) -> i64 {
        self.lo.unwrap_or(0)
    }
    pub fn clear_lo(&mut self) {
        self.lo = ::std::option::Option::None;
    }

    pub fn has_lo(&self) -> bool {
        self.lo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lo(&mut self, v: i64) {
        self.lo = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ShortCircuitShmIdProto {
    fn is_initialized(&self) -> bool {
        if self.hi.is_none() {
            return false;
        }
        if self.lo.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.hi = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lo = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hi {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lo {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hi {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.lo {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShortCircuitShmIdProto {
        ShortCircuitShmIdProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "hi",
                |m: &ShortCircuitShmIdProto| { &m.hi },
                |m: &mut ShortCircuitShmIdProto| { &mut m.hi },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "lo",
                |m: &ShortCircuitShmIdProto| { &m.lo },
                |m: &mut ShortCircuitShmIdProto| { &mut m.lo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShortCircuitShmIdProto>(
                "ShortCircuitShmIdProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShortCircuitShmIdProto {
        static instance: ::protobuf::rt::LazyV2<ShortCircuitShmIdProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShortCircuitShmIdProto::new)
    }
}

impl ::protobuf::Clear for ShortCircuitShmIdProto {
    fn clear(&mut self) {
        self.hi = ::std::option::Option::None;
        self.lo = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShortCircuitShmIdProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShortCircuitShmIdProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShortCircuitShmSlotProto {
    // message fields
    pub shmId: ::protobuf::SingularPtrField<ShortCircuitShmIdProto>,
    slotIdx: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShortCircuitShmSlotProto {
    fn default() -> &'a ShortCircuitShmSlotProto {
        <ShortCircuitShmSlotProto as ::protobuf::Message>::default_instance()
    }
}

impl ShortCircuitShmSlotProto {
    pub fn new() -> ShortCircuitShmSlotProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ShortCircuitShmIdProto shmId = 1;


    pub fn get_shmId(&self) -> &ShortCircuitShmIdProto {
        self.shmId.as_ref().unwrap_or_else(|| <ShortCircuitShmIdProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_shmId(&mut self) {
        self.shmId.clear();
    }

    pub fn has_shmId(&self) -> bool {
        self.shmId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shmId(&mut self, v: ShortCircuitShmIdProto) {
        self.shmId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shmId(&mut self) -> &mut ShortCircuitShmIdProto {
        if self.shmId.is_none() {
            self.shmId.set_default();
        }
        self.shmId.as_mut().unwrap()
    }

    // Take field
    pub fn take_shmId(&mut self) -> ShortCircuitShmIdProto {
        self.shmId.take().unwrap_or_else(|| ShortCircuitShmIdProto::new())
    }

    // required int32 slotIdx = 2;


    pub fn get_slotIdx(&self) -> i32 {
        self.slotIdx.unwrap_or(0)
    }
    pub fn clear_slotIdx(&mut self) {
        self.slotIdx = ::std::option::Option::None;
    }

    pub fn has_slotIdx(&self) -> bool {
        self.slotIdx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slotIdx(&mut self, v: i32) {
        self.slotIdx = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ShortCircuitShmSlotProto {
    fn is_initialized(&self) -> bool {
        if self.shmId.is_none() {
            return false;
        }
        if self.slotIdx.is_none() {
            return false;
        }
        for v in &self.shmId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shmId)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.slotIdx = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.shmId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.slotIdx {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.shmId.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.slotIdx {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShortCircuitShmSlotProto {
        ShortCircuitShmSlotProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShortCircuitShmIdProto>>(
                "shmId",
                |m: &ShortCircuitShmSlotProto| { &m.shmId },
                |m: &mut ShortCircuitShmSlotProto| { &mut m.shmId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "slotIdx",
                |m: &ShortCircuitShmSlotProto| { &m.slotIdx },
                |m: &mut ShortCircuitShmSlotProto| { &mut m.slotIdx },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShortCircuitShmSlotProto>(
                "ShortCircuitShmSlotProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShortCircuitShmSlotProto {
        static instance: ::protobuf::rt::LazyV2<ShortCircuitShmSlotProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShortCircuitShmSlotProto::new)
    }
}

impl ::protobuf::Clear for ShortCircuitShmSlotProto {
    fn clear(&mut self) {
        self.shmId.clear();
        self.slotIdx = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShortCircuitShmSlotProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShortCircuitShmSlotProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpRequestShortCircuitAccessProto {
    // message fields
    pub header: ::protobuf::SingularPtrField<BaseHeaderProto>,
    maxVersion: ::std::option::Option<u32>,
    pub slotId: ::protobuf::SingularPtrField<ShortCircuitShmSlotProto>,
    supportsReceiptVerification: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpRequestShortCircuitAccessProto {
    fn default() -> &'a OpRequestShortCircuitAccessProto {
        <OpRequestShortCircuitAccessProto as ::protobuf::Message>::default_instance()
    }
}

impl OpRequestShortCircuitAccessProto {
    pub fn new() -> OpRequestShortCircuitAccessProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.BaseHeaderProto header = 1;


    pub fn get_header(&self) -> &BaseHeaderProto {
        self.header.as_ref().unwrap_or_else(|| <BaseHeaderProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: BaseHeaderProto) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut BaseHeaderProto {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> BaseHeaderProto {
        self.header.take().unwrap_or_else(|| BaseHeaderProto::new())
    }

    // required uint32 maxVersion = 2;


    pub fn get_maxVersion(&self) -> u32 {
        self.maxVersion.unwrap_or(0)
    }
    pub fn clear_maxVersion(&mut self) {
        self.maxVersion = ::std::option::Option::None;
    }

    pub fn has_maxVersion(&self) -> bool {
        self.maxVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxVersion(&mut self, v: u32) {
        self.maxVersion = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.ShortCircuitShmSlotProto slotId = 3;


    pub fn get_slotId(&self) -> &ShortCircuitShmSlotProto {
        self.slotId.as_ref().unwrap_or_else(|| <ShortCircuitShmSlotProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_slotId(&mut self) {
        self.slotId.clear();
    }

    pub fn has_slotId(&self) -> bool {
        self.slotId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slotId(&mut self, v: ShortCircuitShmSlotProto) {
        self.slotId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_slotId(&mut self) -> &mut ShortCircuitShmSlotProto {
        if self.slotId.is_none() {
            self.slotId.set_default();
        }
        self.slotId.as_mut().unwrap()
    }

    // Take field
    pub fn take_slotId(&mut self) -> ShortCircuitShmSlotProto {
        self.slotId.take().unwrap_or_else(|| ShortCircuitShmSlotProto::new())
    }

    // optional bool supportsReceiptVerification = 4;


    pub fn get_supportsReceiptVerification(&self) -> bool {
        self.supportsReceiptVerification.unwrap_or(false)
    }
    pub fn clear_supportsReceiptVerification(&mut self) {
        self.supportsReceiptVerification = ::std::option::Option::None;
    }

    pub fn has_supportsReceiptVerification(&self) -> bool {
        self.supportsReceiptVerification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supportsReceiptVerification(&mut self, v: bool) {
        self.supportsReceiptVerification = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for OpRequestShortCircuitAccessProto {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        if self.maxVersion.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.slotId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maxVersion = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.slotId)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supportsReceiptVerification = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.maxVersion {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.slotId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.supportsReceiptVerification {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.maxVersion {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.slotId.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.supportsReceiptVerification {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpRequestShortCircuitAccessProto {
        OpRequestShortCircuitAccessProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BaseHeaderProto>>(
                "header",
                |m: &OpRequestShortCircuitAccessProto| { &m.header },
                |m: &mut OpRequestShortCircuitAccessProto| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "maxVersion",
                |m: &OpRequestShortCircuitAccessProto| { &m.maxVersion },
                |m: &mut OpRequestShortCircuitAccessProto| { &mut m.maxVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShortCircuitShmSlotProto>>(
                "slotId",
                |m: &OpRequestShortCircuitAccessProto| { &m.slotId },
                |m: &mut OpRequestShortCircuitAccessProto| { &mut m.slotId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supportsReceiptVerification",
                |m: &OpRequestShortCircuitAccessProto| { &m.supportsReceiptVerification },
                |m: &mut OpRequestShortCircuitAccessProto| { &mut m.supportsReceiptVerification },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpRequestShortCircuitAccessProto>(
                "OpRequestShortCircuitAccessProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpRequestShortCircuitAccessProto {
        static instance: ::protobuf::rt::LazyV2<OpRequestShortCircuitAccessProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpRequestShortCircuitAccessProto::new)
    }
}

impl ::protobuf::Clear for OpRequestShortCircuitAccessProto {
    fn clear(&mut self) {
        self.header.clear();
        self.maxVersion = ::std::option::Option::None;
        self.slotId.clear();
        self.supportsReceiptVerification = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpRequestShortCircuitAccessProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpRequestShortCircuitAccessProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReleaseShortCircuitAccessRequestProto {
    // message fields
    pub slotId: ::protobuf::SingularPtrField<ShortCircuitShmSlotProto>,
    pub traceInfo: ::protobuf::SingularPtrField<DataTransferTraceInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReleaseShortCircuitAccessRequestProto {
    fn default() -> &'a ReleaseShortCircuitAccessRequestProto {
        <ReleaseShortCircuitAccessRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ReleaseShortCircuitAccessRequestProto {
    pub fn new() -> ReleaseShortCircuitAccessRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ShortCircuitShmSlotProto slotId = 1;


    pub fn get_slotId(&self) -> &ShortCircuitShmSlotProto {
        self.slotId.as_ref().unwrap_or_else(|| <ShortCircuitShmSlotProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_slotId(&mut self) {
        self.slotId.clear();
    }

    pub fn has_slotId(&self) -> bool {
        self.slotId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slotId(&mut self, v: ShortCircuitShmSlotProto) {
        self.slotId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_slotId(&mut self) -> &mut ShortCircuitShmSlotProto {
        if self.slotId.is_none() {
            self.slotId.set_default();
        }
        self.slotId.as_mut().unwrap()
    }

    // Take field
    pub fn take_slotId(&mut self) -> ShortCircuitShmSlotProto {
        self.slotId.take().unwrap_or_else(|| ShortCircuitShmSlotProto::new())
    }

    // optional .hadoop.hdfs.DataTransferTraceInfoProto traceInfo = 2;


    pub fn get_traceInfo(&self) -> &DataTransferTraceInfoProto {
        self.traceInfo.as_ref().unwrap_or_else(|| <DataTransferTraceInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_traceInfo(&mut self) {
        self.traceInfo.clear();
    }

    pub fn has_traceInfo(&self) -> bool {
        self.traceInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_traceInfo(&mut self, v: DataTransferTraceInfoProto) {
        self.traceInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_traceInfo(&mut self) -> &mut DataTransferTraceInfoProto {
        if self.traceInfo.is_none() {
            self.traceInfo.set_default();
        }
        self.traceInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_traceInfo(&mut self) -> DataTransferTraceInfoProto {
        self.traceInfo.take().unwrap_or_else(|| DataTransferTraceInfoProto::new())
    }
}

impl ::protobuf::Message for ReleaseShortCircuitAccessRequestProto {
    fn is_initialized(&self) -> bool {
        if self.slotId.is_none() {
            return false;
        }
        for v in &self.slotId {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.traceInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.slotId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.traceInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.slotId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.traceInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.slotId.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.traceInfo.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReleaseShortCircuitAccessRequestProto {
        ReleaseShortCircuitAccessRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShortCircuitShmSlotProto>>(
                "slotId",
                |m: &ReleaseShortCircuitAccessRequestProto| { &m.slotId },
                |m: &mut ReleaseShortCircuitAccessRequestProto| { &mut m.slotId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataTransferTraceInfoProto>>(
                "traceInfo",
                |m: &ReleaseShortCircuitAccessRequestProto| { &m.traceInfo },
                |m: &mut ReleaseShortCircuitAccessRequestProto| { &mut m.traceInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReleaseShortCircuitAccessRequestProto>(
                "ReleaseShortCircuitAccessRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReleaseShortCircuitAccessRequestProto {
        static instance: ::protobuf::rt::LazyV2<ReleaseShortCircuitAccessRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReleaseShortCircuitAccessRequestProto::new)
    }
}

impl ::protobuf::Clear for ReleaseShortCircuitAccessRequestProto {
    fn clear(&mut self) {
        self.slotId.clear();
        self.traceInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReleaseShortCircuitAccessRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReleaseShortCircuitAccessRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReleaseShortCircuitAccessResponseProto {
    // message fields
    status: ::std::option::Option<Status>,
    error: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReleaseShortCircuitAccessResponseProto {
    fn default() -> &'a ReleaseShortCircuitAccessResponseProto {
        <ReleaseShortCircuitAccessResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ReleaseShortCircuitAccessResponseProto {
    pub fn new() -> ReleaseShortCircuitAccessResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.Status status = 1;


    pub fn get_status(&self) -> Status {
        self.status.unwrap_or(Status::SUCCESS)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional string error = 2;


    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ReleaseShortCircuitAccessResponseProto {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReleaseShortCircuitAccessResponseProto {
        ReleaseShortCircuitAccessResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                "status",
                |m: &ReleaseShortCircuitAccessResponseProto| { &m.status },
                |m: &mut ReleaseShortCircuitAccessResponseProto| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error",
                |m: &ReleaseShortCircuitAccessResponseProto| { &m.error },
                |m: &mut ReleaseShortCircuitAccessResponseProto| { &mut m.error },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReleaseShortCircuitAccessResponseProto>(
                "ReleaseShortCircuitAccessResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReleaseShortCircuitAccessResponseProto {
        static instance: ::protobuf::rt::LazyV2<ReleaseShortCircuitAccessResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReleaseShortCircuitAccessResponseProto::new)
    }
}

impl ::protobuf::Clear for ReleaseShortCircuitAccessResponseProto {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReleaseShortCircuitAccessResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReleaseShortCircuitAccessResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShortCircuitShmRequestProto {
    // message fields
    clientName: ::protobuf::SingularField<::std::string::String>,
    pub traceInfo: ::protobuf::SingularPtrField<DataTransferTraceInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShortCircuitShmRequestProto {
    fn default() -> &'a ShortCircuitShmRequestProto {
        <ShortCircuitShmRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ShortCircuitShmRequestProto {
    pub fn new() -> ShortCircuitShmRequestProto {
        ::std::default::Default::default()
    }

    // required string clientName = 1;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .hadoop.hdfs.DataTransferTraceInfoProto traceInfo = 2;


    pub fn get_traceInfo(&self) -> &DataTransferTraceInfoProto {
        self.traceInfo.as_ref().unwrap_or_else(|| <DataTransferTraceInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_traceInfo(&mut self) {
        self.traceInfo.clear();
    }

    pub fn has_traceInfo(&self) -> bool {
        self.traceInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_traceInfo(&mut self, v: DataTransferTraceInfoProto) {
        self.traceInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_traceInfo(&mut self) -> &mut DataTransferTraceInfoProto {
        if self.traceInfo.is_none() {
            self.traceInfo.set_default();
        }
        self.traceInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_traceInfo(&mut self) -> DataTransferTraceInfoProto {
        self.traceInfo.take().unwrap_or_else(|| DataTransferTraceInfoProto::new())
    }
}

impl ::protobuf::Message for ShortCircuitShmRequestProto {
    fn is_initialized(&self) -> bool {
        if self.clientName.is_none() {
            return false;
        }
        for v in &self.traceInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.traceInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.traceInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.traceInfo.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShortCircuitShmRequestProto {
        ShortCircuitShmRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientName",
                |m: &ShortCircuitShmRequestProto| { &m.clientName },
                |m: &mut ShortCircuitShmRequestProto| { &mut m.clientName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataTransferTraceInfoProto>>(
                "traceInfo",
                |m: &ShortCircuitShmRequestProto| { &m.traceInfo },
                |m: &mut ShortCircuitShmRequestProto| { &mut m.traceInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShortCircuitShmRequestProto>(
                "ShortCircuitShmRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShortCircuitShmRequestProto {
        static instance: ::protobuf::rt::LazyV2<ShortCircuitShmRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShortCircuitShmRequestProto::new)
    }
}

impl ::protobuf::Clear for ShortCircuitShmRequestProto {
    fn clear(&mut self) {
        self.clientName.clear();
        self.traceInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShortCircuitShmRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShortCircuitShmRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShortCircuitShmResponseProto {
    // message fields
    status: ::std::option::Option<Status>,
    error: ::protobuf::SingularField<::std::string::String>,
    pub id: ::protobuf::SingularPtrField<ShortCircuitShmIdProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShortCircuitShmResponseProto {
    fn default() -> &'a ShortCircuitShmResponseProto {
        <ShortCircuitShmResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ShortCircuitShmResponseProto {
    pub fn new() -> ShortCircuitShmResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.Status status = 1;


    pub fn get_status(&self) -> Status {
        self.status.unwrap_or(Status::SUCCESS)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional string error = 2;


    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .hadoop.hdfs.ShortCircuitShmIdProto id = 3;


    pub fn get_id(&self) -> &ShortCircuitShmIdProto {
        self.id.as_ref().unwrap_or_else(|| <ShortCircuitShmIdProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ShortCircuitShmIdProto) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ShortCircuitShmIdProto {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ShortCircuitShmIdProto {
        self.id.take().unwrap_or_else(|| ShortCircuitShmIdProto::new())
    }
}

impl ::protobuf::Message for ShortCircuitShmResponseProto {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShortCircuitShmResponseProto {
        ShortCircuitShmResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                "status",
                |m: &ShortCircuitShmResponseProto| { &m.status },
                |m: &mut ShortCircuitShmResponseProto| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error",
                |m: &ShortCircuitShmResponseProto| { &m.error },
                |m: &mut ShortCircuitShmResponseProto| { &mut m.error },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShortCircuitShmIdProto>>(
                "id",
                |m: &ShortCircuitShmResponseProto| { &m.id },
                |m: &mut ShortCircuitShmResponseProto| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShortCircuitShmResponseProto>(
                "ShortCircuitShmResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShortCircuitShmResponseProto {
        static instance: ::protobuf::rt::LazyV2<ShortCircuitShmResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShortCircuitShmResponseProto::new)
    }
}

impl ::protobuf::Clear for ShortCircuitShmResponseProto {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.error.clear();
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShortCircuitShmResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShortCircuitShmResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PacketHeaderProto {
    // message fields
    offsetInBlock: ::std::option::Option<i64>,
    seqno: ::std::option::Option<i64>,
    lastPacketInBlock: ::std::option::Option<bool>,
    dataLen: ::std::option::Option<i32>,
    syncBlock: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PacketHeaderProto {
    fn default() -> &'a PacketHeaderProto {
        <PacketHeaderProto as ::protobuf::Message>::default_instance()
    }
}

impl PacketHeaderProto {
    pub fn new() -> PacketHeaderProto {
        ::std::default::Default::default()
    }

    // required sfixed64 offsetInBlock = 1;


    pub fn get_offsetInBlock(&self) -> i64 {
        self.offsetInBlock.unwrap_or(0)
    }
    pub fn clear_offsetInBlock(&mut self) {
        self.offsetInBlock = ::std::option::Option::None;
    }

    pub fn has_offsetInBlock(&self) -> bool {
        self.offsetInBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offsetInBlock(&mut self, v: i64) {
        self.offsetInBlock = ::std::option::Option::Some(v);
    }

    // required sfixed64 seqno = 2;


    pub fn get_seqno(&self) -> i64 {
        self.seqno.unwrap_or(0)
    }
    pub fn clear_seqno(&mut self) {
        self.seqno = ::std::option::Option::None;
    }

    pub fn has_seqno(&self) -> bool {
        self.seqno.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seqno(&mut self, v: i64) {
        self.seqno = ::std::option::Option::Some(v);
    }

    // required bool lastPacketInBlock = 3;


    pub fn get_lastPacketInBlock(&self) -> bool {
        self.lastPacketInBlock.unwrap_or(false)
    }
    pub fn clear_lastPacketInBlock(&mut self) {
        self.lastPacketInBlock = ::std::option::Option::None;
    }

    pub fn has_lastPacketInBlock(&self) -> bool {
        self.lastPacketInBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastPacketInBlock(&mut self, v: bool) {
        self.lastPacketInBlock = ::std::option::Option::Some(v);
    }

    // required sfixed32 dataLen = 4;


    pub fn get_dataLen(&self) -> i32 {
        self.dataLen.unwrap_or(0)
    }
    pub fn clear_dataLen(&mut self) {
        self.dataLen = ::std::option::Option::None;
    }

    pub fn has_dataLen(&self) -> bool {
        self.dataLen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dataLen(&mut self, v: i32) {
        self.dataLen = ::std::option::Option::Some(v);
    }

    // optional bool syncBlock = 5;


    pub fn get_syncBlock(&self) -> bool {
        self.syncBlock.unwrap_or(false)
    }
    pub fn clear_syncBlock(&mut self) {
        self.syncBlock = ::std::option::Option::None;
    }

    pub fn has_syncBlock(&self) -> bool {
        self.syncBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_syncBlock(&mut self, v: bool) {
        self.syncBlock = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PacketHeaderProto {
    fn is_initialized(&self) -> bool {
        if self.offsetInBlock.is_none() {
            return false;
        }
        if self.seqno.is_none() {
            return false;
        }
        if self.lastPacketInBlock.is_none() {
            return false;
        }
        if self.dataLen.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sfixed64()?;
                    self.offsetInBlock = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sfixed64()?;
                    self.seqno = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.lastPacketInBlock = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sfixed32()?;
                    self.dataLen = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.syncBlock = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.offsetInBlock {
            my_size += 9;
        }
        if let Some(v) = self.seqno {
            my_size += 9;
        }
        if let Some(v) = self.lastPacketInBlock {
            my_size += 2;
        }
        if let Some(v) = self.dataLen {
            my_size += 5;
        }
        if let Some(v) = self.syncBlock {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.offsetInBlock {
            os.write_sfixed64(1, v)?;
        }
        if let Some(v) = self.seqno {
            os.write_sfixed64(2, v)?;
        }
        if let Some(v) = self.lastPacketInBlock {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.dataLen {
            os.write_sfixed32(4, v)?;
        }
        if let Some(v) = self.syncBlock {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PacketHeaderProto {
        PacketHeaderProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSfixed64>(
                "offsetInBlock",
                |m: &PacketHeaderProto| { &m.offsetInBlock },
                |m: &mut PacketHeaderProto| { &mut m.offsetInBlock },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSfixed64>(
                "seqno",
                |m: &PacketHeaderProto| { &m.seqno },
                |m: &mut PacketHeaderProto| { &mut m.seqno },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "lastPacketInBlock",
                |m: &PacketHeaderProto| { &m.lastPacketInBlock },
                |m: &mut PacketHeaderProto| { &mut m.lastPacketInBlock },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSfixed32>(
                "dataLen",
                |m: &PacketHeaderProto| { &m.dataLen },
                |m: &mut PacketHeaderProto| { &mut m.dataLen },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "syncBlock",
                |m: &PacketHeaderProto| { &m.syncBlock },
                |m: &mut PacketHeaderProto| { &mut m.syncBlock },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PacketHeaderProto>(
                "PacketHeaderProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PacketHeaderProto {
        static instance: ::protobuf::rt::LazyV2<PacketHeaderProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PacketHeaderProto::new)
    }
}

impl ::protobuf::Clear for PacketHeaderProto {
    fn clear(&mut self) {
        self.offsetInBlock = ::std::option::Option::None;
        self.seqno = ::std::option::Option::None;
        self.lastPacketInBlock = ::std::option::Option::None;
        self.dataLen = ::std::option::Option::None;
        self.syncBlock = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PacketHeaderProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PacketHeaderProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PipelineAckProto {
    // message fields
    seqno: ::std::option::Option<i64>,
    pub reply: ::std::vec::Vec<Status>,
    downstreamAckTimeNanos: ::std::option::Option<u64>,
    pub flag: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PipelineAckProto {
    fn default() -> &'a PipelineAckProto {
        <PipelineAckProto as ::protobuf::Message>::default_instance()
    }
}

impl PipelineAckProto {
    pub fn new() -> PipelineAckProto {
        ::std::default::Default::default()
    }

    // required sint64 seqno = 1;


    pub fn get_seqno(&self) -> i64 {
        self.seqno.unwrap_or(0)
    }
    pub fn clear_seqno(&mut self) {
        self.seqno = ::std::option::Option::None;
    }

    pub fn has_seqno(&self) -> bool {
        self.seqno.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seqno(&mut self, v: i64) {
        self.seqno = ::std::option::Option::Some(v);
    }

    // repeated .hadoop.hdfs.Status reply = 2;


    pub fn get_reply(&self) -> &[Status] {
        &self.reply
    }
    pub fn clear_reply(&mut self) {
        self.reply.clear();
    }

    // Param is passed by value, moved
    pub fn set_reply(&mut self, v: ::std::vec::Vec<Status>) {
        self.reply = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reply(&mut self) -> &mut ::std::vec::Vec<Status> {
        &mut self.reply
    }

    // Take field
    pub fn take_reply(&mut self) -> ::std::vec::Vec<Status> {
        ::std::mem::replace(&mut self.reply, ::std::vec::Vec::new())
    }

    // optional uint64 downstreamAckTimeNanos = 3;


    pub fn get_downstreamAckTimeNanos(&self) -> u64 {
        self.downstreamAckTimeNanos.unwrap_or(0u64)
    }
    pub fn clear_downstreamAckTimeNanos(&mut self) {
        self.downstreamAckTimeNanos = ::std::option::Option::None;
    }

    pub fn has_downstreamAckTimeNanos(&self) -> bool {
        self.downstreamAckTimeNanos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_downstreamAckTimeNanos(&mut self, v: u64) {
        self.downstreamAckTimeNanos = ::std::option::Option::Some(v);
    }

    // repeated uint32 flag = 4;


    pub fn get_flag(&self) -> &[u32] {
        &self.flag
    }
    pub fn clear_flag(&mut self) {
        self.flag.clear();
    }

    // Param is passed by value, moved
    pub fn set_flag(&mut self, v: ::std::vec::Vec<u32>) {
        self.flag = v;
    }

    // Mutable pointer to the field.
    pub fn mut_flag(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.flag
    }

    // Take field
    pub fn take_flag(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.flag, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PipelineAckProto {
    fn is_initialized(&self) -> bool {
        if self.seqno.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.seqno = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.reply, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.downstreamAckTimeNanos = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.flag)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.seqno {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, v);
        }
        for value in &self.reply {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        if let Some(v) = self.downstreamAckTimeNanos {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.flag.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(4, &self.flag);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.seqno {
            os.write_sint64(1, v)?;
        }
        for v in &self.reply {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(v))?;
        };
        if let Some(v) = self.downstreamAckTimeNanos {
            os.write_uint64(3, v)?;
        }
        if !self.flag.is_empty() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.flag))?;
            for v in &self.flag {
                os.write_uint32_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PipelineAckProto {
        PipelineAckProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "seqno",
                |m: &PipelineAckProto| { &m.seqno },
                |m: &mut PipelineAckProto| { &mut m.seqno },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                "reply",
                |m: &PipelineAckProto| { &m.reply },
                |m: &mut PipelineAckProto| { &mut m.reply },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "downstreamAckTimeNanos",
                |m: &PipelineAckProto| { &m.downstreamAckTimeNanos },
                |m: &mut PipelineAckProto| { &mut m.downstreamAckTimeNanos },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flag",
                |m: &PipelineAckProto| { &m.flag },
                |m: &mut PipelineAckProto| { &mut m.flag },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PipelineAckProto>(
                "PipelineAckProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PipelineAckProto {
        static instance: ::protobuf::rt::LazyV2<PipelineAckProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PipelineAckProto::new)
    }
}

impl ::protobuf::Clear for PipelineAckProto {
    fn clear(&mut self) {
        self.seqno = ::std::option::Option::None;
        self.reply.clear();
        self.downstreamAckTimeNanos = ::std::option::Option::None;
        self.flag.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PipelineAckProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PipelineAckProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadOpChecksumInfoProto {
    // message fields
    pub checksum: ::protobuf::SingularPtrField<ChecksumProto>,
    chunkOffset: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadOpChecksumInfoProto {
    fn default() -> &'a ReadOpChecksumInfoProto {
        <ReadOpChecksumInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl ReadOpChecksumInfoProto {
    pub fn new() -> ReadOpChecksumInfoProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ChecksumProto checksum = 1;


    pub fn get_checksum(&self) -> &ChecksumProto {
        self.checksum.as_ref().unwrap_or_else(|| <ChecksumProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_checksum(&mut self) {
        self.checksum.clear();
    }

    pub fn has_checksum(&self) -> bool {
        self.checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checksum(&mut self, v: ChecksumProto) {
        self.checksum = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_checksum(&mut self) -> &mut ChecksumProto {
        if self.checksum.is_none() {
            self.checksum.set_default();
        }
        self.checksum.as_mut().unwrap()
    }

    // Take field
    pub fn take_checksum(&mut self) -> ChecksumProto {
        self.checksum.take().unwrap_or_else(|| ChecksumProto::new())
    }

    // required uint64 chunkOffset = 2;


    pub fn get_chunkOffset(&self) -> u64 {
        self.chunkOffset.unwrap_or(0)
    }
    pub fn clear_chunkOffset(&mut self) {
        self.chunkOffset = ::std::option::Option::None;
    }

    pub fn has_chunkOffset(&self) -> bool {
        self.chunkOffset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chunkOffset(&mut self, v: u64) {
        self.chunkOffset = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ReadOpChecksumInfoProto {
    fn is_initialized(&self) -> bool {
        if self.checksum.is_none() {
            return false;
        }
        if self.chunkOffset.is_none() {
            return false;
        }
        for v in &self.checksum {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checksum)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chunkOffset = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.checksum.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.chunkOffset {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.checksum.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.chunkOffset {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadOpChecksumInfoProto {
        ReadOpChecksumInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChecksumProto>>(
                "checksum",
                |m: &ReadOpChecksumInfoProto| { &m.checksum },
                |m: &mut ReadOpChecksumInfoProto| { &mut m.checksum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chunkOffset",
                |m: &ReadOpChecksumInfoProto| { &m.chunkOffset },
                |m: &mut ReadOpChecksumInfoProto| { &mut m.chunkOffset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadOpChecksumInfoProto>(
                "ReadOpChecksumInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReadOpChecksumInfoProto {
        static instance: ::protobuf::rt::LazyV2<ReadOpChecksumInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReadOpChecksumInfoProto::new)
    }
}

impl ::protobuf::Clear for ReadOpChecksumInfoProto {
    fn clear(&mut self) {
        self.checksum.clear();
        self.chunkOffset = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadOpChecksumInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadOpChecksumInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockOpResponseProto {
    // message fields
    status: ::std::option::Option<Status>,
    firstBadLink: ::protobuf::SingularField<::std::string::String>,
    pub checksumResponse: ::protobuf::SingularPtrField<OpBlockChecksumResponseProto>,
    pub readOpChecksumInfo: ::protobuf::SingularPtrField<ReadOpChecksumInfoProto>,
    message: ::protobuf::SingularField<::std::string::String>,
    shortCircuitAccessVersion: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockOpResponseProto {
    fn default() -> &'a BlockOpResponseProto {
        <BlockOpResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl BlockOpResponseProto {
    pub fn new() -> BlockOpResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.Status status = 1;


    pub fn get_status(&self) -> Status {
        self.status.unwrap_or(Status::SUCCESS)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional string firstBadLink = 2;


    pub fn get_firstBadLink(&self) -> &str {
        match self.firstBadLink.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_firstBadLink(&mut self) {
        self.firstBadLink.clear();
    }

    pub fn has_firstBadLink(&self) -> bool {
        self.firstBadLink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstBadLink(&mut self, v: ::std::string::String) {
        self.firstBadLink = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_firstBadLink(&mut self) -> &mut ::std::string::String {
        if self.firstBadLink.is_none() {
            self.firstBadLink.set_default();
        }
        self.firstBadLink.as_mut().unwrap()
    }

    // Take field
    pub fn take_firstBadLink(&mut self) -> ::std::string::String {
        self.firstBadLink.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .hadoop.hdfs.OpBlockChecksumResponseProto checksumResponse = 3;


    pub fn get_checksumResponse(&self) -> &OpBlockChecksumResponseProto {
        self.checksumResponse.as_ref().unwrap_or_else(|| <OpBlockChecksumResponseProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_checksumResponse(&mut self) {
        self.checksumResponse.clear();
    }

    pub fn has_checksumResponse(&self) -> bool {
        self.checksumResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checksumResponse(&mut self, v: OpBlockChecksumResponseProto) {
        self.checksumResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_checksumResponse(&mut self) -> &mut OpBlockChecksumResponseProto {
        if self.checksumResponse.is_none() {
            self.checksumResponse.set_default();
        }
        self.checksumResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_checksumResponse(&mut self) -> OpBlockChecksumResponseProto {
        self.checksumResponse.take().unwrap_or_else(|| OpBlockChecksumResponseProto::new())
    }

    // optional .hadoop.hdfs.ReadOpChecksumInfoProto readOpChecksumInfo = 4;


    pub fn get_readOpChecksumInfo(&self) -> &ReadOpChecksumInfoProto {
        self.readOpChecksumInfo.as_ref().unwrap_or_else(|| <ReadOpChecksumInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_readOpChecksumInfo(&mut self) {
        self.readOpChecksumInfo.clear();
    }

    pub fn has_readOpChecksumInfo(&self) -> bool {
        self.readOpChecksumInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOpChecksumInfo(&mut self, v: ReadOpChecksumInfoProto) {
        self.readOpChecksumInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readOpChecksumInfo(&mut self) -> &mut ReadOpChecksumInfoProto {
        if self.readOpChecksumInfo.is_none() {
            self.readOpChecksumInfo.set_default();
        }
        self.readOpChecksumInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_readOpChecksumInfo(&mut self) -> ReadOpChecksumInfoProto {
        self.readOpChecksumInfo.take().unwrap_or_else(|| ReadOpChecksumInfoProto::new())
    }

    // optional string message = 5;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 shortCircuitAccessVersion = 6;


    pub fn get_shortCircuitAccessVersion(&self) -> u32 {
        self.shortCircuitAccessVersion.unwrap_or(0)
    }
    pub fn clear_shortCircuitAccessVersion(&mut self) {
        self.shortCircuitAccessVersion = ::std::option::Option::None;
    }

    pub fn has_shortCircuitAccessVersion(&self) -> bool {
        self.shortCircuitAccessVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shortCircuitAccessVersion(&mut self, v: u32) {
        self.shortCircuitAccessVersion = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BlockOpResponseProto {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        for v in &self.checksumResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.readOpChecksumInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.firstBadLink)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checksumResponse)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.readOpChecksumInfo)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shortCircuitAccessVersion = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.firstBadLink.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.checksumResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.readOpChecksumInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.shortCircuitAccessVersion {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.firstBadLink.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.checksumResponse.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.readOpChecksumInfo.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.shortCircuitAccessVersion {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockOpResponseProto {
        BlockOpResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                "status",
                |m: &BlockOpResponseProto| { &m.status },
                |m: &mut BlockOpResponseProto| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "firstBadLink",
                |m: &BlockOpResponseProto| { &m.firstBadLink },
                |m: &mut BlockOpResponseProto| { &mut m.firstBadLink },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpBlockChecksumResponseProto>>(
                "checksumResponse",
                |m: &BlockOpResponseProto| { &m.checksumResponse },
                |m: &mut BlockOpResponseProto| { &mut m.checksumResponse },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReadOpChecksumInfoProto>>(
                "readOpChecksumInfo",
                |m: &BlockOpResponseProto| { &m.readOpChecksumInfo },
                |m: &mut BlockOpResponseProto| { &mut m.readOpChecksumInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &BlockOpResponseProto| { &m.message },
                |m: &mut BlockOpResponseProto| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "shortCircuitAccessVersion",
                |m: &BlockOpResponseProto| { &m.shortCircuitAccessVersion },
                |m: &mut BlockOpResponseProto| { &mut m.shortCircuitAccessVersion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockOpResponseProto>(
                "BlockOpResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockOpResponseProto {
        static instance: ::protobuf::rt::LazyV2<BlockOpResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockOpResponseProto::new)
    }
}

impl ::protobuf::Clear for BlockOpResponseProto {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.firstBadLink.clear();
        self.checksumResponse.clear();
        self.readOpChecksumInfo.clear();
        self.message.clear();
        self.shortCircuitAccessVersion = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockOpResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockOpResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientReadStatusProto {
    // message fields
    status: ::std::option::Option<Status>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientReadStatusProto {
    fn default() -> &'a ClientReadStatusProto {
        <ClientReadStatusProto as ::protobuf::Message>::default_instance()
    }
}

impl ClientReadStatusProto {
    pub fn new() -> ClientReadStatusProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.Status status = 1;


    pub fn get_status(&self) -> Status {
        self.status.unwrap_or(Status::SUCCESS)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ClientReadStatusProto {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientReadStatusProto {
        ClientReadStatusProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                "status",
                |m: &ClientReadStatusProto| { &m.status },
                |m: &mut ClientReadStatusProto| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientReadStatusProto>(
                "ClientReadStatusProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientReadStatusProto {
        static instance: ::protobuf::rt::LazyV2<ClientReadStatusProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientReadStatusProto::new)
    }
}

impl ::protobuf::Clear for ClientReadStatusProto {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientReadStatusProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientReadStatusProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DNTransferAckProto {
    // message fields
    status: ::std::option::Option<Status>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DNTransferAckProto {
    fn default() -> &'a DNTransferAckProto {
        <DNTransferAckProto as ::protobuf::Message>::default_instance()
    }
}

impl DNTransferAckProto {
    pub fn new() -> DNTransferAckProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.Status status = 1;


    pub fn get_status(&self) -> Status {
        self.status.unwrap_or(Status::SUCCESS)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DNTransferAckProto {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DNTransferAckProto {
        DNTransferAckProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                "status",
                |m: &DNTransferAckProto| { &m.status },
                |m: &mut DNTransferAckProto| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DNTransferAckProto>(
                "DNTransferAckProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DNTransferAckProto {
        static instance: ::protobuf::rt::LazyV2<DNTransferAckProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DNTransferAckProto::new)
    }
}

impl ::protobuf::Clear for DNTransferAckProto {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DNTransferAckProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DNTransferAckProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpBlockChecksumResponseProto {
    // message fields
    bytesPerCrc: ::std::option::Option<u32>,
    crcPerBlock: ::std::option::Option<u64>,
    blockChecksum: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    crcType: ::std::option::Option<super::hdfs::ChecksumTypeProto>,
    pub blockChecksumOptions: ::protobuf::SingularPtrField<super::hdfs::BlockChecksumOptionsProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpBlockChecksumResponseProto {
    fn default() -> &'a OpBlockChecksumResponseProto {
        <OpBlockChecksumResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl OpBlockChecksumResponseProto {
    pub fn new() -> OpBlockChecksumResponseProto {
        ::std::default::Default::default()
    }

    // required uint32 bytesPerCrc = 1;


    pub fn get_bytesPerCrc(&self) -> u32 {
        self.bytesPerCrc.unwrap_or(0)
    }
    pub fn clear_bytesPerCrc(&mut self) {
        self.bytesPerCrc = ::std::option::Option::None;
    }

    pub fn has_bytesPerCrc(&self) -> bool {
        self.bytesPerCrc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesPerCrc(&mut self, v: u32) {
        self.bytesPerCrc = ::std::option::Option::Some(v);
    }

    // required uint64 crcPerBlock = 2;


    pub fn get_crcPerBlock(&self) -> u64 {
        self.crcPerBlock.unwrap_or(0)
    }
    pub fn clear_crcPerBlock(&mut self) {
        self.crcPerBlock = ::std::option::Option::None;
    }

    pub fn has_crcPerBlock(&self) -> bool {
        self.crcPerBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crcPerBlock(&mut self, v: u64) {
        self.crcPerBlock = ::std::option::Option::Some(v);
    }

    // required bytes blockChecksum = 3;


    pub fn get_blockChecksum(&self) -> &[u8] {
        match self.blockChecksum.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_blockChecksum(&mut self) {
        self.blockChecksum.clear();
    }

    pub fn has_blockChecksum(&self) -> bool {
        self.blockChecksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockChecksum(&mut self, v: ::std::vec::Vec<u8>) {
        self.blockChecksum = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockChecksum(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.blockChecksum.is_none() {
            self.blockChecksum.set_default();
        }
        self.blockChecksum.as_mut().unwrap()
    }

    // Take field
    pub fn take_blockChecksum(&mut self) -> ::std::vec::Vec<u8> {
        self.blockChecksum.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .hadoop.hdfs.ChecksumTypeProto crcType = 4;


    pub fn get_crcType(&self) -> super::hdfs::ChecksumTypeProto {
        self.crcType.unwrap_or(super::hdfs::ChecksumTypeProto::CHECKSUM_NULL)
    }
    pub fn clear_crcType(&mut self) {
        self.crcType = ::std::option::Option::None;
    }

    pub fn has_crcType(&self) -> bool {
        self.crcType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crcType(&mut self, v: super::hdfs::ChecksumTypeProto) {
        self.crcType = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.BlockChecksumOptionsProto blockChecksumOptions = 5;


    pub fn get_blockChecksumOptions(&self) -> &super::hdfs::BlockChecksumOptionsProto {
        self.blockChecksumOptions.as_ref().unwrap_or_else(|| <super::hdfs::BlockChecksumOptionsProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blockChecksumOptions(&mut self) {
        self.blockChecksumOptions.clear();
    }

    pub fn has_blockChecksumOptions(&self) -> bool {
        self.blockChecksumOptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockChecksumOptions(&mut self, v: super::hdfs::BlockChecksumOptionsProto) {
        self.blockChecksumOptions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockChecksumOptions(&mut self) -> &mut super::hdfs::BlockChecksumOptionsProto {
        if self.blockChecksumOptions.is_none() {
            self.blockChecksumOptions.set_default();
        }
        self.blockChecksumOptions.as_mut().unwrap()
    }

    // Take field
    pub fn take_blockChecksumOptions(&mut self) -> super::hdfs::BlockChecksumOptionsProto {
        self.blockChecksumOptions.take().unwrap_or_else(|| super::hdfs::BlockChecksumOptionsProto::new())
    }
}

impl ::protobuf::Message for OpBlockChecksumResponseProto {
    fn is_initialized(&self) -> bool {
        if self.bytesPerCrc.is_none() {
            return false;
        }
        if self.crcPerBlock.is_none() {
            return false;
        }
        if self.blockChecksum.is_none() {
            return false;
        }
        for v in &self.blockChecksumOptions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bytesPerCrc = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.crcPerBlock = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.blockChecksum)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.crcType, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blockChecksumOptions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bytesPerCrc {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.crcPerBlock {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.blockChecksum.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.crcType {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.blockChecksumOptions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bytesPerCrc {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.crcPerBlock {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.blockChecksum.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.crcType {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.blockChecksumOptions.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpBlockChecksumResponseProto {
        OpBlockChecksumResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "bytesPerCrc",
                |m: &OpBlockChecksumResponseProto| { &m.bytesPerCrc },
                |m: &mut OpBlockChecksumResponseProto| { &mut m.bytesPerCrc },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "crcPerBlock",
                |m: &OpBlockChecksumResponseProto| { &m.crcPerBlock },
                |m: &mut OpBlockChecksumResponseProto| { &mut m.crcPerBlock },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "blockChecksum",
                |m: &OpBlockChecksumResponseProto| { &m.blockChecksum },
                |m: &mut OpBlockChecksumResponseProto| { &mut m.blockChecksum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::ChecksumTypeProto>>(
                "crcType",
                |m: &OpBlockChecksumResponseProto| { &m.crcType },
                |m: &mut OpBlockChecksumResponseProto| { &mut m.crcType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::BlockChecksumOptionsProto>>(
                "blockChecksumOptions",
                |m: &OpBlockChecksumResponseProto| { &m.blockChecksumOptions },
                |m: &mut OpBlockChecksumResponseProto| { &mut m.blockChecksumOptions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpBlockChecksumResponseProto>(
                "OpBlockChecksumResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpBlockChecksumResponseProto {
        static instance: ::protobuf::rt::LazyV2<OpBlockChecksumResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpBlockChecksumResponseProto::new)
    }
}

impl ::protobuf::Clear for OpBlockChecksumResponseProto {
    fn clear(&mut self) {
        self.bytesPerCrc = ::std::option::Option::None;
        self.crcPerBlock = ::std::option::Option::None;
        self.blockChecksum.clear();
        self.crcType = ::std::option::Option::None;
        self.blockChecksumOptions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpBlockChecksumResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpBlockChecksumResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpCustomProto {
    // message fields
    customId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpCustomProto {
    fn default() -> &'a OpCustomProto {
        <OpCustomProto as ::protobuf::Message>::default_instance()
    }
}

impl OpCustomProto {
    pub fn new() -> OpCustomProto {
        ::std::default::Default::default()
    }

    // required string customId = 1;


    pub fn get_customId(&self) -> &str {
        match self.customId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_customId(&mut self) {
        self.customId.clear();
    }

    pub fn has_customId(&self) -> bool {
        self.customId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_customId(&mut self, v: ::std::string::String) {
        self.customId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_customId(&mut self) -> &mut ::std::string::String {
        if self.customId.is_none() {
            self.customId.set_default();
        }
        self.customId.as_mut().unwrap()
    }

    // Take field
    pub fn take_customId(&mut self) -> ::std::string::String {
        self.customId.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for OpCustomProto {
    fn is_initialized(&self) -> bool {
        if self.customId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.customId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.customId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.customId.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpCustomProto {
        OpCustomProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "customId",
                |m: &OpCustomProto| { &m.customId },
                |m: &mut OpCustomProto| { &mut m.customId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpCustomProto>(
                "OpCustomProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpCustomProto {
        static instance: ::protobuf::rt::LazyV2<OpCustomProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpCustomProto::new)
    }
}

impl ::protobuf::Clear for OpCustomProto {
    fn clear(&mut self) {
        self.customId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpCustomProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpCustomProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Status {
    SUCCESS = 0,
    ERROR = 1,
    ERROR_CHECKSUM = 2,
    ERROR_INVALID = 3,
    ERROR_EXISTS = 4,
    ERROR_ACCESS_TOKEN = 5,
    CHECKSUM_OK = 6,
    ERROR_UNSUPPORTED = 7,
    OOB_RESTART = 8,
    OOB_RESERVED1 = 9,
    OOB_RESERVED2 = 10,
    OOB_RESERVED3 = 11,
    IN_PROGRESS = 12,
    ERROR_BLOCK_PINNED = 13,
}

impl ::protobuf::ProtobufEnum for Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Status> {
        match value {
            0 => ::std::option::Option::Some(Status::SUCCESS),
            1 => ::std::option::Option::Some(Status::ERROR),
            2 => ::std::option::Option::Some(Status::ERROR_CHECKSUM),
            3 => ::std::option::Option::Some(Status::ERROR_INVALID),
            4 => ::std::option::Option::Some(Status::ERROR_EXISTS),
            5 => ::std::option::Option::Some(Status::ERROR_ACCESS_TOKEN),
            6 => ::std::option::Option::Some(Status::CHECKSUM_OK),
            7 => ::std::option::Option::Some(Status::ERROR_UNSUPPORTED),
            8 => ::std::option::Option::Some(Status::OOB_RESTART),
            9 => ::std::option::Option::Some(Status::OOB_RESERVED1),
            10 => ::std::option::Option::Some(Status::OOB_RESERVED2),
            11 => ::std::option::Option::Some(Status::OOB_RESERVED3),
            12 => ::std::option::Option::Some(Status::IN_PROGRESS),
            13 => ::std::option::Option::Some(Status::ERROR_BLOCK_PINNED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Status] = &[
            Status::SUCCESS,
            Status::ERROR,
            Status::ERROR_CHECKSUM,
            Status::ERROR_INVALID,
            Status::ERROR_EXISTS,
            Status::ERROR_ACCESS_TOKEN,
            Status::CHECKSUM_OK,
            Status::ERROR_UNSUPPORTED,
            Status::OOB_RESTART,
            Status::OOB_RESERVED1,
            Status::OOB_RESERVED2,
            Status::OOB_RESERVED3,
            Status::IN_PROGRESS,
            Status::ERROR_BLOCK_PINNED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Status>("Status", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Status {
}

impl ::std::default::Default for Status {
    fn default() -> Self {
        Status::SUCCESS
    }
}

impl ::protobuf::reflect::ProtobufValue for Status {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ShortCircuitFdResponse {
    DO_NOT_USE_RECEIPT_VERIFICATION = 0,
    USE_RECEIPT_VERIFICATION = 1,
}

impl ::protobuf::ProtobufEnum for ShortCircuitFdResponse {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ShortCircuitFdResponse> {
        match value {
            0 => ::std::option::Option::Some(ShortCircuitFdResponse::DO_NOT_USE_RECEIPT_VERIFICATION),
            1 => ::std::option::Option::Some(ShortCircuitFdResponse::USE_RECEIPT_VERIFICATION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ShortCircuitFdResponse] = &[
            ShortCircuitFdResponse::DO_NOT_USE_RECEIPT_VERIFICATION,
            ShortCircuitFdResponse::USE_RECEIPT_VERIFICATION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ShortCircuitFdResponse>("ShortCircuitFdResponse", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ShortCircuitFdResponse {
}

impl ::std::default::Default for ShortCircuitFdResponse {
    fn default() -> Self {
        ShortCircuitFdResponse::DO_NOT_USE_RECEIPT_VERIFICATION
    }
}

impl ::protobuf::reflect::ProtobufValue for ShortCircuitFdResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12datatransfer.proto\x12\x0bhadoop.hdfs\x1a\x0eSecurity.proto\x1a\nh\
    dfs.proto\"\x9a\x03\n!DataTransferEncryptorMessageProto\x12b\n\x06status\
    \x18\x01\x20\x02(\x0e2J.hadoop.hdfs.DataTransferEncryptorMessageProto.Da\
    taTransferEncryptorStatusR\x06status\x12\x18\n\x07payload\x18\x02\x20\
    \x01(\x0cR\x07payload\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07messag\
    e\x12B\n\x0ccipherOption\x18\x04\x20\x03(\x0b2\x1e.hadoop.hdfs.CipherOpt\
    ionProtoR\x0ccipherOption\x12K\n\x0fhandshakeSecret\x18\x05\x20\x01(\x0b\
    2!.hadoop.hdfs.HandshakeSecretProtoR\x0fhandshakeSecret\"L\n\x1bDataTran\
    sferEncryptorStatus\x12\x0b\n\x07SUCCESS\x10\0\x12\x15\n\x11ERROR_UNKNOW\
    N_KEY\x10\x01\x12\t\n\x05ERROR\x10\x02\"B\n\x14HandshakeSecretProto\x12\
    \x16\n\x06secret\x18\x01\x20\x02(\x0cR\x06secret\x12\x12\n\x04bpid\x18\
    \x02\x20\x02(\tR\x04bpid\"\xc0\x01\n\x0fBaseHeaderProto\x125\n\x05block\
    \x18\x01\x20\x02(\x0b2\x1f.hadoop.hdfs.ExtendedBlockProtoR\x05block\x12/\
    \n\x05token\x18\x02\x20\x01(\x0b2\x19.hadoop.common.TokenProtoR\x05token\
    \x12E\n\ttraceInfo\x18\x03\x20\x01(\x0b2'.hadoop.hdfs.DataTransferTraceI\
    nfoProtoR\ttraceInfo\"R\n\x1aDataTransferTraceInfoProto\x12\x18\n\x07tra\
    ceId\x18\x01\x20\x02(\x04R\x07traceId\x12\x1a\n\x08parentId\x18\x02\x20\
    \x02(\x04R\x08parentId\"z\n\x1aClientOperationHeaderProto\x12<\n\nbaseHe\
    ader\x18\x01\x20\x02(\x0b2\x1c.hadoop.hdfs.BaseHeaderProtoR\nbaseHeader\
    \x12\x1e\n\nclientName\x18\x02\x20\x02(\tR\nclientName\"T\n\x14CachingSt\
    rategyProto\x12\x1e\n\ndropBehind\x18\x01\x20\x01(\x08R\ndropBehind\x12\
    \x1c\n\treadahead\x18\x02\x20\x01(\x03R\treadahead\"\xf6\x01\n\x10OpRead\
    BlockProto\x12?\n\x06header\x18\x01\x20\x02(\x0b2'.hadoop.hdfs.ClientOpe\
    rationHeaderProtoR\x06header\x12\x16\n\x06offset\x18\x02\x20\x02(\x04R\
    \x06offset\x12\x10\n\x03len\x18\x03\x20\x02(\x04R\x03len\x12*\n\rsendChe\
    cksums\x18\x04\x20\x01(\x08:\x04trueR\rsendChecksums\x12K\n\x0fcachingSt\
    rategy\x18\x05\x20\x01(\x0b2!.hadoop.hdfs.CachingStrategyProtoR\x0fcachi\
    ngStrategy\"o\n\rChecksumProto\x122\n\x04type\x18\x01\x20\x02(\x0e2\x1e.\
    hadoop.hdfs.ChecksumTypeProtoR\x04type\x12*\n\x10bytesPerChecksum\x18\
    \x02\x20\x02(\rR\x10bytesPerChecksum\"\xb3\t\n\x11OpWriteBlockProto\x12?\
    \n\x06header\x18\x01\x20\x02(\x0b2'.hadoop.hdfs.ClientOperationHeaderPro\
    toR\x06header\x128\n\x07targets\x18\x02\x20\x03(\x0b2\x1e.hadoop.hdfs.Da\
    tanodeInfoProtoR\x07targets\x126\n\x06source\x18\x03\x20\x01(\x0b2\x1e.h\
    adoop.hdfs.DatanodeInfoProtoR\x06source\x12K\n\x05stage\x18\x04\x20\x02(\
    \x0e25.hadoop.hdfs.OpWriteBlockProto.BlockConstructionStageR\x05stage\
    \x12\"\n\x0cpipelineSize\x18\x05\x20\x02(\rR\x0cpipelineSize\x12\"\n\x0c\
    minBytesRcvd\x18\x06\x20\x02(\x04R\x0cminBytesRcvd\x12\"\n\x0cmaxBytesRc\
    vd\x18\x07\x20\x02(\x04R\x0cmaxBytesRcvd\x124\n\x15latestGenerationStamp\
    \x18\x08\x20\x02(\x04R\x15latestGenerationStamp\x12H\n\x11requestedCheck\
    sum\x18\t\x20\x02(\x0b2\x1a.hadoop.hdfs.ChecksumProtoR\x11requestedCheck\
    sum\x12K\n\x0fcachingStrategy\x18\n\x20\x01(\x0b2!.hadoop.hdfs.CachingSt\
    rategyProtoR\x0fcachingStrategy\x12E\n\x0bstorageType\x18\x0b\x20\x01(\
    \x0e2\x1d.hadoop.hdfs.StorageTypeProto:\x04DISKR\x0bstorageType\x12M\n\
    \x12targetStorageTypes\x18\x0c\x20\x03(\x0e2\x1d.hadoop.hdfs.StorageType\
    ProtoR\x12targetStorageTypes\x121\n\x10allowLazyPersist\x18\r\x20\x01(\
    \x08:\x05falseR\x10allowLazyPersist\x12\x1f\n\x07pinning\x18\x0e\x20\x01\
    (\x08:\x05falseR\x07pinning\x12&\n\x0etargetPinnings\x18\x0f\x20\x03(\
    \x08R\x0etargetPinnings\x12\x1c\n\tstorageId\x18\x10\x20\x01(\tR\tstorag\
    eId\x12*\n\x10targetStorageIds\x18\x11\x20\x03(\tR\x10targetStorageIds\"\
    \x88\x02\n\x16BlockConstructionStage\x12\x19\n\x15PIPELINE_SETUP_APPEND\
    \x10\0\x12\"\n\x1ePIPELINE_SETUP_APPEND_RECOVERY\x10\x01\x12\x12\n\x0eDA\
    TA_STREAMING\x10\x02\x12%\n!PIPELINE_SETUP_STREAMING_RECOVERY\x10\x03\
    \x12\x12\n\x0ePIPELINE_CLOSE\x10\x04\x12\x1b\n\x17PIPELINE_CLOSE_RECOVER\
    Y\x10\x05\x12\x19\n\x15PIPELINE_SETUP_CREATE\x10\x06\x12\x10\n\x0cTRANSF\
    ER_RBW\x10\x07\x12\x16\n\x12TRANSFER_FINALIZED\x10\x08\"\x8c\x02\n\x14Op\
    TransferBlockProto\x12?\n\x06header\x18\x01\x20\x02(\x0b2'.hadoop.hdfs.C\
    lientOperationHeaderProtoR\x06header\x128\n\x07targets\x18\x02\x20\x03(\
    \x0b2\x1e.hadoop.hdfs.DatanodeInfoProtoR\x07targets\x12M\n\x12targetStor\
    ageTypes\x18\x03\x20\x03(\x0e2\x1d.hadoop.hdfs.StorageTypeProtoR\x12targ\
    etStorageTypes\x12*\n\x10targetStorageIds\x18\x04\x20\x03(\tR\x10targetS\
    torageIds\"\x82\x02\n\x13OpReplaceBlockProto\x124\n\x06header\x18\x01\
    \x20\x02(\x0b2\x1c.hadoop.hdfs.BaseHeaderProtoR\x06header\x12\x18\n\x07d\
    elHint\x18\x02\x20\x02(\tR\x07delHint\x126\n\x06source\x18\x03\x20\x02(\
    \x0b2\x1e.hadoop.hdfs.DatanodeInfoProtoR\x06source\x12E\n\x0bstorageType\
    \x18\x04\x20\x01(\x0e2\x1d.hadoop.hdfs.StorageTypeProto:\x04DISKR\x0bsto\
    rageType\x12\x1c\n\tstorageId\x18\x05\x20\x01(\tR\tstorageId\"H\n\x10OpC\
    opyBlockProto\x124\n\x06header\x18\x01\x20\x02(\x0b2\x1c.hadoop.hdfs.Bas\
    eHeaderProtoR\x06header\"\xa8\x01\n\x14OpBlockChecksumProto\x124\n\x06he\
    ader\x18\x01\x20\x02(\x0b2\x1c.hadoop.hdfs.BaseHeaderProtoR\x06header\
    \x12Z\n\x14blockChecksumOptions\x18\x02\x20\x01(\x0b2&.hadoop.hdfs.Block\
    ChecksumOptionsProtoR\x14blockChecksumOptions\"\xbe\x03\n\x19OpBlockGrou\
    pChecksumProto\x124\n\x06header\x18\x01\x20\x02(\x0b2\x1c.hadoop.hdfs.Ba\
    seHeaderProtoR\x06header\x12=\n\tdatanodes\x18\x02\x20\x02(\x0b2\x1f.had\
    oop.hdfs.DatanodeInfosProtoR\tdatanodes\x12;\n\x0bblockTokens\x18\x03\
    \x20\x03(\x0b2\x19.hadoop.common.TokenProtoR\x0bblockTokens\x12A\n\x08ec\
    Policy\x18\x04\x20\x02(\x0b2%.hadoop.hdfs.ErasureCodingPolicyProtoR\x08e\
    cPolicy\x12\"\n\x0cblockIndices\x18\x05\x20\x03(\rR\x0cblockIndices\x12,\
    \n\x11requestedNumBytes\x18\x06\x20\x02(\x04R\x11requestedNumBytes\x12Z\
    \n\x14blockChecksumOptions\x18\x07\x20\x01(\x0b2&.hadoop.hdfs.BlockCheck\
    sumOptionsProtoR\x14blockChecksumOptions\"8\n\x16ShortCircuitShmIdProto\
    \x12\x0e\n\x02hi\x18\x01\x20\x02(\x03R\x02hi\x12\x0e\n\x02lo\x18\x02\x20\
    \x02(\x03R\x02lo\"o\n\x18ShortCircuitShmSlotProto\x129\n\x05shmId\x18\
    \x01\x20\x02(\x0b2#.hadoop.hdfs.ShortCircuitShmIdProtoR\x05shmId\x12\x18\
    \n\x07slotIdx\x18\x02\x20\x02(\x05R\x07slotIdx\"\x80\x02\n\x20OpRequestS\
    hortCircuitAccessProto\x124\n\x06header\x18\x01\x20\x02(\x0b2\x1c.hadoop\
    .hdfs.BaseHeaderProtoR\x06header\x12\x1e\n\nmaxVersion\x18\x02\x20\x02(\
    \rR\nmaxVersion\x12=\n\x06slotId\x18\x03\x20\x01(\x0b2%.hadoop.hdfs.Shor\
    tCircuitShmSlotProtoR\x06slotId\x12G\n\x1bsupportsReceiptVerification\
    \x18\x04\x20\x01(\x08:\x05falseR\x1bsupportsReceiptVerification\"\xad\
    \x01\n%ReleaseShortCircuitAccessRequestProto\x12=\n\x06slotId\x18\x01\
    \x20\x02(\x0b2%.hadoop.hdfs.ShortCircuitShmSlotProtoR\x06slotId\x12E\n\t\
    traceInfo\x18\x02\x20\x01(\x0b2'.hadoop.hdfs.DataTransferTraceInfoProtoR\
    \ttraceInfo\"k\n&ReleaseShortCircuitAccessResponseProto\x12+\n\x06status\
    \x18\x01\x20\x02(\x0e2\x13.hadoop.hdfs.StatusR\x06status\x12\x14\n\x05er\
    ror\x18\x02\x20\x01(\tR\x05error\"\x84\x01\n\x1bShortCircuitShmRequestPr\
    oto\x12\x1e\n\nclientName\x18\x01\x20\x02(\tR\nclientName\x12E\n\ttraceI\
    nfo\x18\x02\x20\x01(\x0b2'.hadoop.hdfs.DataTransferTraceInfoProtoR\ttrac\
    eInfo\"\x96\x01\n\x1cShortCircuitShmResponseProto\x12+\n\x06status\x18\
    \x01\x20\x02(\x0e2\x13.hadoop.hdfs.StatusR\x06status\x12\x14\n\x05error\
    \x18\x02\x20\x01(\tR\x05error\x123\n\x02id\x18\x03\x20\x01(\x0b2#.hadoop\
    .hdfs.ShortCircuitShmIdProtoR\x02id\"\xbc\x01\n\x11PacketHeaderProto\x12\
    $\n\roffsetInBlock\x18\x01\x20\x02(\x10R\roffsetInBlock\x12\x14\n\x05seq\
    no\x18\x02\x20\x02(\x10R\x05seqno\x12,\n\x11lastPacketInBlock\x18\x03\
    \x20\x02(\x08R\x11lastPacketInBlock\x12\x18\n\x07dataLen\x18\x04\x20\x02\
    (\x0fR\x07dataLen\x12#\n\tsyncBlock\x18\x05\x20\x01(\x08:\x05falseR\tsyn\
    cBlock\"\xa6\x01\n\x10PipelineAckProto\x12\x14\n\x05seqno\x18\x01\x20\
    \x02(\x12R\x05seqno\x12)\n\x05reply\x18\x02\x20\x03(\x0e2\x13.hadoop.hdf\
    s.StatusR\x05reply\x129\n\x16downstreamAckTimeNanos\x18\x03\x20\x01(\x04\
    :\x010R\x16downstreamAckTimeNanos\x12\x16\n\x04flag\x18\x04\x20\x03(\rR\
    \x04flagB\x02\x10\x01\"s\n\x17ReadOpChecksumInfoProto\x126\n\x08checksum\
    \x18\x01\x20\x02(\x0b2\x1a.hadoop.hdfs.ChecksumProtoR\x08checksum\x12\
    \x20\n\x0bchunkOffset\x18\x02\x20\x02(\x04R\x0bchunkOffset\"\xec\x02\n\
    \x14BlockOpResponseProto\x12+\n\x06status\x18\x01\x20\x02(\x0e2\x13.hado\
    op.hdfs.StatusR\x06status\x12\"\n\x0cfirstBadLink\x18\x02\x20\x01(\tR\
    \x0cfirstBadLink\x12U\n\x10checksumResponse\x18\x03\x20\x01(\x0b2).hadoo\
    p.hdfs.OpBlockChecksumResponseProtoR\x10checksumResponse\x12T\n\x12readO\
    pChecksumInfo\x18\x04\x20\x01(\x0b2$.hadoop.hdfs.ReadOpChecksumInfoProto\
    R\x12readOpChecksumInfo\x12\x18\n\x07message\x18\x05\x20\x01(\tR\x07mess\
    age\x12<\n\x19shortCircuitAccessVersion\x18\x06\x20\x01(\rR\x19shortCirc\
    uitAccessVersion\"D\n\x15ClientReadStatusProto\x12+\n\x06status\x18\x01\
    \x20\x02(\x0e2\x13.hadoop.hdfs.StatusR\x06status\"A\n\x12DNTransferAckPr\
    oto\x12+\n\x06status\x18\x01\x20\x02(\x0e2\x13.hadoop.hdfs.StatusR\x06st\
    atus\"\x9e\x02\n\x1cOpBlockChecksumResponseProto\x12\x20\n\x0bbytesPerCr\
    c\x18\x01\x20\x02(\rR\x0bbytesPerCrc\x12\x20\n\x0bcrcPerBlock\x18\x02\
    \x20\x02(\x04R\x0bcrcPerBlock\x12$\n\rblockChecksum\x18\x03\x20\x02(\x0c\
    R\rblockChecksum\x128\n\x07crcType\x18\x04\x20\x01(\x0e2\x1e.hadoop.hdfs\
    .ChecksumTypeProtoR\x07crcType\x12Z\n\x14blockChecksumOptions\x18\x05\
    \x20\x01(\x0b2&.hadoop.hdfs.BlockChecksumOptionsProtoR\x14blockChecksumO\
    ptions\"+\n\rOpCustomProto\x12\x1a\n\x08customId\x18\x01\x20\x02(\tR\x08\
    customId*\x8c\x02\n\x06Status\x12\x0b\n\x07SUCCESS\x10\0\x12\t\n\x05ERRO\
    R\x10\x01\x12\x12\n\x0eERROR_CHECKSUM\x10\x02\x12\x11\n\rERROR_INVALID\
    \x10\x03\x12\x10\n\x0cERROR_EXISTS\x10\x04\x12\x16\n\x12ERROR_ACCESS_TOK\
    EN\x10\x05\x12\x0f\n\x0bCHECKSUM_OK\x10\x06\x12\x15\n\x11ERROR_UNSUPPORT\
    ED\x10\x07\x12\x0f\n\x0bOOB_RESTART\x10\x08\x12\x11\n\rOOB_RESERVED1\x10\
    \t\x12\x11\n\rOOB_RESERVED2\x10\n\x12\x11\n\rOOB_RESERVED3\x10\x0b\x12\
    \x0f\n\x0bIN_PROGRESS\x10\x0c\x12\x16\n\x12ERROR_BLOCK_PINNED\x10\r*[\n\
    \x16ShortCircuitFdResponse\x12#\n\x1fDO_NOT_USE_RECEIPT_VERIFICATION\x10\
    \0\x12\x1c\n\x18USE_RECEIPT_VERIFICATION\x10\x01B>\n%org.apache.hadoop.h\
    dfs.protocol.protoB\x12DataTransferProtos\xa0\x01\x01\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
