// This file is generated by rust-protobuf 2.23.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `hdfs.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_23_0;

#[derive(PartialEq,Clone,Default)]
pub struct ExtendedBlockProto {
    // message fields
    poolId: ::protobuf::SingularField<::std::string::String>,
    blockId: ::std::option::Option<u64>,
    generationStamp: ::std::option::Option<u64>,
    numBytes: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExtendedBlockProto {
    fn default() -> &'a ExtendedBlockProto {
        <ExtendedBlockProto as ::protobuf::Message>::default_instance()
    }
}

impl ExtendedBlockProto {
    pub fn new() -> ExtendedBlockProto {
        ::std::default::Default::default()
    }

    // required string poolId = 1;


    pub fn get_poolId(&self) -> &str {
        match self.poolId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_poolId(&mut self) {
        self.poolId.clear();
    }

    pub fn has_poolId(&self) -> bool {
        self.poolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poolId(&mut self, v: ::std::string::String) {
        self.poolId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poolId(&mut self) -> &mut ::std::string::String {
        if self.poolId.is_none() {
            self.poolId.set_default();
        }
        self.poolId.as_mut().unwrap()
    }

    // Take field
    pub fn take_poolId(&mut self) -> ::std::string::String {
        self.poolId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 blockId = 2;


    pub fn get_blockId(&self) -> u64 {
        self.blockId.unwrap_or(0)
    }
    pub fn clear_blockId(&mut self) {
        self.blockId = ::std::option::Option::None;
    }

    pub fn has_blockId(&self) -> bool {
        self.blockId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockId(&mut self, v: u64) {
        self.blockId = ::std::option::Option::Some(v);
    }

    // required uint64 generationStamp = 3;


    pub fn get_generationStamp(&self) -> u64 {
        self.generationStamp.unwrap_or(0)
    }
    pub fn clear_generationStamp(&mut self) {
        self.generationStamp = ::std::option::Option::None;
    }

    pub fn has_generationStamp(&self) -> bool {
        self.generationStamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generationStamp(&mut self, v: u64) {
        self.generationStamp = ::std::option::Option::Some(v);
    }

    // optional uint64 numBytes = 4;


    pub fn get_numBytes(&self) -> u64 {
        self.numBytes.unwrap_or(0u64)
    }
    pub fn clear_numBytes(&mut self) {
        self.numBytes = ::std::option::Option::None;
    }

    pub fn has_numBytes(&self) -> bool {
        self.numBytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numBytes(&mut self, v: u64) {
        self.numBytes = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ExtendedBlockProto {
    fn is_initialized(&self) -> bool {
        if self.poolId.is_none() {
            return false;
        }
        if self.blockId.is_none() {
            return false;
        }
        if self.generationStamp.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.poolId)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.generationStamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.numBytes = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.poolId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.blockId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.generationStamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numBytes {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.poolId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.blockId {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.generationStamp {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.numBytes {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExtendedBlockProto {
        ExtendedBlockProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "poolId",
                |m: &ExtendedBlockProto| { &m.poolId },
                |m: &mut ExtendedBlockProto| { &mut m.poolId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "blockId",
                |m: &ExtendedBlockProto| { &m.blockId },
                |m: &mut ExtendedBlockProto| { &mut m.blockId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "generationStamp",
                |m: &ExtendedBlockProto| { &m.generationStamp },
                |m: &mut ExtendedBlockProto| { &mut m.generationStamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "numBytes",
                |m: &ExtendedBlockProto| { &m.numBytes },
                |m: &mut ExtendedBlockProto| { &mut m.numBytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExtendedBlockProto>(
                "ExtendedBlockProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExtendedBlockProto {
        static instance: ::protobuf::rt::LazyV2<ExtendedBlockProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExtendedBlockProto::new)
    }
}

impl ::protobuf::Clear for ExtendedBlockProto {
    fn clear(&mut self) {
        self.poolId.clear();
        self.blockId = ::std::option::Option::None;
        self.generationStamp = ::std::option::Option::None;
        self.numBytes = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExtendedBlockProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtendedBlockProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProvidedStorageLocationProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    offset: ::std::option::Option<i64>,
    length: ::std::option::Option<i64>,
    nonce: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProvidedStorageLocationProto {
    fn default() -> &'a ProvidedStorageLocationProto {
        <ProvidedStorageLocationProto as ::protobuf::Message>::default_instance()
    }
}

impl ProvidedStorageLocationProto {
    pub fn new() -> ProvidedStorageLocationProto {
        ::std::default::Default::default()
    }

    // required string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int64 offset = 2;


    pub fn get_offset(&self) -> i64 {
        self.offset.unwrap_or(0)
    }
    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.offset = ::std::option::Option::Some(v);
    }

    // required int64 length = 3;


    pub fn get_length(&self) -> i64 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: i64) {
        self.length = ::std::option::Option::Some(v);
    }

    // required bytes nonce = 4;


    pub fn get_nonce(&self) -> &[u8] {
        match self.nonce.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_nonce(&mut self) {
        self.nonce.clear();
    }

    pub fn has_nonce(&self) -> bool {
        self.nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.nonce = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.nonce.is_none() {
            self.nonce.set_default();
        }
        self.nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::vec::Vec<u8> {
        self.nonce.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ProvidedStorageLocationProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        if self.length.is_none() {
            return false;
        }
        if self.nonce.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.nonce)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.nonce.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.offset {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.length {
            os.write_int64(3, v)?;
        }
        if let Some(ref v) = self.nonce.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProvidedStorageLocationProto {
        ProvidedStorageLocationProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &ProvidedStorageLocationProto| { &m.path },
                |m: &mut ProvidedStorageLocationProto| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "offset",
                |m: &ProvidedStorageLocationProto| { &m.offset },
                |m: &mut ProvidedStorageLocationProto| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "length",
                |m: &ProvidedStorageLocationProto| { &m.length },
                |m: &mut ProvidedStorageLocationProto| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nonce",
                |m: &ProvidedStorageLocationProto| { &m.nonce },
                |m: &mut ProvidedStorageLocationProto| { &mut m.nonce },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProvidedStorageLocationProto>(
                "ProvidedStorageLocationProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProvidedStorageLocationProto {
        static instance: ::protobuf::rt::LazyV2<ProvidedStorageLocationProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProvidedStorageLocationProto::new)
    }
}

impl ::protobuf::Clear for ProvidedStorageLocationProto {
    fn clear(&mut self) {
        self.path.clear();
        self.offset = ::std::option::Option::None;
        self.length = ::std::option::Option::None;
        self.nonce.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProvidedStorageLocationProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProvidedStorageLocationProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatanodeIDProto {
    // message fields
    ipAddr: ::protobuf::SingularField<::std::string::String>,
    hostName: ::protobuf::SingularField<::std::string::String>,
    datanodeUuid: ::protobuf::SingularField<::std::string::String>,
    xferPort: ::std::option::Option<u32>,
    infoPort: ::std::option::Option<u32>,
    ipcPort: ::std::option::Option<u32>,
    infoSecurePort: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatanodeIDProto {
    fn default() -> &'a DatanodeIDProto {
        <DatanodeIDProto as ::protobuf::Message>::default_instance()
    }
}

impl DatanodeIDProto {
    pub fn new() -> DatanodeIDProto {
        ::std::default::Default::default()
    }

    // required string ipAddr = 1;


    pub fn get_ipAddr(&self) -> &str {
        match self.ipAddr.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ipAddr(&mut self) {
        self.ipAddr.clear();
    }

    pub fn has_ipAddr(&self) -> bool {
        self.ipAddr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipAddr(&mut self, v: ::std::string::String) {
        self.ipAddr = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipAddr(&mut self) -> &mut ::std::string::String {
        if self.ipAddr.is_none() {
            self.ipAddr.set_default();
        }
        self.ipAddr.as_mut().unwrap()
    }

    // Take field
    pub fn take_ipAddr(&mut self) -> ::std::string::String {
        self.ipAddr.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string hostName = 2;


    pub fn get_hostName(&self) -> &str {
        match self.hostName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_hostName(&mut self) {
        self.hostName.clear();
    }

    pub fn has_hostName(&self) -> bool {
        self.hostName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostName(&mut self, v: ::std::string::String) {
        self.hostName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostName(&mut self) -> &mut ::std::string::String {
        if self.hostName.is_none() {
            self.hostName.set_default();
        }
        self.hostName.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostName(&mut self) -> ::std::string::String {
        self.hostName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string datanodeUuid = 3;


    pub fn get_datanodeUuid(&self) -> &str {
        match self.datanodeUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_datanodeUuid(&mut self) {
        self.datanodeUuid.clear();
    }

    pub fn has_datanodeUuid(&self) -> bool {
        self.datanodeUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datanodeUuid(&mut self, v: ::std::string::String) {
        self.datanodeUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_datanodeUuid(&mut self) -> &mut ::std::string::String {
        if self.datanodeUuid.is_none() {
            self.datanodeUuid.set_default();
        }
        self.datanodeUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_datanodeUuid(&mut self) -> ::std::string::String {
        self.datanodeUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint32 xferPort = 4;


    pub fn get_xferPort(&self) -> u32 {
        self.xferPort.unwrap_or(0)
    }
    pub fn clear_xferPort(&mut self) {
        self.xferPort = ::std::option::Option::None;
    }

    pub fn has_xferPort(&self) -> bool {
        self.xferPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xferPort(&mut self, v: u32) {
        self.xferPort = ::std::option::Option::Some(v);
    }

    // required uint32 infoPort = 5;


    pub fn get_infoPort(&self) -> u32 {
        self.infoPort.unwrap_or(0)
    }
    pub fn clear_infoPort(&mut self) {
        self.infoPort = ::std::option::Option::None;
    }

    pub fn has_infoPort(&self) -> bool {
        self.infoPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_infoPort(&mut self, v: u32) {
        self.infoPort = ::std::option::Option::Some(v);
    }

    // required uint32 ipcPort = 6;


    pub fn get_ipcPort(&self) -> u32 {
        self.ipcPort.unwrap_or(0)
    }
    pub fn clear_ipcPort(&mut self) {
        self.ipcPort = ::std::option::Option::None;
    }

    pub fn has_ipcPort(&self) -> bool {
        self.ipcPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipcPort(&mut self, v: u32) {
        self.ipcPort = ::std::option::Option::Some(v);
    }

    // optional uint32 infoSecurePort = 7;


    pub fn get_infoSecurePort(&self) -> u32 {
        self.infoSecurePort.unwrap_or(0u32)
    }
    pub fn clear_infoSecurePort(&mut self) {
        self.infoSecurePort = ::std::option::Option::None;
    }

    pub fn has_infoSecurePort(&self) -> bool {
        self.infoSecurePort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_infoSecurePort(&mut self, v: u32) {
        self.infoSecurePort = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DatanodeIDProto {
    fn is_initialized(&self) -> bool {
        if self.ipAddr.is_none() {
            return false;
        }
        if self.hostName.is_none() {
            return false;
        }
        if self.datanodeUuid.is_none() {
            return false;
        }
        if self.xferPort.is_none() {
            return false;
        }
        if self.infoPort.is_none() {
            return false;
        }
        if self.ipcPort.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ipAddr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.datanodeUuid)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.xferPort = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.infoPort = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ipcPort = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.infoSecurePort = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ipAddr.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.hostName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.datanodeUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.xferPort {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.infoPort {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ipcPort {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.infoSecurePort {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ipAddr.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.hostName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.datanodeUuid.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.xferPort {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.infoPort {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.ipcPort {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.infoSecurePort {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatanodeIDProto {
        DatanodeIDProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ipAddr",
                |m: &DatanodeIDProto| { &m.ipAddr },
                |m: &mut DatanodeIDProto| { &mut m.ipAddr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hostName",
                |m: &DatanodeIDProto| { &m.hostName },
                |m: &mut DatanodeIDProto| { &mut m.hostName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "datanodeUuid",
                |m: &DatanodeIDProto| { &m.datanodeUuid },
                |m: &mut DatanodeIDProto| { &mut m.datanodeUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "xferPort",
                |m: &DatanodeIDProto| { &m.xferPort },
                |m: &mut DatanodeIDProto| { &mut m.xferPort },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "infoPort",
                |m: &DatanodeIDProto| { &m.infoPort },
                |m: &mut DatanodeIDProto| { &mut m.infoPort },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ipcPort",
                |m: &DatanodeIDProto| { &m.ipcPort },
                |m: &mut DatanodeIDProto| { &mut m.ipcPort },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "infoSecurePort",
                |m: &DatanodeIDProto| { &m.infoSecurePort },
                |m: &mut DatanodeIDProto| { &mut m.infoSecurePort },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DatanodeIDProto>(
                "DatanodeIDProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DatanodeIDProto {
        static instance: ::protobuf::rt::LazyV2<DatanodeIDProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DatanodeIDProto::new)
    }
}

impl ::protobuf::Clear for DatanodeIDProto {
    fn clear(&mut self) {
        self.ipAddr.clear();
        self.hostName.clear();
        self.datanodeUuid.clear();
        self.xferPort = ::std::option::Option::None;
        self.infoPort = ::std::option::Option::None;
        self.ipcPort = ::std::option::Option::None;
        self.infoSecurePort = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatanodeIDProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeIDProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatanodeLocalInfoProto {
    // message fields
    softwareVersion: ::protobuf::SingularField<::std::string::String>,
    configVersion: ::protobuf::SingularField<::std::string::String>,
    uptime: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatanodeLocalInfoProto {
    fn default() -> &'a DatanodeLocalInfoProto {
        <DatanodeLocalInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl DatanodeLocalInfoProto {
    pub fn new() -> DatanodeLocalInfoProto {
        ::std::default::Default::default()
    }

    // required string softwareVersion = 1;


    pub fn get_softwareVersion(&self) -> &str {
        match self.softwareVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_softwareVersion(&mut self) {
        self.softwareVersion.clear();
    }

    pub fn has_softwareVersion(&self) -> bool {
        self.softwareVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_softwareVersion(&mut self, v: ::std::string::String) {
        self.softwareVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_softwareVersion(&mut self) -> &mut ::std::string::String {
        if self.softwareVersion.is_none() {
            self.softwareVersion.set_default();
        }
        self.softwareVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_softwareVersion(&mut self) -> ::std::string::String {
        self.softwareVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string configVersion = 2;


    pub fn get_configVersion(&self) -> &str {
        match self.configVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_configVersion(&mut self) {
        self.configVersion.clear();
    }

    pub fn has_configVersion(&self) -> bool {
        self.configVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configVersion(&mut self, v: ::std::string::String) {
        self.configVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configVersion(&mut self) -> &mut ::std::string::String {
        if self.configVersion.is_none() {
            self.configVersion.set_default();
        }
        self.configVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_configVersion(&mut self) -> ::std::string::String {
        self.configVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 uptime = 3;


    pub fn get_uptime(&self) -> u64 {
        self.uptime.unwrap_or(0)
    }
    pub fn clear_uptime(&mut self) {
        self.uptime = ::std::option::Option::None;
    }

    pub fn has_uptime(&self) -> bool {
        self.uptime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uptime(&mut self, v: u64) {
        self.uptime = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DatanodeLocalInfoProto {
    fn is_initialized(&self) -> bool {
        if self.softwareVersion.is_none() {
            return false;
        }
        if self.configVersion.is_none() {
            return false;
        }
        if self.uptime.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.softwareVersion)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.configVersion)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.uptime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.softwareVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.configVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.uptime {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.softwareVersion.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.configVersion.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.uptime {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatanodeLocalInfoProto {
        DatanodeLocalInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "softwareVersion",
                |m: &DatanodeLocalInfoProto| { &m.softwareVersion },
                |m: &mut DatanodeLocalInfoProto| { &mut m.softwareVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "configVersion",
                |m: &DatanodeLocalInfoProto| { &m.configVersion },
                |m: &mut DatanodeLocalInfoProto| { &mut m.configVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "uptime",
                |m: &DatanodeLocalInfoProto| { &m.uptime },
                |m: &mut DatanodeLocalInfoProto| { &mut m.uptime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DatanodeLocalInfoProto>(
                "DatanodeLocalInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DatanodeLocalInfoProto {
        static instance: ::protobuf::rt::LazyV2<DatanodeLocalInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DatanodeLocalInfoProto::new)
    }
}

impl ::protobuf::Clear for DatanodeLocalInfoProto {
    fn clear(&mut self) {
        self.softwareVersion.clear();
        self.configVersion.clear();
        self.uptime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatanodeLocalInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeLocalInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatanodeVolumeInfoProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    storageType: ::std::option::Option<StorageTypeProto>,
    usedSpace: ::std::option::Option<u64>,
    freeSpace: ::std::option::Option<u64>,
    reservedSpace: ::std::option::Option<u64>,
    reservedSpaceForReplicas: ::std::option::Option<u64>,
    numBlocks: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatanodeVolumeInfoProto {
    fn default() -> &'a DatanodeVolumeInfoProto {
        <DatanodeVolumeInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl DatanodeVolumeInfoProto {
    pub fn new() -> DatanodeVolumeInfoProto {
        ::std::default::Default::default()
    }

    // required string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.StorageTypeProto storageType = 2;


    pub fn get_storageType(&self) -> StorageTypeProto {
        self.storageType.unwrap_or(StorageTypeProto::DISK)
    }
    pub fn clear_storageType(&mut self) {
        self.storageType = ::std::option::Option::None;
    }

    pub fn has_storageType(&self) -> bool {
        self.storageType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageType(&mut self, v: StorageTypeProto) {
        self.storageType = ::std::option::Option::Some(v);
    }

    // required uint64 usedSpace = 3;


    pub fn get_usedSpace(&self) -> u64 {
        self.usedSpace.unwrap_or(0)
    }
    pub fn clear_usedSpace(&mut self) {
        self.usedSpace = ::std::option::Option::None;
    }

    pub fn has_usedSpace(&self) -> bool {
        self.usedSpace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usedSpace(&mut self, v: u64) {
        self.usedSpace = ::std::option::Option::Some(v);
    }

    // required uint64 freeSpace = 4;


    pub fn get_freeSpace(&self) -> u64 {
        self.freeSpace.unwrap_or(0)
    }
    pub fn clear_freeSpace(&mut self) {
        self.freeSpace = ::std::option::Option::None;
    }

    pub fn has_freeSpace(&self) -> bool {
        self.freeSpace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_freeSpace(&mut self, v: u64) {
        self.freeSpace = ::std::option::Option::Some(v);
    }

    // required uint64 reservedSpace = 5;


    pub fn get_reservedSpace(&self) -> u64 {
        self.reservedSpace.unwrap_or(0)
    }
    pub fn clear_reservedSpace(&mut self) {
        self.reservedSpace = ::std::option::Option::None;
    }

    pub fn has_reservedSpace(&self) -> bool {
        self.reservedSpace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservedSpace(&mut self, v: u64) {
        self.reservedSpace = ::std::option::Option::Some(v);
    }

    // required uint64 reservedSpaceForReplicas = 6;


    pub fn get_reservedSpaceForReplicas(&self) -> u64 {
        self.reservedSpaceForReplicas.unwrap_or(0)
    }
    pub fn clear_reservedSpaceForReplicas(&mut self) {
        self.reservedSpaceForReplicas = ::std::option::Option::None;
    }

    pub fn has_reservedSpaceForReplicas(&self) -> bool {
        self.reservedSpaceForReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservedSpaceForReplicas(&mut self, v: u64) {
        self.reservedSpaceForReplicas = ::std::option::Option::Some(v);
    }

    // required uint64 numBlocks = 7;


    pub fn get_numBlocks(&self) -> u64 {
        self.numBlocks.unwrap_or(0)
    }
    pub fn clear_numBlocks(&mut self) {
        self.numBlocks = ::std::option::Option::None;
    }

    pub fn has_numBlocks(&self) -> bool {
        self.numBlocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numBlocks(&mut self, v: u64) {
        self.numBlocks = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DatanodeVolumeInfoProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        if self.storageType.is_none() {
            return false;
        }
        if self.usedSpace.is_none() {
            return false;
        }
        if self.freeSpace.is_none() {
            return false;
        }
        if self.reservedSpace.is_none() {
            return false;
        }
        if self.reservedSpaceForReplicas.is_none() {
            return false;
        }
        if self.numBlocks.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.storageType, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.usedSpace = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.freeSpace = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.reservedSpace = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.reservedSpaceForReplicas = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.numBlocks = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.storageType {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.usedSpace {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.freeSpace {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reservedSpace {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reservedSpaceForReplicas {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numBlocks {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.storageType {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.usedSpace {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.freeSpace {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.reservedSpace {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.reservedSpaceForReplicas {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.numBlocks {
            os.write_uint64(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatanodeVolumeInfoProto {
        DatanodeVolumeInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &DatanodeVolumeInfoProto| { &m.path },
                |m: &mut DatanodeVolumeInfoProto| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StorageTypeProto>>(
                "storageType",
                |m: &DatanodeVolumeInfoProto| { &m.storageType },
                |m: &mut DatanodeVolumeInfoProto| { &mut m.storageType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "usedSpace",
                |m: &DatanodeVolumeInfoProto| { &m.usedSpace },
                |m: &mut DatanodeVolumeInfoProto| { &mut m.usedSpace },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "freeSpace",
                |m: &DatanodeVolumeInfoProto| { &m.freeSpace },
                |m: &mut DatanodeVolumeInfoProto| { &mut m.freeSpace },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "reservedSpace",
                |m: &DatanodeVolumeInfoProto| { &m.reservedSpace },
                |m: &mut DatanodeVolumeInfoProto| { &mut m.reservedSpace },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "reservedSpaceForReplicas",
                |m: &DatanodeVolumeInfoProto| { &m.reservedSpaceForReplicas },
                |m: &mut DatanodeVolumeInfoProto| { &mut m.reservedSpaceForReplicas },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "numBlocks",
                |m: &DatanodeVolumeInfoProto| { &m.numBlocks },
                |m: &mut DatanodeVolumeInfoProto| { &mut m.numBlocks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DatanodeVolumeInfoProto>(
                "DatanodeVolumeInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DatanodeVolumeInfoProto {
        static instance: ::protobuf::rt::LazyV2<DatanodeVolumeInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DatanodeVolumeInfoProto::new)
    }
}

impl ::protobuf::Clear for DatanodeVolumeInfoProto {
    fn clear(&mut self) {
        self.path.clear();
        self.storageType = ::std::option::Option::None;
        self.usedSpace = ::std::option::Option::None;
        self.freeSpace = ::std::option::Option::None;
        self.reservedSpace = ::std::option::Option::None;
        self.reservedSpaceForReplicas = ::std::option::Option::None;
        self.numBlocks = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatanodeVolumeInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeVolumeInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatanodeInfosProto {
    // message fields
    pub datanodes: ::protobuf::RepeatedField<DatanodeInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatanodeInfosProto {
    fn default() -> &'a DatanodeInfosProto {
        <DatanodeInfosProto as ::protobuf::Message>::default_instance()
    }
}

impl DatanodeInfosProto {
    pub fn new() -> DatanodeInfosProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto datanodes = 1;


    pub fn get_datanodes(&self) -> &[DatanodeInfoProto] {
        &self.datanodes
    }
    pub fn clear_datanodes(&mut self) {
        self.datanodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_datanodes(&mut self, v: ::protobuf::RepeatedField<DatanodeInfoProto>) {
        self.datanodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_datanodes(&mut self) -> &mut ::protobuf::RepeatedField<DatanodeInfoProto> {
        &mut self.datanodes
    }

    // Take field
    pub fn take_datanodes(&mut self) -> ::protobuf::RepeatedField<DatanodeInfoProto> {
        ::std::mem::replace(&mut self.datanodes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DatanodeInfosProto {
    fn is_initialized(&self) -> bool {
        for v in &self.datanodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.datanodes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.datanodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.datanodes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatanodeInfosProto {
        DatanodeInfosProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeInfoProto>>(
                "datanodes",
                |m: &DatanodeInfosProto| { &m.datanodes },
                |m: &mut DatanodeInfosProto| { &mut m.datanodes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DatanodeInfosProto>(
                "DatanodeInfosProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DatanodeInfosProto {
        static instance: ::protobuf::rt::LazyV2<DatanodeInfosProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DatanodeInfosProto::new)
    }
}

impl ::protobuf::Clear for DatanodeInfosProto {
    fn clear(&mut self) {
        self.datanodes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatanodeInfosProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeInfosProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatanodeInfoProto {
    // message fields
    pub id: ::protobuf::SingularPtrField<DatanodeIDProto>,
    capacity: ::std::option::Option<u64>,
    dfsUsed: ::std::option::Option<u64>,
    remaining: ::std::option::Option<u64>,
    blockPoolUsed: ::std::option::Option<u64>,
    lastUpdate: ::std::option::Option<u64>,
    xceiverCount: ::std::option::Option<u32>,
    location: ::protobuf::SingularField<::std::string::String>,
    nonDfsUsed: ::std::option::Option<u64>,
    adminState: ::std::option::Option<DatanodeInfoProto_AdminState>,
    cacheCapacity: ::std::option::Option<u64>,
    cacheUsed: ::std::option::Option<u64>,
    lastUpdateMonotonic: ::std::option::Option<u64>,
    upgradeDomain: ::protobuf::SingularField<::std::string::String>,
    lastBlockReportTime: ::std::option::Option<u64>,
    lastBlockReportMonotonic: ::std::option::Option<u64>,
    numBlocks: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatanodeInfoProto {
    fn default() -> &'a DatanodeInfoProto {
        <DatanodeInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl DatanodeInfoProto {
    pub fn new() -> DatanodeInfoProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.DatanodeIDProto id = 1;


    pub fn get_id(&self) -> &DatanodeIDProto {
        self.id.as_ref().unwrap_or_else(|| <DatanodeIDProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: DatanodeIDProto) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut DatanodeIDProto {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> DatanodeIDProto {
        self.id.take().unwrap_or_else(|| DatanodeIDProto::new())
    }

    // optional uint64 capacity = 2;


    pub fn get_capacity(&self) -> u64 {
        self.capacity.unwrap_or(0u64)
    }
    pub fn clear_capacity(&mut self) {
        self.capacity = ::std::option::Option::None;
    }

    pub fn has_capacity(&self) -> bool {
        self.capacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: u64) {
        self.capacity = ::std::option::Option::Some(v);
    }

    // optional uint64 dfsUsed = 3;


    pub fn get_dfsUsed(&self) -> u64 {
        self.dfsUsed.unwrap_or(0u64)
    }
    pub fn clear_dfsUsed(&mut self) {
        self.dfsUsed = ::std::option::Option::None;
    }

    pub fn has_dfsUsed(&self) -> bool {
        self.dfsUsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dfsUsed(&mut self, v: u64) {
        self.dfsUsed = ::std::option::Option::Some(v);
    }

    // optional uint64 remaining = 4;


    pub fn get_remaining(&self) -> u64 {
        self.remaining.unwrap_or(0u64)
    }
    pub fn clear_remaining(&mut self) {
        self.remaining = ::std::option::Option::None;
    }

    pub fn has_remaining(&self) -> bool {
        self.remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remaining(&mut self, v: u64) {
        self.remaining = ::std::option::Option::Some(v);
    }

    // optional uint64 blockPoolUsed = 5;


    pub fn get_blockPoolUsed(&self) -> u64 {
        self.blockPoolUsed.unwrap_or(0u64)
    }
    pub fn clear_blockPoolUsed(&mut self) {
        self.blockPoolUsed = ::std::option::Option::None;
    }

    pub fn has_blockPoolUsed(&self) -> bool {
        self.blockPoolUsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockPoolUsed(&mut self, v: u64) {
        self.blockPoolUsed = ::std::option::Option::Some(v);
    }

    // optional uint64 lastUpdate = 6;


    pub fn get_lastUpdate(&self) -> u64 {
        self.lastUpdate.unwrap_or(0u64)
    }
    pub fn clear_lastUpdate(&mut self) {
        self.lastUpdate = ::std::option::Option::None;
    }

    pub fn has_lastUpdate(&self) -> bool {
        self.lastUpdate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastUpdate(&mut self, v: u64) {
        self.lastUpdate = ::std::option::Option::Some(v);
    }

    // optional uint32 xceiverCount = 7;


    pub fn get_xceiverCount(&self) -> u32 {
        self.xceiverCount.unwrap_or(0u32)
    }
    pub fn clear_xceiverCount(&mut self) {
        self.xceiverCount = ::std::option::Option::None;
    }

    pub fn has_xceiverCount(&self) -> bool {
        self.xceiverCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xceiverCount(&mut self, v: u32) {
        self.xceiverCount = ::std::option::Option::Some(v);
    }

    // optional string location = 8;


    pub fn get_location(&self) -> &str {
        match self.location.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::std::string::String {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        self.location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 nonDfsUsed = 9;


    pub fn get_nonDfsUsed(&self) -> u64 {
        self.nonDfsUsed.unwrap_or(0)
    }
    pub fn clear_nonDfsUsed(&mut self) {
        self.nonDfsUsed = ::std::option::Option::None;
    }

    pub fn has_nonDfsUsed(&self) -> bool {
        self.nonDfsUsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonDfsUsed(&mut self, v: u64) {
        self.nonDfsUsed = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.DatanodeInfoProto.AdminState adminState = 10;


    pub fn get_adminState(&self) -> DatanodeInfoProto_AdminState {
        self.adminState.unwrap_or(DatanodeInfoProto_AdminState::NORMAL)
    }
    pub fn clear_adminState(&mut self) {
        self.adminState = ::std::option::Option::None;
    }

    pub fn has_adminState(&self) -> bool {
        self.adminState.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adminState(&mut self, v: DatanodeInfoProto_AdminState) {
        self.adminState = ::std::option::Option::Some(v);
    }

    // optional uint64 cacheCapacity = 11;


    pub fn get_cacheCapacity(&self) -> u64 {
        self.cacheCapacity.unwrap_or(0u64)
    }
    pub fn clear_cacheCapacity(&mut self) {
        self.cacheCapacity = ::std::option::Option::None;
    }

    pub fn has_cacheCapacity(&self) -> bool {
        self.cacheCapacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cacheCapacity(&mut self, v: u64) {
        self.cacheCapacity = ::std::option::Option::Some(v);
    }

    // optional uint64 cacheUsed = 12;


    pub fn get_cacheUsed(&self) -> u64 {
        self.cacheUsed.unwrap_or(0u64)
    }
    pub fn clear_cacheUsed(&mut self) {
        self.cacheUsed = ::std::option::Option::None;
    }

    pub fn has_cacheUsed(&self) -> bool {
        self.cacheUsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cacheUsed(&mut self, v: u64) {
        self.cacheUsed = ::std::option::Option::Some(v);
    }

    // optional uint64 lastUpdateMonotonic = 13;


    pub fn get_lastUpdateMonotonic(&self) -> u64 {
        self.lastUpdateMonotonic.unwrap_or(0u64)
    }
    pub fn clear_lastUpdateMonotonic(&mut self) {
        self.lastUpdateMonotonic = ::std::option::Option::None;
    }

    pub fn has_lastUpdateMonotonic(&self) -> bool {
        self.lastUpdateMonotonic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastUpdateMonotonic(&mut self, v: u64) {
        self.lastUpdateMonotonic = ::std::option::Option::Some(v);
    }

    // optional string upgradeDomain = 14;


    pub fn get_upgradeDomain(&self) -> &str {
        match self.upgradeDomain.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_upgradeDomain(&mut self) {
        self.upgradeDomain.clear();
    }

    pub fn has_upgradeDomain(&self) -> bool {
        self.upgradeDomain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upgradeDomain(&mut self, v: ::std::string::String) {
        self.upgradeDomain = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upgradeDomain(&mut self) -> &mut ::std::string::String {
        if self.upgradeDomain.is_none() {
            self.upgradeDomain.set_default();
        }
        self.upgradeDomain.as_mut().unwrap()
    }

    // Take field
    pub fn take_upgradeDomain(&mut self) -> ::std::string::String {
        self.upgradeDomain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 lastBlockReportTime = 15;


    pub fn get_lastBlockReportTime(&self) -> u64 {
        self.lastBlockReportTime.unwrap_or(0u64)
    }
    pub fn clear_lastBlockReportTime(&mut self) {
        self.lastBlockReportTime = ::std::option::Option::None;
    }

    pub fn has_lastBlockReportTime(&self) -> bool {
        self.lastBlockReportTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastBlockReportTime(&mut self, v: u64) {
        self.lastBlockReportTime = ::std::option::Option::Some(v);
    }

    // optional uint64 lastBlockReportMonotonic = 16;


    pub fn get_lastBlockReportMonotonic(&self) -> u64 {
        self.lastBlockReportMonotonic.unwrap_or(0u64)
    }
    pub fn clear_lastBlockReportMonotonic(&mut self) {
        self.lastBlockReportMonotonic = ::std::option::Option::None;
    }

    pub fn has_lastBlockReportMonotonic(&self) -> bool {
        self.lastBlockReportMonotonic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastBlockReportMonotonic(&mut self, v: u64) {
        self.lastBlockReportMonotonic = ::std::option::Option::Some(v);
    }

    // optional uint32 numBlocks = 17;


    pub fn get_numBlocks(&self) -> u32 {
        self.numBlocks.unwrap_or(0u32)
    }
    pub fn clear_numBlocks(&mut self) {
        self.numBlocks = ::std::option::Option::None;
    }

    pub fn has_numBlocks(&self) -> bool {
        self.numBlocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numBlocks(&mut self, v: u32) {
        self.numBlocks = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DatanodeInfoProto {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.capacity = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dfsUsed = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.remaining = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockPoolUsed = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lastUpdate = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.xceiverCount = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.location)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nonDfsUsed = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.adminState, 10, &mut self.unknown_fields)?
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cacheCapacity = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cacheUsed = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lastUpdateMonotonic = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.upgradeDomain)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lastBlockReportTime = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lastBlockReportMonotonic = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.numBlocks = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.capacity {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dfsUsed {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.remaining {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blockPoolUsed {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lastUpdate {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.xceiverCount {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.location.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.nonDfsUsed {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.adminState {
            my_size += ::protobuf::rt::enum_size(10, v);
        }
        if let Some(v) = self.cacheCapacity {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cacheUsed {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lastUpdateMonotonic {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.upgradeDomain.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.lastBlockReportTime {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lastBlockReportMonotonic {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numBlocks {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.capacity {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.dfsUsed {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.remaining {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.blockPoolUsed {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.lastUpdate {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.xceiverCount {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.location.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.nonDfsUsed {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.adminState {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.cacheCapacity {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.cacheUsed {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.lastUpdateMonotonic {
            os.write_uint64(13, v)?;
        }
        if let Some(ref v) = self.upgradeDomain.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(v) = self.lastBlockReportTime {
            os.write_uint64(15, v)?;
        }
        if let Some(v) = self.lastBlockReportMonotonic {
            os.write_uint64(16, v)?;
        }
        if let Some(v) = self.numBlocks {
            os.write_uint32(17, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatanodeInfoProto {
        DatanodeInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeIDProto>>(
                "id",
                |m: &DatanodeInfoProto| { &m.id },
                |m: &mut DatanodeInfoProto| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "capacity",
                |m: &DatanodeInfoProto| { &m.capacity },
                |m: &mut DatanodeInfoProto| { &mut m.capacity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "dfsUsed",
                |m: &DatanodeInfoProto| { &m.dfsUsed },
                |m: &mut DatanodeInfoProto| { &mut m.dfsUsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "remaining",
                |m: &DatanodeInfoProto| { &m.remaining },
                |m: &mut DatanodeInfoProto| { &mut m.remaining },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "blockPoolUsed",
                |m: &DatanodeInfoProto| { &m.blockPoolUsed },
                |m: &mut DatanodeInfoProto| { &mut m.blockPoolUsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "lastUpdate",
                |m: &DatanodeInfoProto| { &m.lastUpdate },
                |m: &mut DatanodeInfoProto| { &mut m.lastUpdate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "xceiverCount",
                |m: &DatanodeInfoProto| { &m.xceiverCount },
                |m: &mut DatanodeInfoProto| { &mut m.xceiverCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "location",
                |m: &DatanodeInfoProto| { &m.location },
                |m: &mut DatanodeInfoProto| { &mut m.location },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "nonDfsUsed",
                |m: &DatanodeInfoProto| { &m.nonDfsUsed },
                |m: &mut DatanodeInfoProto| { &mut m.nonDfsUsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DatanodeInfoProto_AdminState>>(
                "adminState",
                |m: &DatanodeInfoProto| { &m.adminState },
                |m: &mut DatanodeInfoProto| { &mut m.adminState },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "cacheCapacity",
                |m: &DatanodeInfoProto| { &m.cacheCapacity },
                |m: &mut DatanodeInfoProto| { &mut m.cacheCapacity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "cacheUsed",
                |m: &DatanodeInfoProto| { &m.cacheUsed },
                |m: &mut DatanodeInfoProto| { &mut m.cacheUsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "lastUpdateMonotonic",
                |m: &DatanodeInfoProto| { &m.lastUpdateMonotonic },
                |m: &mut DatanodeInfoProto| { &mut m.lastUpdateMonotonic },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "upgradeDomain",
                |m: &DatanodeInfoProto| { &m.upgradeDomain },
                |m: &mut DatanodeInfoProto| { &mut m.upgradeDomain },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "lastBlockReportTime",
                |m: &DatanodeInfoProto| { &m.lastBlockReportTime },
                |m: &mut DatanodeInfoProto| { &mut m.lastBlockReportTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "lastBlockReportMonotonic",
                |m: &DatanodeInfoProto| { &m.lastBlockReportMonotonic },
                |m: &mut DatanodeInfoProto| { &mut m.lastBlockReportMonotonic },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "numBlocks",
                |m: &DatanodeInfoProto| { &m.numBlocks },
                |m: &mut DatanodeInfoProto| { &mut m.numBlocks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DatanodeInfoProto>(
                "DatanodeInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DatanodeInfoProto {
        static instance: ::protobuf::rt::LazyV2<DatanodeInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DatanodeInfoProto::new)
    }
}

impl ::protobuf::Clear for DatanodeInfoProto {
    fn clear(&mut self) {
        self.id.clear();
        self.capacity = ::std::option::Option::None;
        self.dfsUsed = ::std::option::Option::None;
        self.remaining = ::std::option::Option::None;
        self.blockPoolUsed = ::std::option::Option::None;
        self.lastUpdate = ::std::option::Option::None;
        self.xceiverCount = ::std::option::Option::None;
        self.location.clear();
        self.nonDfsUsed = ::std::option::Option::None;
        self.adminState = ::std::option::Option::None;
        self.cacheCapacity = ::std::option::Option::None;
        self.cacheUsed = ::std::option::Option::None;
        self.lastUpdateMonotonic = ::std::option::Option::None;
        self.upgradeDomain.clear();
        self.lastBlockReportTime = ::std::option::Option::None;
        self.lastBlockReportMonotonic = ::std::option::Option::None;
        self.numBlocks = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatanodeInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DatanodeInfoProto_AdminState {
    NORMAL = 0,
    DECOMMISSION_INPROGRESS = 1,
    DECOMMISSIONED = 2,
    ENTERING_MAINTENANCE = 3,
    IN_MAINTENANCE = 4,
}

impl ::protobuf::ProtobufEnum for DatanodeInfoProto_AdminState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DatanodeInfoProto_AdminState> {
        match value {
            0 => ::std::option::Option::Some(DatanodeInfoProto_AdminState::NORMAL),
            1 => ::std::option::Option::Some(DatanodeInfoProto_AdminState::DECOMMISSION_INPROGRESS),
            2 => ::std::option::Option::Some(DatanodeInfoProto_AdminState::DECOMMISSIONED),
            3 => ::std::option::Option::Some(DatanodeInfoProto_AdminState::ENTERING_MAINTENANCE),
            4 => ::std::option::Option::Some(DatanodeInfoProto_AdminState::IN_MAINTENANCE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DatanodeInfoProto_AdminState] = &[
            DatanodeInfoProto_AdminState::NORMAL,
            DatanodeInfoProto_AdminState::DECOMMISSION_INPROGRESS,
            DatanodeInfoProto_AdminState::DECOMMISSIONED,
            DatanodeInfoProto_AdminState::ENTERING_MAINTENANCE,
            DatanodeInfoProto_AdminState::IN_MAINTENANCE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DatanodeInfoProto_AdminState>("DatanodeInfoProto.AdminState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DatanodeInfoProto_AdminState {
}

impl ::std::default::Default for DatanodeInfoProto_AdminState {
    fn default() -> Self {
        DatanodeInfoProto_AdminState::NORMAL
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeInfoProto_AdminState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatanodeStorageProto {
    // message fields
    storageUuid: ::protobuf::SingularField<::std::string::String>,
    state: ::std::option::Option<DatanodeStorageProto_StorageState>,
    storageType: ::std::option::Option<StorageTypeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatanodeStorageProto {
    fn default() -> &'a DatanodeStorageProto {
        <DatanodeStorageProto as ::protobuf::Message>::default_instance()
    }
}

impl DatanodeStorageProto {
    pub fn new() -> DatanodeStorageProto {
        ::std::default::Default::default()
    }

    // required string storageUuid = 1;


    pub fn get_storageUuid(&self) -> &str {
        match self.storageUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_storageUuid(&mut self) {
        self.storageUuid.clear();
    }

    pub fn has_storageUuid(&self) -> bool {
        self.storageUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageUuid(&mut self, v: ::std::string::String) {
        self.storageUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageUuid(&mut self) -> &mut ::std::string::String {
        if self.storageUuid.is_none() {
            self.storageUuid.set_default();
        }
        self.storageUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageUuid(&mut self) -> ::std::string::String {
        self.storageUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .hadoop.hdfs.DatanodeStorageProto.StorageState state = 2;


    pub fn get_state(&self) -> DatanodeStorageProto_StorageState {
        self.state.unwrap_or(DatanodeStorageProto_StorageState::NORMAL)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: DatanodeStorageProto_StorageState) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.StorageTypeProto storageType = 3;


    pub fn get_storageType(&self) -> StorageTypeProto {
        self.storageType.unwrap_or(StorageTypeProto::DISK)
    }
    pub fn clear_storageType(&mut self) {
        self.storageType = ::std::option::Option::None;
    }

    pub fn has_storageType(&self) -> bool {
        self.storageType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageType(&mut self, v: StorageTypeProto) {
        self.storageType = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DatanodeStorageProto {
    fn is_initialized(&self) -> bool {
        if self.storageUuid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storageUuid)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.storageType, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.storageUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.storageType {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.storageUuid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.state {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.storageType {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatanodeStorageProto {
        DatanodeStorageProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storageUuid",
                |m: &DatanodeStorageProto| { &m.storageUuid },
                |m: &mut DatanodeStorageProto| { &mut m.storageUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DatanodeStorageProto_StorageState>>(
                "state",
                |m: &DatanodeStorageProto| { &m.state },
                |m: &mut DatanodeStorageProto| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StorageTypeProto>>(
                "storageType",
                |m: &DatanodeStorageProto| { &m.storageType },
                |m: &mut DatanodeStorageProto| { &mut m.storageType },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DatanodeStorageProto>(
                "DatanodeStorageProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DatanodeStorageProto {
        static instance: ::protobuf::rt::LazyV2<DatanodeStorageProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DatanodeStorageProto::new)
    }
}

impl ::protobuf::Clear for DatanodeStorageProto {
    fn clear(&mut self) {
        self.storageUuid.clear();
        self.state = ::std::option::Option::None;
        self.storageType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatanodeStorageProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeStorageProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DatanodeStorageProto_StorageState {
    NORMAL = 0,
    READ_ONLY_SHARED = 1,
}

impl ::protobuf::ProtobufEnum for DatanodeStorageProto_StorageState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DatanodeStorageProto_StorageState> {
        match value {
            0 => ::std::option::Option::Some(DatanodeStorageProto_StorageState::NORMAL),
            1 => ::std::option::Option::Some(DatanodeStorageProto_StorageState::READ_ONLY_SHARED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DatanodeStorageProto_StorageState] = &[
            DatanodeStorageProto_StorageState::NORMAL,
            DatanodeStorageProto_StorageState::READ_ONLY_SHARED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DatanodeStorageProto_StorageState>("DatanodeStorageProto.StorageState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DatanodeStorageProto_StorageState {
}

impl ::std::default::Default for DatanodeStorageProto_StorageState {
    fn default() -> Self {
        DatanodeStorageProto_StorageState::NORMAL
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeStorageProto_StorageState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageReportProto {
    // message fields
    storageUuid: ::protobuf::SingularField<::std::string::String>,
    failed: ::std::option::Option<bool>,
    capacity: ::std::option::Option<u64>,
    dfsUsed: ::std::option::Option<u64>,
    remaining: ::std::option::Option<u64>,
    blockPoolUsed: ::std::option::Option<u64>,
    pub storage: ::protobuf::SingularPtrField<DatanodeStorageProto>,
    nonDfsUsed: ::std::option::Option<u64>,
    mount: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorageReportProto {
    fn default() -> &'a StorageReportProto {
        <StorageReportProto as ::protobuf::Message>::default_instance()
    }
}

impl StorageReportProto {
    pub fn new() -> StorageReportProto {
        ::std::default::Default::default()
    }

    // required string storageUuid = 1;


    pub fn get_storageUuid(&self) -> &str {
        match self.storageUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_storageUuid(&mut self) {
        self.storageUuid.clear();
    }

    pub fn has_storageUuid(&self) -> bool {
        self.storageUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageUuid(&mut self, v: ::std::string::String) {
        self.storageUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageUuid(&mut self) -> &mut ::std::string::String {
        if self.storageUuid.is_none() {
            self.storageUuid.set_default();
        }
        self.storageUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageUuid(&mut self) -> ::std::string::String {
        self.storageUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool failed = 2;


    pub fn get_failed(&self) -> bool {
        self.failed.unwrap_or(false)
    }
    pub fn clear_failed(&mut self) {
        self.failed = ::std::option::Option::None;
    }

    pub fn has_failed(&self) -> bool {
        self.failed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failed(&mut self, v: bool) {
        self.failed = ::std::option::Option::Some(v);
    }

    // optional uint64 capacity = 3;


    pub fn get_capacity(&self) -> u64 {
        self.capacity.unwrap_or(0u64)
    }
    pub fn clear_capacity(&mut self) {
        self.capacity = ::std::option::Option::None;
    }

    pub fn has_capacity(&self) -> bool {
        self.capacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: u64) {
        self.capacity = ::std::option::Option::Some(v);
    }

    // optional uint64 dfsUsed = 4;


    pub fn get_dfsUsed(&self) -> u64 {
        self.dfsUsed.unwrap_or(0u64)
    }
    pub fn clear_dfsUsed(&mut self) {
        self.dfsUsed = ::std::option::Option::None;
    }

    pub fn has_dfsUsed(&self) -> bool {
        self.dfsUsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dfsUsed(&mut self, v: u64) {
        self.dfsUsed = ::std::option::Option::Some(v);
    }

    // optional uint64 remaining = 5;


    pub fn get_remaining(&self) -> u64 {
        self.remaining.unwrap_or(0u64)
    }
    pub fn clear_remaining(&mut self) {
        self.remaining = ::std::option::Option::None;
    }

    pub fn has_remaining(&self) -> bool {
        self.remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remaining(&mut self, v: u64) {
        self.remaining = ::std::option::Option::Some(v);
    }

    // optional uint64 blockPoolUsed = 6;


    pub fn get_blockPoolUsed(&self) -> u64 {
        self.blockPoolUsed.unwrap_or(0u64)
    }
    pub fn clear_blockPoolUsed(&mut self) {
        self.blockPoolUsed = ::std::option::Option::None;
    }

    pub fn has_blockPoolUsed(&self) -> bool {
        self.blockPoolUsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockPoolUsed(&mut self, v: u64) {
        self.blockPoolUsed = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.DatanodeStorageProto storage = 7;


    pub fn get_storage(&self) -> &DatanodeStorageProto {
        self.storage.as_ref().unwrap_or_else(|| <DatanodeStorageProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_storage(&mut self) {
        self.storage.clear();
    }

    pub fn has_storage(&self) -> bool {
        self.storage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storage(&mut self, v: DatanodeStorageProto) {
        self.storage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storage(&mut self) -> &mut DatanodeStorageProto {
        if self.storage.is_none() {
            self.storage.set_default();
        }
        self.storage.as_mut().unwrap()
    }

    // Take field
    pub fn take_storage(&mut self) -> DatanodeStorageProto {
        self.storage.take().unwrap_or_else(|| DatanodeStorageProto::new())
    }

    // optional uint64 nonDfsUsed = 8;


    pub fn get_nonDfsUsed(&self) -> u64 {
        self.nonDfsUsed.unwrap_or(0)
    }
    pub fn clear_nonDfsUsed(&mut self) {
        self.nonDfsUsed = ::std::option::Option::None;
    }

    pub fn has_nonDfsUsed(&self) -> bool {
        self.nonDfsUsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonDfsUsed(&mut self, v: u64) {
        self.nonDfsUsed = ::std::option::Option::Some(v);
    }

    // optional string mount = 9;


    pub fn get_mount(&self) -> &str {
        match self.mount.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_mount(&mut self) {
        self.mount.clear();
    }

    pub fn has_mount(&self) -> bool {
        self.mount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mount(&mut self, v: ::std::string::String) {
        self.mount = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mount(&mut self) -> &mut ::std::string::String {
        if self.mount.is_none() {
            self.mount.set_default();
        }
        self.mount.as_mut().unwrap()
    }

    // Take field
    pub fn take_mount(&mut self) -> ::std::string::String {
        self.mount.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for StorageReportProto {
    fn is_initialized(&self) -> bool {
        if self.storageUuid.is_none() {
            return false;
        }
        for v in &self.storage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storageUuid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.failed = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.capacity = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dfsUsed = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.remaining = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockPoolUsed = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.storage)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nonDfsUsed = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.storageUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.failed {
            my_size += 2;
        }
        if let Some(v) = self.capacity {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dfsUsed {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.remaining {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blockPoolUsed {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.storage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.nonDfsUsed {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.mount.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.storageUuid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.failed {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.capacity {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.dfsUsed {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.remaining {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.blockPoolUsed {
            os.write_uint64(6, v)?;
        }
        if let Some(ref v) = self.storage.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.nonDfsUsed {
            os.write_uint64(8, v)?;
        }
        if let Some(ref v) = self.mount.as_ref() {
            os.write_string(9, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageReportProto {
        StorageReportProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storageUuid",
                |m: &StorageReportProto| { &m.storageUuid },
                |m: &mut StorageReportProto| { &mut m.storageUuid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "failed",
                |m: &StorageReportProto| { &m.failed },
                |m: &mut StorageReportProto| { &mut m.failed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "capacity",
                |m: &StorageReportProto| { &m.capacity },
                |m: &mut StorageReportProto| { &mut m.capacity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "dfsUsed",
                |m: &StorageReportProto| { &m.dfsUsed },
                |m: &mut StorageReportProto| { &mut m.dfsUsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "remaining",
                |m: &StorageReportProto| { &m.remaining },
                |m: &mut StorageReportProto| { &mut m.remaining },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "blockPoolUsed",
                |m: &StorageReportProto| { &m.blockPoolUsed },
                |m: &mut StorageReportProto| { &mut m.blockPoolUsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeStorageProto>>(
                "storage",
                |m: &StorageReportProto| { &m.storage },
                |m: &mut StorageReportProto| { &mut m.storage },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "nonDfsUsed",
                |m: &StorageReportProto| { &m.nonDfsUsed },
                |m: &mut StorageReportProto| { &mut m.nonDfsUsed },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mount",
                |m: &StorageReportProto| { &m.mount },
                |m: &mut StorageReportProto| { &mut m.mount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StorageReportProto>(
                "StorageReportProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StorageReportProto {
        static instance: ::protobuf::rt::LazyV2<StorageReportProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StorageReportProto::new)
    }
}

impl ::protobuf::Clear for StorageReportProto {
    fn clear(&mut self) {
        self.storageUuid.clear();
        self.failed = ::std::option::Option::None;
        self.capacity = ::std::option::Option::None;
        self.dfsUsed = ::std::option::Option::None;
        self.remaining = ::std::option::Option::None;
        self.blockPoolUsed = ::std::option::Option::None;
        self.storage.clear();
        self.nonDfsUsed = ::std::option::Option::None;
        self.mount.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageReportProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageReportProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContentSummaryProto {
    // message fields
    length: ::std::option::Option<u64>,
    fileCount: ::std::option::Option<u64>,
    directoryCount: ::std::option::Option<u64>,
    quota: ::std::option::Option<u64>,
    spaceConsumed: ::std::option::Option<u64>,
    spaceQuota: ::std::option::Option<u64>,
    pub typeQuotaInfos: ::protobuf::SingularPtrField<StorageTypeQuotaInfosProto>,
    snapshotLength: ::std::option::Option<u64>,
    snapshotFileCount: ::std::option::Option<u64>,
    snapshotDirectoryCount: ::std::option::Option<u64>,
    snapshotSpaceConsumed: ::std::option::Option<u64>,
    erasureCodingPolicy: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContentSummaryProto {
    fn default() -> &'a ContentSummaryProto {
        <ContentSummaryProto as ::protobuf::Message>::default_instance()
    }
}

impl ContentSummaryProto {
    pub fn new() -> ContentSummaryProto {
        ::std::default::Default::default()
    }

    // required uint64 length = 1;


    pub fn get_length(&self) -> u64 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = ::std::option::Option::Some(v);
    }

    // required uint64 fileCount = 2;


    pub fn get_fileCount(&self) -> u64 {
        self.fileCount.unwrap_or(0)
    }
    pub fn clear_fileCount(&mut self) {
        self.fileCount = ::std::option::Option::None;
    }

    pub fn has_fileCount(&self) -> bool {
        self.fileCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileCount(&mut self, v: u64) {
        self.fileCount = ::std::option::Option::Some(v);
    }

    // required uint64 directoryCount = 3;


    pub fn get_directoryCount(&self) -> u64 {
        self.directoryCount.unwrap_or(0)
    }
    pub fn clear_directoryCount(&mut self) {
        self.directoryCount = ::std::option::Option::None;
    }

    pub fn has_directoryCount(&self) -> bool {
        self.directoryCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directoryCount(&mut self, v: u64) {
        self.directoryCount = ::std::option::Option::Some(v);
    }

    // required uint64 quota = 4;


    pub fn get_quota(&self) -> u64 {
        self.quota.unwrap_or(0)
    }
    pub fn clear_quota(&mut self) {
        self.quota = ::std::option::Option::None;
    }

    pub fn has_quota(&self) -> bool {
        self.quota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quota(&mut self, v: u64) {
        self.quota = ::std::option::Option::Some(v);
    }

    // required uint64 spaceConsumed = 5;


    pub fn get_spaceConsumed(&self) -> u64 {
        self.spaceConsumed.unwrap_or(0)
    }
    pub fn clear_spaceConsumed(&mut self) {
        self.spaceConsumed = ::std::option::Option::None;
    }

    pub fn has_spaceConsumed(&self) -> bool {
        self.spaceConsumed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spaceConsumed(&mut self, v: u64) {
        self.spaceConsumed = ::std::option::Option::Some(v);
    }

    // required uint64 spaceQuota = 6;


    pub fn get_spaceQuota(&self) -> u64 {
        self.spaceQuota.unwrap_or(0)
    }
    pub fn clear_spaceQuota(&mut self) {
        self.spaceQuota = ::std::option::Option::None;
    }

    pub fn has_spaceQuota(&self) -> bool {
        self.spaceQuota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spaceQuota(&mut self, v: u64) {
        self.spaceQuota = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.StorageTypeQuotaInfosProto typeQuotaInfos = 7;


    pub fn get_typeQuotaInfos(&self) -> &StorageTypeQuotaInfosProto {
        self.typeQuotaInfos.as_ref().unwrap_or_else(|| <StorageTypeQuotaInfosProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_typeQuotaInfos(&mut self) {
        self.typeQuotaInfos.clear();
    }

    pub fn has_typeQuotaInfos(&self) -> bool {
        self.typeQuotaInfos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typeQuotaInfos(&mut self, v: StorageTypeQuotaInfosProto) {
        self.typeQuotaInfos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_typeQuotaInfos(&mut self) -> &mut StorageTypeQuotaInfosProto {
        if self.typeQuotaInfos.is_none() {
            self.typeQuotaInfos.set_default();
        }
        self.typeQuotaInfos.as_mut().unwrap()
    }

    // Take field
    pub fn take_typeQuotaInfos(&mut self) -> StorageTypeQuotaInfosProto {
        self.typeQuotaInfos.take().unwrap_or_else(|| StorageTypeQuotaInfosProto::new())
    }

    // optional uint64 snapshotLength = 8;


    pub fn get_snapshotLength(&self) -> u64 {
        self.snapshotLength.unwrap_or(0)
    }
    pub fn clear_snapshotLength(&mut self) {
        self.snapshotLength = ::std::option::Option::None;
    }

    pub fn has_snapshotLength(&self) -> bool {
        self.snapshotLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotLength(&mut self, v: u64) {
        self.snapshotLength = ::std::option::Option::Some(v);
    }

    // optional uint64 snapshotFileCount = 9;


    pub fn get_snapshotFileCount(&self) -> u64 {
        self.snapshotFileCount.unwrap_or(0)
    }
    pub fn clear_snapshotFileCount(&mut self) {
        self.snapshotFileCount = ::std::option::Option::None;
    }

    pub fn has_snapshotFileCount(&self) -> bool {
        self.snapshotFileCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotFileCount(&mut self, v: u64) {
        self.snapshotFileCount = ::std::option::Option::Some(v);
    }

    // optional uint64 snapshotDirectoryCount = 10;


    pub fn get_snapshotDirectoryCount(&self) -> u64 {
        self.snapshotDirectoryCount.unwrap_or(0)
    }
    pub fn clear_snapshotDirectoryCount(&mut self) {
        self.snapshotDirectoryCount = ::std::option::Option::None;
    }

    pub fn has_snapshotDirectoryCount(&self) -> bool {
        self.snapshotDirectoryCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotDirectoryCount(&mut self, v: u64) {
        self.snapshotDirectoryCount = ::std::option::Option::Some(v);
    }

    // optional uint64 snapshotSpaceConsumed = 11;


    pub fn get_snapshotSpaceConsumed(&self) -> u64 {
        self.snapshotSpaceConsumed.unwrap_or(0)
    }
    pub fn clear_snapshotSpaceConsumed(&mut self) {
        self.snapshotSpaceConsumed = ::std::option::Option::None;
    }

    pub fn has_snapshotSpaceConsumed(&self) -> bool {
        self.snapshotSpaceConsumed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotSpaceConsumed(&mut self, v: u64) {
        self.snapshotSpaceConsumed = ::std::option::Option::Some(v);
    }

    // optional string erasureCodingPolicy = 12;


    pub fn get_erasureCodingPolicy(&self) -> &str {
        match self.erasureCodingPolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_erasureCodingPolicy(&mut self) {
        self.erasureCodingPolicy.clear();
    }

    pub fn has_erasureCodingPolicy(&self) -> bool {
        self.erasureCodingPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_erasureCodingPolicy(&mut self, v: ::std::string::String) {
        self.erasureCodingPolicy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_erasureCodingPolicy(&mut self) -> &mut ::std::string::String {
        if self.erasureCodingPolicy.is_none() {
            self.erasureCodingPolicy.set_default();
        }
        self.erasureCodingPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_erasureCodingPolicy(&mut self) -> ::std::string::String {
        self.erasureCodingPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ContentSummaryProto {
    fn is_initialized(&self) -> bool {
        if self.length.is_none() {
            return false;
        }
        if self.fileCount.is_none() {
            return false;
        }
        if self.directoryCount.is_none() {
            return false;
        }
        if self.quota.is_none() {
            return false;
        }
        if self.spaceConsumed.is_none() {
            return false;
        }
        if self.spaceQuota.is_none() {
            return false;
        }
        for v in &self.typeQuotaInfos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileCount = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.directoryCount = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quota = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.spaceConsumed = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.spaceQuota = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.typeQuotaInfos)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.snapshotLength = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.snapshotFileCount = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.snapshotDirectoryCount = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.snapshotSpaceConsumed = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.erasureCodingPolicy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fileCount {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.directoryCount {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quota {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.spaceConsumed {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.spaceQuota {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.typeQuotaInfos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.snapshotLength {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.snapshotFileCount {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.snapshotDirectoryCount {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.snapshotSpaceConsumed {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.erasureCodingPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.length {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.fileCount {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.directoryCount {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.quota {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.spaceConsumed {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.spaceQuota {
            os.write_uint64(6, v)?;
        }
        if let Some(ref v) = self.typeQuotaInfos.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.snapshotLength {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.snapshotFileCount {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.snapshotDirectoryCount {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.snapshotSpaceConsumed {
            os.write_uint64(11, v)?;
        }
        if let Some(ref v) = self.erasureCodingPolicy.as_ref() {
            os.write_string(12, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContentSummaryProto {
        ContentSummaryProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "length",
                |m: &ContentSummaryProto| { &m.length },
                |m: &mut ContentSummaryProto| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fileCount",
                |m: &ContentSummaryProto| { &m.fileCount },
                |m: &mut ContentSummaryProto| { &mut m.fileCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "directoryCount",
                |m: &ContentSummaryProto| { &m.directoryCount },
                |m: &mut ContentSummaryProto| { &mut m.directoryCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "quota",
                |m: &ContentSummaryProto| { &m.quota },
                |m: &mut ContentSummaryProto| { &mut m.quota },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "spaceConsumed",
                |m: &ContentSummaryProto| { &m.spaceConsumed },
                |m: &mut ContentSummaryProto| { &mut m.spaceConsumed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "spaceQuota",
                |m: &ContentSummaryProto| { &m.spaceQuota },
                |m: &mut ContentSummaryProto| { &mut m.spaceQuota },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageTypeQuotaInfosProto>>(
                "typeQuotaInfos",
                |m: &ContentSummaryProto| { &m.typeQuotaInfos },
                |m: &mut ContentSummaryProto| { &mut m.typeQuotaInfos },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "snapshotLength",
                |m: &ContentSummaryProto| { &m.snapshotLength },
                |m: &mut ContentSummaryProto| { &mut m.snapshotLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "snapshotFileCount",
                |m: &ContentSummaryProto| { &m.snapshotFileCount },
                |m: &mut ContentSummaryProto| { &mut m.snapshotFileCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "snapshotDirectoryCount",
                |m: &ContentSummaryProto| { &m.snapshotDirectoryCount },
                |m: &mut ContentSummaryProto| { &mut m.snapshotDirectoryCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "snapshotSpaceConsumed",
                |m: &ContentSummaryProto| { &m.snapshotSpaceConsumed },
                |m: &mut ContentSummaryProto| { &mut m.snapshotSpaceConsumed },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "erasureCodingPolicy",
                |m: &ContentSummaryProto| { &m.erasureCodingPolicy },
                |m: &mut ContentSummaryProto| { &mut m.erasureCodingPolicy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContentSummaryProto>(
                "ContentSummaryProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContentSummaryProto {
        static instance: ::protobuf::rt::LazyV2<ContentSummaryProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContentSummaryProto::new)
    }
}

impl ::protobuf::Clear for ContentSummaryProto {
    fn clear(&mut self) {
        self.length = ::std::option::Option::None;
        self.fileCount = ::std::option::Option::None;
        self.directoryCount = ::std::option::Option::None;
        self.quota = ::std::option::Option::None;
        self.spaceConsumed = ::std::option::Option::None;
        self.spaceQuota = ::std::option::Option::None;
        self.typeQuotaInfos.clear();
        self.snapshotLength = ::std::option::Option::None;
        self.snapshotFileCount = ::std::option::Option::None;
        self.snapshotDirectoryCount = ::std::option::Option::None;
        self.snapshotSpaceConsumed = ::std::option::Option::None;
        self.erasureCodingPolicy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContentSummaryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentSummaryProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QuotaUsageProto {
    // message fields
    fileAndDirectoryCount: ::std::option::Option<u64>,
    quota: ::std::option::Option<u64>,
    spaceConsumed: ::std::option::Option<u64>,
    spaceQuota: ::std::option::Option<u64>,
    pub typeQuotaInfos: ::protobuf::SingularPtrField<StorageTypeQuotaInfosProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuotaUsageProto {
    fn default() -> &'a QuotaUsageProto {
        <QuotaUsageProto as ::protobuf::Message>::default_instance()
    }
}

impl QuotaUsageProto {
    pub fn new() -> QuotaUsageProto {
        ::std::default::Default::default()
    }

    // required uint64 fileAndDirectoryCount = 1;


    pub fn get_fileAndDirectoryCount(&self) -> u64 {
        self.fileAndDirectoryCount.unwrap_or(0)
    }
    pub fn clear_fileAndDirectoryCount(&mut self) {
        self.fileAndDirectoryCount = ::std::option::Option::None;
    }

    pub fn has_fileAndDirectoryCount(&self) -> bool {
        self.fileAndDirectoryCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileAndDirectoryCount(&mut self, v: u64) {
        self.fileAndDirectoryCount = ::std::option::Option::Some(v);
    }

    // required uint64 quota = 2;


    pub fn get_quota(&self) -> u64 {
        self.quota.unwrap_or(0)
    }
    pub fn clear_quota(&mut self) {
        self.quota = ::std::option::Option::None;
    }

    pub fn has_quota(&self) -> bool {
        self.quota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quota(&mut self, v: u64) {
        self.quota = ::std::option::Option::Some(v);
    }

    // required uint64 spaceConsumed = 3;


    pub fn get_spaceConsumed(&self) -> u64 {
        self.spaceConsumed.unwrap_or(0)
    }
    pub fn clear_spaceConsumed(&mut self) {
        self.spaceConsumed = ::std::option::Option::None;
    }

    pub fn has_spaceConsumed(&self) -> bool {
        self.spaceConsumed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spaceConsumed(&mut self, v: u64) {
        self.spaceConsumed = ::std::option::Option::Some(v);
    }

    // required uint64 spaceQuota = 4;


    pub fn get_spaceQuota(&self) -> u64 {
        self.spaceQuota.unwrap_or(0)
    }
    pub fn clear_spaceQuota(&mut self) {
        self.spaceQuota = ::std::option::Option::None;
    }

    pub fn has_spaceQuota(&self) -> bool {
        self.spaceQuota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spaceQuota(&mut self, v: u64) {
        self.spaceQuota = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.StorageTypeQuotaInfosProto typeQuotaInfos = 5;


    pub fn get_typeQuotaInfos(&self) -> &StorageTypeQuotaInfosProto {
        self.typeQuotaInfos.as_ref().unwrap_or_else(|| <StorageTypeQuotaInfosProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_typeQuotaInfos(&mut self) {
        self.typeQuotaInfos.clear();
    }

    pub fn has_typeQuotaInfos(&self) -> bool {
        self.typeQuotaInfos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typeQuotaInfos(&mut self, v: StorageTypeQuotaInfosProto) {
        self.typeQuotaInfos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_typeQuotaInfos(&mut self) -> &mut StorageTypeQuotaInfosProto {
        if self.typeQuotaInfos.is_none() {
            self.typeQuotaInfos.set_default();
        }
        self.typeQuotaInfos.as_mut().unwrap()
    }

    // Take field
    pub fn take_typeQuotaInfos(&mut self) -> StorageTypeQuotaInfosProto {
        self.typeQuotaInfos.take().unwrap_or_else(|| StorageTypeQuotaInfosProto::new())
    }
}

impl ::protobuf::Message for QuotaUsageProto {
    fn is_initialized(&self) -> bool {
        if self.fileAndDirectoryCount.is_none() {
            return false;
        }
        if self.quota.is_none() {
            return false;
        }
        if self.spaceConsumed.is_none() {
            return false;
        }
        if self.spaceQuota.is_none() {
            return false;
        }
        for v in &self.typeQuotaInfos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileAndDirectoryCount = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quota = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.spaceConsumed = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.spaceQuota = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.typeQuotaInfos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fileAndDirectoryCount {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quota {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.spaceConsumed {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.spaceQuota {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.typeQuotaInfos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fileAndDirectoryCount {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.quota {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.spaceConsumed {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.spaceQuota {
            os.write_uint64(4, v)?;
        }
        if let Some(ref v) = self.typeQuotaInfos.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuotaUsageProto {
        QuotaUsageProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fileAndDirectoryCount",
                |m: &QuotaUsageProto| { &m.fileAndDirectoryCount },
                |m: &mut QuotaUsageProto| { &mut m.fileAndDirectoryCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "quota",
                |m: &QuotaUsageProto| { &m.quota },
                |m: &mut QuotaUsageProto| { &mut m.quota },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "spaceConsumed",
                |m: &QuotaUsageProto| { &m.spaceConsumed },
                |m: &mut QuotaUsageProto| { &mut m.spaceConsumed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "spaceQuota",
                |m: &QuotaUsageProto| { &m.spaceQuota },
                |m: &mut QuotaUsageProto| { &mut m.spaceQuota },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageTypeQuotaInfosProto>>(
                "typeQuotaInfos",
                |m: &QuotaUsageProto| { &m.typeQuotaInfos },
                |m: &mut QuotaUsageProto| { &mut m.typeQuotaInfos },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QuotaUsageProto>(
                "QuotaUsageProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QuotaUsageProto {
        static instance: ::protobuf::rt::LazyV2<QuotaUsageProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuotaUsageProto::new)
    }
}

impl ::protobuf::Clear for QuotaUsageProto {
    fn clear(&mut self) {
        self.fileAndDirectoryCount = ::std::option::Option::None;
        self.quota = ::std::option::Option::None;
        self.spaceConsumed = ::std::option::Option::None;
        self.spaceQuota = ::std::option::Option::None;
        self.typeQuotaInfos.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuotaUsageProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuotaUsageProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageTypeQuotaInfosProto {
    // message fields
    pub typeQuotaInfo: ::protobuf::RepeatedField<StorageTypeQuotaInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorageTypeQuotaInfosProto {
    fn default() -> &'a StorageTypeQuotaInfosProto {
        <StorageTypeQuotaInfosProto as ::protobuf::Message>::default_instance()
    }
}

impl StorageTypeQuotaInfosProto {
    pub fn new() -> StorageTypeQuotaInfosProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.StorageTypeQuotaInfoProto typeQuotaInfo = 1;


    pub fn get_typeQuotaInfo(&self) -> &[StorageTypeQuotaInfoProto] {
        &self.typeQuotaInfo
    }
    pub fn clear_typeQuotaInfo(&mut self) {
        self.typeQuotaInfo.clear();
    }

    // Param is passed by value, moved
    pub fn set_typeQuotaInfo(&mut self, v: ::protobuf::RepeatedField<StorageTypeQuotaInfoProto>) {
        self.typeQuotaInfo = v;
    }

    // Mutable pointer to the field.
    pub fn mut_typeQuotaInfo(&mut self) -> &mut ::protobuf::RepeatedField<StorageTypeQuotaInfoProto> {
        &mut self.typeQuotaInfo
    }

    // Take field
    pub fn take_typeQuotaInfo(&mut self) -> ::protobuf::RepeatedField<StorageTypeQuotaInfoProto> {
        ::std::mem::replace(&mut self.typeQuotaInfo, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StorageTypeQuotaInfosProto {
    fn is_initialized(&self) -> bool {
        for v in &self.typeQuotaInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.typeQuotaInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.typeQuotaInfo {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.typeQuotaInfo {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageTypeQuotaInfosProto {
        StorageTypeQuotaInfosProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageTypeQuotaInfoProto>>(
                "typeQuotaInfo",
                |m: &StorageTypeQuotaInfosProto| { &m.typeQuotaInfo },
                |m: &mut StorageTypeQuotaInfosProto| { &mut m.typeQuotaInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StorageTypeQuotaInfosProto>(
                "StorageTypeQuotaInfosProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StorageTypeQuotaInfosProto {
        static instance: ::protobuf::rt::LazyV2<StorageTypeQuotaInfosProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StorageTypeQuotaInfosProto::new)
    }
}

impl ::protobuf::Clear for StorageTypeQuotaInfosProto {
    fn clear(&mut self) {
        self.typeQuotaInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageTypeQuotaInfosProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageTypeQuotaInfosProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageTypeQuotaInfoProto {
    // message fields
    field_type: ::std::option::Option<StorageTypeProto>,
    quota: ::std::option::Option<u64>,
    consumed: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorageTypeQuotaInfoProto {
    fn default() -> &'a StorageTypeQuotaInfoProto {
        <StorageTypeQuotaInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl StorageTypeQuotaInfoProto {
    pub fn new() -> StorageTypeQuotaInfoProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.StorageTypeProto type = 1;


    pub fn get_field_type(&self) -> StorageTypeProto {
        self.field_type.unwrap_or(StorageTypeProto::DISK)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: StorageTypeProto) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // required uint64 quota = 2;


    pub fn get_quota(&self) -> u64 {
        self.quota.unwrap_or(0)
    }
    pub fn clear_quota(&mut self) {
        self.quota = ::std::option::Option::None;
    }

    pub fn has_quota(&self) -> bool {
        self.quota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quota(&mut self, v: u64) {
        self.quota = ::std::option::Option::Some(v);
    }

    // required uint64 consumed = 3;


    pub fn get_consumed(&self) -> u64 {
        self.consumed.unwrap_or(0)
    }
    pub fn clear_consumed(&mut self) {
        self.consumed = ::std::option::Option::None;
    }

    pub fn has_consumed(&self) -> bool {
        self.consumed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumed(&mut self, v: u64) {
        self.consumed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StorageTypeQuotaInfoProto {
    fn is_initialized(&self) -> bool {
        if self.quota.is_none() {
            return false;
        }
        if self.consumed.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quota = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.quota {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.consumed {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.quota {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.consumed {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageTypeQuotaInfoProto {
        StorageTypeQuotaInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StorageTypeProto>>(
                "type",
                |m: &StorageTypeQuotaInfoProto| { &m.field_type },
                |m: &mut StorageTypeQuotaInfoProto| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "quota",
                |m: &StorageTypeQuotaInfoProto| { &m.quota },
                |m: &mut StorageTypeQuotaInfoProto| { &mut m.quota },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "consumed",
                |m: &StorageTypeQuotaInfoProto| { &m.consumed },
                |m: &mut StorageTypeQuotaInfoProto| { &mut m.consumed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StorageTypeQuotaInfoProto>(
                "StorageTypeQuotaInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StorageTypeQuotaInfoProto {
        static instance: ::protobuf::rt::LazyV2<StorageTypeQuotaInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StorageTypeQuotaInfoProto::new)
    }
}

impl ::protobuf::Clear for StorageTypeQuotaInfoProto {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.quota = ::std::option::Option::None;
        self.consumed = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageTypeQuotaInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageTypeQuotaInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CorruptFileBlocksProto {
    // message fields
    pub files: ::protobuf::RepeatedField<::std::string::String>,
    cookie: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CorruptFileBlocksProto {
    fn default() -> &'a CorruptFileBlocksProto {
        <CorruptFileBlocksProto as ::protobuf::Message>::default_instance()
    }
}

impl CorruptFileBlocksProto {
    pub fn new() -> CorruptFileBlocksProto {
        ::std::default::Default::default()
    }

    // repeated string files = 1;


    pub fn get_files(&self) -> &[::std::string::String] {
        &self.files
    }
    pub fn clear_files(&mut self) {
        self.files.clear();
    }

    // Param is passed by value, moved
    pub fn set_files(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_files(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.files
    }

    // Take field
    pub fn take_files(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.files, ::protobuf::RepeatedField::new())
    }

    // required string cookie = 2;


    pub fn get_cookie(&self) -> &str {
        match self.cookie.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_cookie(&mut self) {
        self.cookie.clear();
    }

    pub fn has_cookie(&self) -> bool {
        self.cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: ::std::string::String) {
        self.cookie = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cookie(&mut self) -> &mut ::std::string::String {
        if self.cookie.is_none() {
            self.cookie.set_default();
        }
        self.cookie.as_mut().unwrap()
    }

    // Take field
    pub fn take_cookie(&mut self) -> ::std::string::String {
        self.cookie.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CorruptFileBlocksProto {
    fn is_initialized(&self) -> bool {
        if self.cookie.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.files)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.files {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.cookie.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.files {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.cookie.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CorruptFileBlocksProto {
        CorruptFileBlocksProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "files",
                |m: &CorruptFileBlocksProto| { &m.files },
                |m: &mut CorruptFileBlocksProto| { &mut m.files },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cookie",
                |m: &CorruptFileBlocksProto| { &m.cookie },
                |m: &mut CorruptFileBlocksProto| { &mut m.cookie },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CorruptFileBlocksProto>(
                "CorruptFileBlocksProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CorruptFileBlocksProto {
        static instance: ::protobuf::rt::LazyV2<CorruptFileBlocksProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CorruptFileBlocksProto::new)
    }
}

impl ::protobuf::Clear for CorruptFileBlocksProto {
    fn clear(&mut self) {
        self.files.clear();
        self.cookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CorruptFileBlocksProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CorruptFileBlocksProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageTypesProto {
    // message fields
    pub storageTypes: ::std::vec::Vec<StorageTypeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorageTypesProto {
    fn default() -> &'a StorageTypesProto {
        <StorageTypesProto as ::protobuf::Message>::default_instance()
    }
}

impl StorageTypesProto {
    pub fn new() -> StorageTypesProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.StorageTypeProto storageTypes = 1;


    pub fn get_storageTypes(&self) -> &[StorageTypeProto] {
        &self.storageTypes
    }
    pub fn clear_storageTypes(&mut self) {
        self.storageTypes.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageTypes(&mut self, v: ::std::vec::Vec<StorageTypeProto>) {
        self.storageTypes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageTypes(&mut self) -> &mut ::std::vec::Vec<StorageTypeProto> {
        &mut self.storageTypes
    }

    // Take field
    pub fn take_storageTypes(&mut self) -> ::std::vec::Vec<StorageTypeProto> {
        ::std::mem::replace(&mut self.storageTypes, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for StorageTypesProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.storageTypes, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.storageTypes {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.storageTypes {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageTypesProto {
        StorageTypesProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StorageTypeProto>>(
                "storageTypes",
                |m: &StorageTypesProto| { &m.storageTypes },
                |m: &mut StorageTypesProto| { &mut m.storageTypes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StorageTypesProto>(
                "StorageTypesProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StorageTypesProto {
        static instance: ::protobuf::rt::LazyV2<StorageTypesProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StorageTypesProto::new)
    }
}

impl ::protobuf::Clear for StorageTypesProto {
    fn clear(&mut self) {
        self.storageTypes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageTypesProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageTypesProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockStoragePolicyProto {
    // message fields
    policyId: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    pub creationPolicy: ::protobuf::SingularPtrField<StorageTypesProto>,
    pub creationFallbackPolicy: ::protobuf::SingularPtrField<StorageTypesProto>,
    pub replicationFallbackPolicy: ::protobuf::SingularPtrField<StorageTypesProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockStoragePolicyProto {
    fn default() -> &'a BlockStoragePolicyProto {
        <BlockStoragePolicyProto as ::protobuf::Message>::default_instance()
    }
}

impl BlockStoragePolicyProto {
    pub fn new() -> BlockStoragePolicyProto {
        ::std::default::Default::default()
    }

    // required uint32 policyId = 1;


    pub fn get_policyId(&self) -> u32 {
        self.policyId.unwrap_or(0)
    }
    pub fn clear_policyId(&mut self) {
        self.policyId = ::std::option::Option::None;
    }

    pub fn has_policyId(&self) -> bool {
        self.policyId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_policyId(&mut self, v: u32) {
        self.policyId = ::std::option::Option::Some(v);
    }

    // required string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.StorageTypesProto creationPolicy = 3;


    pub fn get_creationPolicy(&self) -> &StorageTypesProto {
        self.creationPolicy.as_ref().unwrap_or_else(|| <StorageTypesProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_creationPolicy(&mut self) {
        self.creationPolicy.clear();
    }

    pub fn has_creationPolicy(&self) -> bool {
        self.creationPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creationPolicy(&mut self, v: StorageTypesProto) {
        self.creationPolicy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creationPolicy(&mut self) -> &mut StorageTypesProto {
        if self.creationPolicy.is_none() {
            self.creationPolicy.set_default();
        }
        self.creationPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_creationPolicy(&mut self) -> StorageTypesProto {
        self.creationPolicy.take().unwrap_or_else(|| StorageTypesProto::new())
    }

    // optional .hadoop.hdfs.StorageTypesProto creationFallbackPolicy = 4;


    pub fn get_creationFallbackPolicy(&self) -> &StorageTypesProto {
        self.creationFallbackPolicy.as_ref().unwrap_or_else(|| <StorageTypesProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_creationFallbackPolicy(&mut self) {
        self.creationFallbackPolicy.clear();
    }

    pub fn has_creationFallbackPolicy(&self) -> bool {
        self.creationFallbackPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creationFallbackPolicy(&mut self, v: StorageTypesProto) {
        self.creationFallbackPolicy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creationFallbackPolicy(&mut self) -> &mut StorageTypesProto {
        if self.creationFallbackPolicy.is_none() {
            self.creationFallbackPolicy.set_default();
        }
        self.creationFallbackPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_creationFallbackPolicy(&mut self) -> StorageTypesProto {
        self.creationFallbackPolicy.take().unwrap_or_else(|| StorageTypesProto::new())
    }

    // optional .hadoop.hdfs.StorageTypesProto replicationFallbackPolicy = 5;


    pub fn get_replicationFallbackPolicy(&self) -> &StorageTypesProto {
        self.replicationFallbackPolicy.as_ref().unwrap_or_else(|| <StorageTypesProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_replicationFallbackPolicy(&mut self) {
        self.replicationFallbackPolicy.clear();
    }

    pub fn has_replicationFallbackPolicy(&self) -> bool {
        self.replicationFallbackPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicationFallbackPolicy(&mut self, v: StorageTypesProto) {
        self.replicationFallbackPolicy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_replicationFallbackPolicy(&mut self) -> &mut StorageTypesProto {
        if self.replicationFallbackPolicy.is_none() {
            self.replicationFallbackPolicy.set_default();
        }
        self.replicationFallbackPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_replicationFallbackPolicy(&mut self) -> StorageTypesProto {
        self.replicationFallbackPolicy.take().unwrap_or_else(|| StorageTypesProto::new())
    }
}

impl ::protobuf::Message for BlockStoragePolicyProto {
    fn is_initialized(&self) -> bool {
        if self.policyId.is_none() {
            return false;
        }
        if self.name.is_none() {
            return false;
        }
        if self.creationPolicy.is_none() {
            return false;
        }
        for v in &self.creationPolicy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.creationFallbackPolicy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.replicationFallbackPolicy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.policyId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.creationPolicy)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.creationFallbackPolicy)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.replicationFallbackPolicy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.policyId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.creationPolicy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.creationFallbackPolicy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.replicationFallbackPolicy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.policyId {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.creationPolicy.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.creationFallbackPolicy.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.replicationFallbackPolicy.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockStoragePolicyProto {
        BlockStoragePolicyProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "policyId",
                |m: &BlockStoragePolicyProto| { &m.policyId },
                |m: &mut BlockStoragePolicyProto| { &mut m.policyId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &BlockStoragePolicyProto| { &m.name },
                |m: &mut BlockStoragePolicyProto| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageTypesProto>>(
                "creationPolicy",
                |m: &BlockStoragePolicyProto| { &m.creationPolicy },
                |m: &mut BlockStoragePolicyProto| { &mut m.creationPolicy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageTypesProto>>(
                "creationFallbackPolicy",
                |m: &BlockStoragePolicyProto| { &m.creationFallbackPolicy },
                |m: &mut BlockStoragePolicyProto| { &mut m.creationFallbackPolicy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageTypesProto>>(
                "replicationFallbackPolicy",
                |m: &BlockStoragePolicyProto| { &m.replicationFallbackPolicy },
                |m: &mut BlockStoragePolicyProto| { &mut m.replicationFallbackPolicy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockStoragePolicyProto>(
                "BlockStoragePolicyProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockStoragePolicyProto {
        static instance: ::protobuf::rt::LazyV2<BlockStoragePolicyProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockStoragePolicyProto::new)
    }
}

impl ::protobuf::Clear for BlockStoragePolicyProto {
    fn clear(&mut self) {
        self.policyId = ::std::option::Option::None;
        self.name.clear();
        self.creationPolicy.clear();
        self.creationFallbackPolicy.clear();
        self.replicationFallbackPolicy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockStoragePolicyProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockStoragePolicyProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocatedBlockProto {
    // message fields
    pub b: ::protobuf::SingularPtrField<ExtendedBlockProto>,
    offset: ::std::option::Option<u64>,
    pub locs: ::protobuf::RepeatedField<DatanodeInfoProto>,
    corrupt: ::std::option::Option<bool>,
    pub blockToken: ::protobuf::SingularPtrField<super::Security::TokenProto>,
    pub isCached: ::std::vec::Vec<bool>,
    pub storageTypes: ::std::vec::Vec<StorageTypeProto>,
    pub storageIDs: ::protobuf::RepeatedField<::std::string::String>,
    blockIndices: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub blockTokens: ::protobuf::RepeatedField<super::Security::TokenProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LocatedBlockProto {
    fn default() -> &'a LocatedBlockProto {
        <LocatedBlockProto as ::protobuf::Message>::default_instance()
    }
}

impl LocatedBlockProto {
    pub fn new() -> LocatedBlockProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ExtendedBlockProto b = 1;


    pub fn get_b(&self) -> &ExtendedBlockProto {
        self.b.as_ref().unwrap_or_else(|| <ExtendedBlockProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_b(&mut self) {
        self.b.clear();
    }

    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: ExtendedBlockProto) {
        self.b = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_b(&mut self) -> &mut ExtendedBlockProto {
        if self.b.is_none() {
            self.b.set_default();
        }
        self.b.as_mut().unwrap()
    }

    // Take field
    pub fn take_b(&mut self) -> ExtendedBlockProto {
        self.b.take().unwrap_or_else(|| ExtendedBlockProto::new())
    }

    // required uint64 offset = 2;


    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }
    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto locs = 3;


    pub fn get_locs(&self) -> &[DatanodeInfoProto] {
        &self.locs
    }
    pub fn clear_locs(&mut self) {
        self.locs.clear();
    }

    // Param is passed by value, moved
    pub fn set_locs(&mut self, v: ::protobuf::RepeatedField<DatanodeInfoProto>) {
        self.locs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_locs(&mut self) -> &mut ::protobuf::RepeatedField<DatanodeInfoProto> {
        &mut self.locs
    }

    // Take field
    pub fn take_locs(&mut self) -> ::protobuf::RepeatedField<DatanodeInfoProto> {
        ::std::mem::replace(&mut self.locs, ::protobuf::RepeatedField::new())
    }

    // required bool corrupt = 4;


    pub fn get_corrupt(&self) -> bool {
        self.corrupt.unwrap_or(false)
    }
    pub fn clear_corrupt(&mut self) {
        self.corrupt = ::std::option::Option::None;
    }

    pub fn has_corrupt(&self) -> bool {
        self.corrupt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_corrupt(&mut self, v: bool) {
        self.corrupt = ::std::option::Option::Some(v);
    }

    // required .hadoop.common.TokenProto blockToken = 5;


    pub fn get_blockToken(&self) -> &super::Security::TokenProto {
        self.blockToken.as_ref().unwrap_or_else(|| <super::Security::TokenProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blockToken(&mut self) {
        self.blockToken.clear();
    }

    pub fn has_blockToken(&self) -> bool {
        self.blockToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockToken(&mut self, v: super::Security::TokenProto) {
        self.blockToken = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockToken(&mut self) -> &mut super::Security::TokenProto {
        if self.blockToken.is_none() {
            self.blockToken.set_default();
        }
        self.blockToken.as_mut().unwrap()
    }

    // Take field
    pub fn take_blockToken(&mut self) -> super::Security::TokenProto {
        self.blockToken.take().unwrap_or_else(|| super::Security::TokenProto::new())
    }

    // repeated bool isCached = 6;


    pub fn get_isCached(&self) -> &[bool] {
        &self.isCached
    }
    pub fn clear_isCached(&mut self) {
        self.isCached.clear();
    }

    // Param is passed by value, moved
    pub fn set_isCached(&mut self, v: ::std::vec::Vec<bool>) {
        self.isCached = v;
    }

    // Mutable pointer to the field.
    pub fn mut_isCached(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.isCached
    }

    // Take field
    pub fn take_isCached(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.isCached, ::std::vec::Vec::new())
    }

    // repeated .hadoop.hdfs.StorageTypeProto storageTypes = 7;


    pub fn get_storageTypes(&self) -> &[StorageTypeProto] {
        &self.storageTypes
    }
    pub fn clear_storageTypes(&mut self) {
        self.storageTypes.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageTypes(&mut self, v: ::std::vec::Vec<StorageTypeProto>) {
        self.storageTypes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageTypes(&mut self) -> &mut ::std::vec::Vec<StorageTypeProto> {
        &mut self.storageTypes
    }

    // Take field
    pub fn take_storageTypes(&mut self) -> ::std::vec::Vec<StorageTypeProto> {
        ::std::mem::replace(&mut self.storageTypes, ::std::vec::Vec::new())
    }

    // repeated string storageIDs = 8;


    pub fn get_storageIDs(&self) -> &[::std::string::String] {
        &self.storageIDs
    }
    pub fn clear_storageIDs(&mut self) {
        self.storageIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageIDs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.storageIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageIDs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.storageIDs
    }

    // Take field
    pub fn take_storageIDs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.storageIDs, ::protobuf::RepeatedField::new())
    }

    // optional bytes blockIndices = 9;


    pub fn get_blockIndices(&self) -> &[u8] {
        match self.blockIndices.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_blockIndices(&mut self) {
        self.blockIndices.clear();
    }

    pub fn has_blockIndices(&self) -> bool {
        self.blockIndices.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockIndices(&mut self, v: ::std::vec::Vec<u8>) {
        self.blockIndices = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockIndices(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.blockIndices.is_none() {
            self.blockIndices.set_default();
        }
        self.blockIndices.as_mut().unwrap()
    }

    // Take field
    pub fn take_blockIndices(&mut self) -> ::std::vec::Vec<u8> {
        self.blockIndices.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated .hadoop.common.TokenProto blockTokens = 10;


    pub fn get_blockTokens(&self) -> &[super::Security::TokenProto] {
        &self.blockTokens
    }
    pub fn clear_blockTokens(&mut self) {
        self.blockTokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockTokens(&mut self, v: ::protobuf::RepeatedField<super::Security::TokenProto>) {
        self.blockTokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blockTokens(&mut self) -> &mut ::protobuf::RepeatedField<super::Security::TokenProto> {
        &mut self.blockTokens
    }

    // Take field
    pub fn take_blockTokens(&mut self) -> ::protobuf::RepeatedField<super::Security::TokenProto> {
        ::std::mem::replace(&mut self.blockTokens, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LocatedBlockProto {
    fn is_initialized(&self) -> bool {
        if self.b.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        if self.corrupt.is_none() {
            return false;
        }
        if self.blockToken.is_none() {
            return false;
        }
        for v in &self.b {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.locs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blockToken {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blockTokens {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.b)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.locs)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.corrupt = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blockToken)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.isCached)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.storageTypes, 7, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.storageIDs)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.blockIndices)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blockTokens)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.b.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.locs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.corrupt {
            my_size += 2;
        }
        if let Some(ref v) = self.blockToken.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.isCached.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size((self.isCached.len() * 1) as u32) + (self.isCached.len() * 1) as u32;
        }
        for value in &self.storageTypes {
            my_size += ::protobuf::rt::enum_size(7, *value);
        };
        for value in &self.storageIDs {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if let Some(ref v) = self.blockIndices.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        for value in &self.blockTokens {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.b.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(2, v)?;
        }
        for v in &self.locs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.corrupt {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.blockToken.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.isCached.is_empty() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.isCached.len() * 1) as u32)?;
            for v in &self.isCached {
                os.write_bool_no_tag(*v)?;
            };
        }
        for v in &self.storageTypes {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.storageIDs {
            os.write_string(8, &v)?;
        };
        if let Some(ref v) = self.blockIndices.as_ref() {
            os.write_bytes(9, &v)?;
        }
        for v in &self.blockTokens {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocatedBlockProto {
        LocatedBlockProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExtendedBlockProto>>(
                "b",
                |m: &LocatedBlockProto| { &m.b },
                |m: &mut LocatedBlockProto| { &mut m.b },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "offset",
                |m: &LocatedBlockProto| { &m.offset },
                |m: &mut LocatedBlockProto| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeInfoProto>>(
                "locs",
                |m: &LocatedBlockProto| { &m.locs },
                |m: &mut LocatedBlockProto| { &mut m.locs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "corrupt",
                |m: &LocatedBlockProto| { &m.corrupt },
                |m: &mut LocatedBlockProto| { &mut m.corrupt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Security::TokenProto>>(
                "blockToken",
                |m: &LocatedBlockProto| { &m.blockToken },
                |m: &mut LocatedBlockProto| { &mut m.blockToken },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isCached",
                |m: &LocatedBlockProto| { &m.isCached },
                |m: &mut LocatedBlockProto| { &mut m.isCached },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StorageTypeProto>>(
                "storageTypes",
                |m: &LocatedBlockProto| { &m.storageTypes },
                |m: &mut LocatedBlockProto| { &mut m.storageTypes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storageIDs",
                |m: &LocatedBlockProto| { &m.storageIDs },
                |m: &mut LocatedBlockProto| { &mut m.storageIDs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "blockIndices",
                |m: &LocatedBlockProto| { &m.blockIndices },
                |m: &mut LocatedBlockProto| { &mut m.blockIndices },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Security::TokenProto>>(
                "blockTokens",
                |m: &LocatedBlockProto| { &m.blockTokens },
                |m: &mut LocatedBlockProto| { &mut m.blockTokens },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LocatedBlockProto>(
                "LocatedBlockProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LocatedBlockProto {
        static instance: ::protobuf::rt::LazyV2<LocatedBlockProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LocatedBlockProto::new)
    }
}

impl ::protobuf::Clear for LocatedBlockProto {
    fn clear(&mut self) {
        self.b.clear();
        self.offset = ::std::option::Option::None;
        self.locs.clear();
        self.corrupt = ::std::option::Option::None;
        self.blockToken.clear();
        self.isCached.clear();
        self.storageTypes.clear();
        self.storageIDs.clear();
        self.blockIndices.clear();
        self.blockTokens.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocatedBlockProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocatedBlockProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchedListingKeyProto {
    // message fields
    checksum: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pathIndex: ::std::option::Option<u32>,
    startAfter: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchedListingKeyProto {
    fn default() -> &'a BatchedListingKeyProto {
        <BatchedListingKeyProto as ::protobuf::Message>::default_instance()
    }
}

impl BatchedListingKeyProto {
    pub fn new() -> BatchedListingKeyProto {
        ::std::default::Default::default()
    }

    // required bytes checksum = 1;


    pub fn get_checksum(&self) -> &[u8] {
        match self.checksum.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_checksum(&mut self) {
        self.checksum.clear();
    }

    pub fn has_checksum(&self) -> bool {
        self.checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checksum(&mut self, v: ::std::vec::Vec<u8>) {
        self.checksum = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_checksum(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.checksum.is_none() {
            self.checksum.set_default();
        }
        self.checksum.as_mut().unwrap()
    }

    // Take field
    pub fn take_checksum(&mut self) -> ::std::vec::Vec<u8> {
        self.checksum.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint32 pathIndex = 2;


    pub fn get_pathIndex(&self) -> u32 {
        self.pathIndex.unwrap_or(0)
    }
    pub fn clear_pathIndex(&mut self) {
        self.pathIndex = ::std::option::Option::None;
    }

    pub fn has_pathIndex(&self) -> bool {
        self.pathIndex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pathIndex(&mut self, v: u32) {
        self.pathIndex = ::std::option::Option::Some(v);
    }

    // required bytes startAfter = 3;


    pub fn get_startAfter(&self) -> &[u8] {
        match self.startAfter.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_startAfter(&mut self) {
        self.startAfter.clear();
    }

    pub fn has_startAfter(&self) -> bool {
        self.startAfter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startAfter(&mut self, v: ::std::vec::Vec<u8>) {
        self.startAfter = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startAfter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.startAfter.is_none() {
            self.startAfter.set_default();
        }
        self.startAfter.as_mut().unwrap()
    }

    // Take field
    pub fn take_startAfter(&mut self) -> ::std::vec::Vec<u8> {
        self.startAfter.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BatchedListingKeyProto {
    fn is_initialized(&self) -> bool {
        if self.checksum.is_none() {
            return false;
        }
        if self.pathIndex.is_none() {
            return false;
        }
        if self.startAfter.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.checksum)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pathIndex = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.startAfter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.checksum.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.pathIndex {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.startAfter.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.checksum.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.pathIndex {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.startAfter.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchedListingKeyProto {
        BatchedListingKeyProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "checksum",
                |m: &BatchedListingKeyProto| { &m.checksum },
                |m: &mut BatchedListingKeyProto| { &mut m.checksum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "pathIndex",
                |m: &BatchedListingKeyProto| { &m.pathIndex },
                |m: &mut BatchedListingKeyProto| { &mut m.pathIndex },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "startAfter",
                |m: &BatchedListingKeyProto| { &m.startAfter },
                |m: &mut BatchedListingKeyProto| { &mut m.startAfter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchedListingKeyProto>(
                "BatchedListingKeyProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchedListingKeyProto {
        static instance: ::protobuf::rt::LazyV2<BatchedListingKeyProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchedListingKeyProto::new)
    }
}

impl ::protobuf::Clear for BatchedListingKeyProto {
    fn clear(&mut self) {
        self.checksum.clear();
        self.pathIndex = ::std::option::Option::None;
        self.startAfter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchedListingKeyProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchedListingKeyProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DataEncryptionKeyProto {
    // message fields
    keyId: ::std::option::Option<u32>,
    blockPoolId: ::protobuf::SingularField<::std::string::String>,
    nonce: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    encryptionKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    expiryDate: ::std::option::Option<u64>,
    encryptionAlgorithm: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataEncryptionKeyProto {
    fn default() -> &'a DataEncryptionKeyProto {
        <DataEncryptionKeyProto as ::protobuf::Message>::default_instance()
    }
}

impl DataEncryptionKeyProto {
    pub fn new() -> DataEncryptionKeyProto {
        ::std::default::Default::default()
    }

    // required uint32 keyId = 1;


    pub fn get_keyId(&self) -> u32 {
        self.keyId.unwrap_or(0)
    }
    pub fn clear_keyId(&mut self) {
        self.keyId = ::std::option::Option::None;
    }

    pub fn has_keyId(&self) -> bool {
        self.keyId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyId(&mut self, v: u32) {
        self.keyId = ::std::option::Option::Some(v);
    }

    // required string blockPoolId = 2;


    pub fn get_blockPoolId(&self) -> &str {
        match self.blockPoolId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_blockPoolId(&mut self) {
        self.blockPoolId.clear();
    }

    pub fn has_blockPoolId(&self) -> bool {
        self.blockPoolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockPoolId(&mut self, v: ::std::string::String) {
        self.blockPoolId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockPoolId(&mut self) -> &mut ::std::string::String {
        if self.blockPoolId.is_none() {
            self.blockPoolId.set_default();
        }
        self.blockPoolId.as_mut().unwrap()
    }

    // Take field
    pub fn take_blockPoolId(&mut self) -> ::std::string::String {
        self.blockPoolId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes nonce = 3;


    pub fn get_nonce(&self) -> &[u8] {
        match self.nonce.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_nonce(&mut self) {
        self.nonce.clear();
    }

    pub fn has_nonce(&self) -> bool {
        self.nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.nonce = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.nonce.is_none() {
            self.nonce.set_default();
        }
        self.nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::vec::Vec<u8> {
        self.nonce.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes encryptionKey = 4;


    pub fn get_encryptionKey(&self) -> &[u8] {
        match self.encryptionKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_encryptionKey(&mut self) {
        self.encryptionKey.clear();
    }

    pub fn has_encryptionKey(&self) -> bool {
        self.encryptionKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryptionKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.encryptionKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryptionKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encryptionKey.is_none() {
            self.encryptionKey.set_default();
        }
        self.encryptionKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryptionKey(&mut self) -> ::std::vec::Vec<u8> {
        self.encryptionKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint64 expiryDate = 5;


    pub fn get_expiryDate(&self) -> u64 {
        self.expiryDate.unwrap_or(0)
    }
    pub fn clear_expiryDate(&mut self) {
        self.expiryDate = ::std::option::Option::None;
    }

    pub fn has_expiryDate(&self) -> bool {
        self.expiryDate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiryDate(&mut self, v: u64) {
        self.expiryDate = ::std::option::Option::Some(v);
    }

    // optional string encryptionAlgorithm = 6;


    pub fn get_encryptionAlgorithm(&self) -> &str {
        match self.encryptionAlgorithm.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_encryptionAlgorithm(&mut self) {
        self.encryptionAlgorithm.clear();
    }

    pub fn has_encryptionAlgorithm(&self) -> bool {
        self.encryptionAlgorithm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryptionAlgorithm(&mut self, v: ::std::string::String) {
        self.encryptionAlgorithm = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryptionAlgorithm(&mut self) -> &mut ::std::string::String {
        if self.encryptionAlgorithm.is_none() {
            self.encryptionAlgorithm.set_default();
        }
        self.encryptionAlgorithm.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryptionAlgorithm(&mut self) -> ::std::string::String {
        self.encryptionAlgorithm.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DataEncryptionKeyProto {
    fn is_initialized(&self) -> bool {
        if self.keyId.is_none() {
            return false;
        }
        if self.blockPoolId.is_none() {
            return false;
        }
        if self.nonce.is_none() {
            return false;
        }
        if self.encryptionKey.is_none() {
            return false;
        }
        if self.expiryDate.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.keyId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.blockPoolId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.nonce)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.encryptionKey)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.expiryDate = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.encryptionAlgorithm)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.keyId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.blockPoolId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.nonce.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.encryptionKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.expiryDate {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.encryptionAlgorithm.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.keyId {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.blockPoolId.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.nonce.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.encryptionKey.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.expiryDate {
            os.write_uint64(5, v)?;
        }
        if let Some(ref v) = self.encryptionAlgorithm.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataEncryptionKeyProto {
        DataEncryptionKeyProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "keyId",
                |m: &DataEncryptionKeyProto| { &m.keyId },
                |m: &mut DataEncryptionKeyProto| { &mut m.keyId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blockPoolId",
                |m: &DataEncryptionKeyProto| { &m.blockPoolId },
                |m: &mut DataEncryptionKeyProto| { &mut m.blockPoolId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "nonce",
                |m: &DataEncryptionKeyProto| { &m.nonce },
                |m: &mut DataEncryptionKeyProto| { &mut m.nonce },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "encryptionKey",
                |m: &DataEncryptionKeyProto| { &m.encryptionKey },
                |m: &mut DataEncryptionKeyProto| { &mut m.encryptionKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "expiryDate",
                |m: &DataEncryptionKeyProto| { &m.expiryDate },
                |m: &mut DataEncryptionKeyProto| { &mut m.expiryDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "encryptionAlgorithm",
                |m: &DataEncryptionKeyProto| { &m.encryptionAlgorithm },
                |m: &mut DataEncryptionKeyProto| { &mut m.encryptionAlgorithm },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DataEncryptionKeyProto>(
                "DataEncryptionKeyProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DataEncryptionKeyProto {
        static instance: ::protobuf::rt::LazyV2<DataEncryptionKeyProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DataEncryptionKeyProto::new)
    }
}

impl ::protobuf::Clear for DataEncryptionKeyProto {
    fn clear(&mut self) {
        self.keyId = ::std::option::Option::None;
        self.blockPoolId.clear();
        self.nonce.clear();
        self.encryptionKey.clear();
        self.expiryDate = ::std::option::Option::None;
        self.encryptionAlgorithm.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataEncryptionKeyProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataEncryptionKeyProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileEncryptionInfoProto {
    // message fields
    suite: ::std::option::Option<CipherSuiteProto>,
    cryptoProtocolVersion: ::std::option::Option<CryptoProtocolVersionProto>,
    key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    iv: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    keyName: ::protobuf::SingularField<::std::string::String>,
    ezKeyVersionName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileEncryptionInfoProto {
    fn default() -> &'a FileEncryptionInfoProto {
        <FileEncryptionInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl FileEncryptionInfoProto {
    pub fn new() -> FileEncryptionInfoProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CipherSuiteProto suite = 1;


    pub fn get_suite(&self) -> CipherSuiteProto {
        self.suite.unwrap_or(CipherSuiteProto::UNKNOWN)
    }
    pub fn clear_suite(&mut self) {
        self.suite = ::std::option::Option::None;
    }

    pub fn has_suite(&self) -> bool {
        self.suite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suite(&mut self, v: CipherSuiteProto) {
        self.suite = ::std::option::Option::Some(v);
    }

    // required .hadoop.hdfs.CryptoProtocolVersionProto cryptoProtocolVersion = 2;


    pub fn get_cryptoProtocolVersion(&self) -> CryptoProtocolVersionProto {
        self.cryptoProtocolVersion.unwrap_or(CryptoProtocolVersionProto::UNKNOWN_PROTOCOL_VERSION)
    }
    pub fn clear_cryptoProtocolVersion(&mut self) {
        self.cryptoProtocolVersion = ::std::option::Option::None;
    }

    pub fn has_cryptoProtocolVersion(&self) -> bool {
        self.cryptoProtocolVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cryptoProtocolVersion(&mut self, v: CryptoProtocolVersionProto) {
        self.cryptoProtocolVersion = ::std::option::Option::Some(v);
    }

    // required bytes key = 3;


    pub fn get_key(&self) -> &[u8] {
        match self.key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes iv = 4;


    pub fn get_iv(&self) -> &[u8] {
        match self.iv.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_iv(&mut self) {
        self.iv.clear();
    }

    pub fn has_iv(&self) -> bool {
        self.iv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iv(&mut self, v: ::std::vec::Vec<u8>) {
        self.iv = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.iv.is_none() {
            self.iv.set_default();
        }
        self.iv.as_mut().unwrap()
    }

    // Take field
    pub fn take_iv(&mut self) -> ::std::vec::Vec<u8> {
        self.iv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required string keyName = 5;


    pub fn get_keyName(&self) -> &str {
        match self.keyName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_keyName(&mut self) {
        self.keyName.clear();
    }

    pub fn has_keyName(&self) -> bool {
        self.keyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyName(&mut self, v: ::std::string::String) {
        self.keyName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyName(&mut self) -> &mut ::std::string::String {
        if self.keyName.is_none() {
            self.keyName.set_default();
        }
        self.keyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyName(&mut self) -> ::std::string::String {
        self.keyName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string ezKeyVersionName = 6;


    pub fn get_ezKeyVersionName(&self) -> &str {
        match self.ezKeyVersionName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ezKeyVersionName(&mut self) {
        self.ezKeyVersionName.clear();
    }

    pub fn has_ezKeyVersionName(&self) -> bool {
        self.ezKeyVersionName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ezKeyVersionName(&mut self, v: ::std::string::String) {
        self.ezKeyVersionName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ezKeyVersionName(&mut self) -> &mut ::std::string::String {
        if self.ezKeyVersionName.is_none() {
            self.ezKeyVersionName.set_default();
        }
        self.ezKeyVersionName.as_mut().unwrap()
    }

    // Take field
    pub fn take_ezKeyVersionName(&mut self) -> ::std::string::String {
        self.ezKeyVersionName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for FileEncryptionInfoProto {
    fn is_initialized(&self) -> bool {
        if self.suite.is_none() {
            return false;
        }
        if self.cryptoProtocolVersion.is_none() {
            return false;
        }
        if self.key.is_none() {
            return false;
        }
        if self.iv.is_none() {
            return false;
        }
        if self.keyName.is_none() {
            return false;
        }
        if self.ezKeyVersionName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.suite, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.cryptoProtocolVersion, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.key)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.iv)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.keyName)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ezKeyVersionName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.suite {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.cryptoProtocolVersion {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.iv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.keyName.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.ezKeyVersionName.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.suite {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.cryptoProtocolVersion {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.iv.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.keyName.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.ezKeyVersionName.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileEncryptionInfoProto {
        FileEncryptionInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CipherSuiteProto>>(
                "suite",
                |m: &FileEncryptionInfoProto| { &m.suite },
                |m: &mut FileEncryptionInfoProto| { &mut m.suite },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CryptoProtocolVersionProto>>(
                "cryptoProtocolVersion",
                |m: &FileEncryptionInfoProto| { &m.cryptoProtocolVersion },
                |m: &mut FileEncryptionInfoProto| { &mut m.cryptoProtocolVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &FileEncryptionInfoProto| { &m.key },
                |m: &mut FileEncryptionInfoProto| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "iv",
                |m: &FileEncryptionInfoProto| { &m.iv },
                |m: &mut FileEncryptionInfoProto| { &mut m.iv },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "keyName",
                |m: &FileEncryptionInfoProto| { &m.keyName },
                |m: &mut FileEncryptionInfoProto| { &mut m.keyName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ezKeyVersionName",
                |m: &FileEncryptionInfoProto| { &m.ezKeyVersionName },
                |m: &mut FileEncryptionInfoProto| { &mut m.ezKeyVersionName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FileEncryptionInfoProto>(
                "FileEncryptionInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FileEncryptionInfoProto {
        static instance: ::protobuf::rt::LazyV2<FileEncryptionInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FileEncryptionInfoProto::new)
    }
}

impl ::protobuf::Clear for FileEncryptionInfoProto {
    fn clear(&mut self) {
        self.suite = ::std::option::Option::None;
        self.cryptoProtocolVersion = ::std::option::Option::None;
        self.key.clear();
        self.iv.clear();
        self.keyName.clear();
        self.ezKeyVersionName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileEncryptionInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileEncryptionInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PerFileEncryptionInfoProto {
    // message fields
    key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    iv: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ezKeyVersionName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PerFileEncryptionInfoProto {
    fn default() -> &'a PerFileEncryptionInfoProto {
        <PerFileEncryptionInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl PerFileEncryptionInfoProto {
    pub fn new() -> PerFileEncryptionInfoProto {
        ::std::default::Default::default()
    }

    // required bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        match self.key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes iv = 2;


    pub fn get_iv(&self) -> &[u8] {
        match self.iv.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_iv(&mut self) {
        self.iv.clear();
    }

    pub fn has_iv(&self) -> bool {
        self.iv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iv(&mut self, v: ::std::vec::Vec<u8>) {
        self.iv = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.iv.is_none() {
            self.iv.set_default();
        }
        self.iv.as_mut().unwrap()
    }

    // Take field
    pub fn take_iv(&mut self) -> ::std::vec::Vec<u8> {
        self.iv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required string ezKeyVersionName = 3;


    pub fn get_ezKeyVersionName(&self) -> &str {
        match self.ezKeyVersionName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ezKeyVersionName(&mut self) {
        self.ezKeyVersionName.clear();
    }

    pub fn has_ezKeyVersionName(&self) -> bool {
        self.ezKeyVersionName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ezKeyVersionName(&mut self, v: ::std::string::String) {
        self.ezKeyVersionName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ezKeyVersionName(&mut self) -> &mut ::std::string::String {
        if self.ezKeyVersionName.is_none() {
            self.ezKeyVersionName.set_default();
        }
        self.ezKeyVersionName.as_mut().unwrap()
    }

    // Take field
    pub fn take_ezKeyVersionName(&mut self) -> ::std::string::String {
        self.ezKeyVersionName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PerFileEncryptionInfoProto {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.iv.is_none() {
            return false;
        }
        if self.ezKeyVersionName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.iv)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ezKeyVersionName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.iv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.ezKeyVersionName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.iv.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.ezKeyVersionName.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PerFileEncryptionInfoProto {
        PerFileEncryptionInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &PerFileEncryptionInfoProto| { &m.key },
                |m: &mut PerFileEncryptionInfoProto| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "iv",
                |m: &PerFileEncryptionInfoProto| { &m.iv },
                |m: &mut PerFileEncryptionInfoProto| { &mut m.iv },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ezKeyVersionName",
                |m: &PerFileEncryptionInfoProto| { &m.ezKeyVersionName },
                |m: &mut PerFileEncryptionInfoProto| { &mut m.ezKeyVersionName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PerFileEncryptionInfoProto>(
                "PerFileEncryptionInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PerFileEncryptionInfoProto {
        static instance: ::protobuf::rt::LazyV2<PerFileEncryptionInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PerFileEncryptionInfoProto::new)
    }
}

impl ::protobuf::Clear for PerFileEncryptionInfoProto {
    fn clear(&mut self) {
        self.key.clear();
        self.iv.clear();
        self.ezKeyVersionName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PerFileEncryptionInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PerFileEncryptionInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZoneEncryptionInfoProto {
    // message fields
    suite: ::std::option::Option<CipherSuiteProto>,
    cryptoProtocolVersion: ::std::option::Option<CryptoProtocolVersionProto>,
    keyName: ::protobuf::SingularField<::std::string::String>,
    pub reencryptionProto: ::protobuf::SingularPtrField<ReencryptionInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZoneEncryptionInfoProto {
    fn default() -> &'a ZoneEncryptionInfoProto {
        <ZoneEncryptionInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl ZoneEncryptionInfoProto {
    pub fn new() -> ZoneEncryptionInfoProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CipherSuiteProto suite = 1;


    pub fn get_suite(&self) -> CipherSuiteProto {
        self.suite.unwrap_or(CipherSuiteProto::UNKNOWN)
    }
    pub fn clear_suite(&mut self) {
        self.suite = ::std::option::Option::None;
    }

    pub fn has_suite(&self) -> bool {
        self.suite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suite(&mut self, v: CipherSuiteProto) {
        self.suite = ::std::option::Option::Some(v);
    }

    // required .hadoop.hdfs.CryptoProtocolVersionProto cryptoProtocolVersion = 2;


    pub fn get_cryptoProtocolVersion(&self) -> CryptoProtocolVersionProto {
        self.cryptoProtocolVersion.unwrap_or(CryptoProtocolVersionProto::UNKNOWN_PROTOCOL_VERSION)
    }
    pub fn clear_cryptoProtocolVersion(&mut self) {
        self.cryptoProtocolVersion = ::std::option::Option::None;
    }

    pub fn has_cryptoProtocolVersion(&self) -> bool {
        self.cryptoProtocolVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cryptoProtocolVersion(&mut self, v: CryptoProtocolVersionProto) {
        self.cryptoProtocolVersion = ::std::option::Option::Some(v);
    }

    // required string keyName = 3;


    pub fn get_keyName(&self) -> &str {
        match self.keyName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_keyName(&mut self) {
        self.keyName.clear();
    }

    pub fn has_keyName(&self) -> bool {
        self.keyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyName(&mut self, v: ::std::string::String) {
        self.keyName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyName(&mut self) -> &mut ::std::string::String {
        if self.keyName.is_none() {
            self.keyName.set_default();
        }
        self.keyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyName(&mut self) -> ::std::string::String {
        self.keyName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .hadoop.hdfs.ReencryptionInfoProto reencryptionProto = 4;


    pub fn get_reencryptionProto(&self) -> &ReencryptionInfoProto {
        self.reencryptionProto.as_ref().unwrap_or_else(|| <ReencryptionInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reencryptionProto(&mut self) {
        self.reencryptionProto.clear();
    }

    pub fn has_reencryptionProto(&self) -> bool {
        self.reencryptionProto.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reencryptionProto(&mut self, v: ReencryptionInfoProto) {
        self.reencryptionProto = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reencryptionProto(&mut self) -> &mut ReencryptionInfoProto {
        if self.reencryptionProto.is_none() {
            self.reencryptionProto.set_default();
        }
        self.reencryptionProto.as_mut().unwrap()
    }

    // Take field
    pub fn take_reencryptionProto(&mut self) -> ReencryptionInfoProto {
        self.reencryptionProto.take().unwrap_or_else(|| ReencryptionInfoProto::new())
    }
}

impl ::protobuf::Message for ZoneEncryptionInfoProto {
    fn is_initialized(&self) -> bool {
        if self.suite.is_none() {
            return false;
        }
        if self.cryptoProtocolVersion.is_none() {
            return false;
        }
        if self.keyName.is_none() {
            return false;
        }
        for v in &self.reencryptionProto {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.suite, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.cryptoProtocolVersion, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.keyName)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reencryptionProto)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.suite {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.cryptoProtocolVersion {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.keyName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.reencryptionProto.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.suite {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.cryptoProtocolVersion {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.keyName.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.reencryptionProto.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZoneEncryptionInfoProto {
        ZoneEncryptionInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CipherSuiteProto>>(
                "suite",
                |m: &ZoneEncryptionInfoProto| { &m.suite },
                |m: &mut ZoneEncryptionInfoProto| { &mut m.suite },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CryptoProtocolVersionProto>>(
                "cryptoProtocolVersion",
                |m: &ZoneEncryptionInfoProto| { &m.cryptoProtocolVersion },
                |m: &mut ZoneEncryptionInfoProto| { &mut m.cryptoProtocolVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "keyName",
                |m: &ZoneEncryptionInfoProto| { &m.keyName },
                |m: &mut ZoneEncryptionInfoProto| { &mut m.keyName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReencryptionInfoProto>>(
                "reencryptionProto",
                |m: &ZoneEncryptionInfoProto| { &m.reencryptionProto },
                |m: &mut ZoneEncryptionInfoProto| { &mut m.reencryptionProto },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZoneEncryptionInfoProto>(
                "ZoneEncryptionInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZoneEncryptionInfoProto {
        static instance: ::protobuf::rt::LazyV2<ZoneEncryptionInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZoneEncryptionInfoProto::new)
    }
}

impl ::protobuf::Clear for ZoneEncryptionInfoProto {
    fn clear(&mut self) {
        self.suite = ::std::option::Option::None;
        self.cryptoProtocolVersion = ::std::option::Option::None;
        self.keyName.clear();
        self.reencryptionProto.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZoneEncryptionInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZoneEncryptionInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReencryptionInfoProto {
    // message fields
    ezKeyVersionName: ::protobuf::SingularField<::std::string::String>,
    submissionTime: ::std::option::Option<u64>,
    canceled: ::std::option::Option<bool>,
    numReencrypted: ::std::option::Option<i64>,
    numFailures: ::std::option::Option<i64>,
    completionTime: ::std::option::Option<u64>,
    lastFile: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReencryptionInfoProto {
    fn default() -> &'a ReencryptionInfoProto {
        <ReencryptionInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl ReencryptionInfoProto {
    pub fn new() -> ReencryptionInfoProto {
        ::std::default::Default::default()
    }

    // required string ezKeyVersionName = 1;


    pub fn get_ezKeyVersionName(&self) -> &str {
        match self.ezKeyVersionName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ezKeyVersionName(&mut self) {
        self.ezKeyVersionName.clear();
    }

    pub fn has_ezKeyVersionName(&self) -> bool {
        self.ezKeyVersionName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ezKeyVersionName(&mut self, v: ::std::string::String) {
        self.ezKeyVersionName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ezKeyVersionName(&mut self) -> &mut ::std::string::String {
        if self.ezKeyVersionName.is_none() {
            self.ezKeyVersionName.set_default();
        }
        self.ezKeyVersionName.as_mut().unwrap()
    }

    // Take field
    pub fn take_ezKeyVersionName(&mut self) -> ::std::string::String {
        self.ezKeyVersionName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 submissionTime = 2;


    pub fn get_submissionTime(&self) -> u64 {
        self.submissionTime.unwrap_or(0)
    }
    pub fn clear_submissionTime(&mut self) {
        self.submissionTime = ::std::option::Option::None;
    }

    pub fn has_submissionTime(&self) -> bool {
        self.submissionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_submissionTime(&mut self, v: u64) {
        self.submissionTime = ::std::option::Option::Some(v);
    }

    // required bool canceled = 3;


    pub fn get_canceled(&self) -> bool {
        self.canceled.unwrap_or(false)
    }
    pub fn clear_canceled(&mut self) {
        self.canceled = ::std::option::Option::None;
    }

    pub fn has_canceled(&self) -> bool {
        self.canceled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_canceled(&mut self, v: bool) {
        self.canceled = ::std::option::Option::Some(v);
    }

    // required int64 numReencrypted = 4;


    pub fn get_numReencrypted(&self) -> i64 {
        self.numReencrypted.unwrap_or(0)
    }
    pub fn clear_numReencrypted(&mut self) {
        self.numReencrypted = ::std::option::Option::None;
    }

    pub fn has_numReencrypted(&self) -> bool {
        self.numReencrypted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numReencrypted(&mut self, v: i64) {
        self.numReencrypted = ::std::option::Option::Some(v);
    }

    // required int64 numFailures = 5;


    pub fn get_numFailures(&self) -> i64 {
        self.numFailures.unwrap_or(0)
    }
    pub fn clear_numFailures(&mut self) {
        self.numFailures = ::std::option::Option::None;
    }

    pub fn has_numFailures(&self) -> bool {
        self.numFailures.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numFailures(&mut self, v: i64) {
        self.numFailures = ::std::option::Option::Some(v);
    }

    // optional uint64 completionTime = 6;


    pub fn get_completionTime(&self) -> u64 {
        self.completionTime.unwrap_or(0)
    }
    pub fn clear_completionTime(&mut self) {
        self.completionTime = ::std::option::Option::None;
    }

    pub fn has_completionTime(&self) -> bool {
        self.completionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completionTime(&mut self, v: u64) {
        self.completionTime = ::std::option::Option::Some(v);
    }

    // optional string lastFile = 7;


    pub fn get_lastFile(&self) -> &str {
        match self.lastFile.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_lastFile(&mut self) {
        self.lastFile.clear();
    }

    pub fn has_lastFile(&self) -> bool {
        self.lastFile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastFile(&mut self, v: ::std::string::String) {
        self.lastFile = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastFile(&mut self) -> &mut ::std::string::String {
        if self.lastFile.is_none() {
            self.lastFile.set_default();
        }
        self.lastFile.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastFile(&mut self) -> ::std::string::String {
        self.lastFile.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ReencryptionInfoProto {
    fn is_initialized(&self) -> bool {
        if self.ezKeyVersionName.is_none() {
            return false;
        }
        if self.submissionTime.is_none() {
            return false;
        }
        if self.canceled.is_none() {
            return false;
        }
        if self.numReencrypted.is_none() {
            return false;
        }
        if self.numFailures.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ezKeyVersionName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.submissionTime = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.canceled = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.numReencrypted = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.numFailures = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.completionTime = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.lastFile)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ezKeyVersionName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.submissionTime {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.canceled {
            my_size += 2;
        }
        if let Some(v) = self.numReencrypted {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numFailures {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.completionTime {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.lastFile.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ezKeyVersionName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.submissionTime {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.canceled {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.numReencrypted {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.numFailures {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.completionTime {
            os.write_uint64(6, v)?;
        }
        if let Some(ref v) = self.lastFile.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReencryptionInfoProto {
        ReencryptionInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ezKeyVersionName",
                |m: &ReencryptionInfoProto| { &m.ezKeyVersionName },
                |m: &mut ReencryptionInfoProto| { &mut m.ezKeyVersionName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "submissionTime",
                |m: &ReencryptionInfoProto| { &m.submissionTime },
                |m: &mut ReencryptionInfoProto| { &mut m.submissionTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "canceled",
                |m: &ReencryptionInfoProto| { &m.canceled },
                |m: &mut ReencryptionInfoProto| { &mut m.canceled },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "numReencrypted",
                |m: &ReencryptionInfoProto| { &m.numReencrypted },
                |m: &mut ReencryptionInfoProto| { &mut m.numReencrypted },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "numFailures",
                |m: &ReencryptionInfoProto| { &m.numFailures },
                |m: &mut ReencryptionInfoProto| { &mut m.numFailures },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "completionTime",
                |m: &ReencryptionInfoProto| { &m.completionTime },
                |m: &mut ReencryptionInfoProto| { &mut m.completionTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "lastFile",
                |m: &ReencryptionInfoProto| { &m.lastFile },
                |m: &mut ReencryptionInfoProto| { &mut m.lastFile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReencryptionInfoProto>(
                "ReencryptionInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReencryptionInfoProto {
        static instance: ::protobuf::rt::LazyV2<ReencryptionInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReencryptionInfoProto::new)
    }
}

impl ::protobuf::Clear for ReencryptionInfoProto {
    fn clear(&mut self) {
        self.ezKeyVersionName.clear();
        self.submissionTime = ::std::option::Option::None;
        self.canceled = ::std::option::Option::None;
        self.numReencrypted = ::std::option::Option::None;
        self.numFailures = ::std::option::Option::None;
        self.completionTime = ::std::option::Option::None;
        self.lastFile.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReencryptionInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReencryptionInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CipherOptionProto {
    // message fields
    suite: ::std::option::Option<CipherSuiteProto>,
    inKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    inIv: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    outKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    outIv: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CipherOptionProto {
    fn default() -> &'a CipherOptionProto {
        <CipherOptionProto as ::protobuf::Message>::default_instance()
    }
}

impl CipherOptionProto {
    pub fn new() -> CipherOptionProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CipherSuiteProto suite = 1;


    pub fn get_suite(&self) -> CipherSuiteProto {
        self.suite.unwrap_or(CipherSuiteProto::UNKNOWN)
    }
    pub fn clear_suite(&mut self) {
        self.suite = ::std::option::Option::None;
    }

    pub fn has_suite(&self) -> bool {
        self.suite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suite(&mut self, v: CipherSuiteProto) {
        self.suite = ::std::option::Option::Some(v);
    }

    // optional bytes inKey = 2;


    pub fn get_inKey(&self) -> &[u8] {
        match self.inKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_inKey(&mut self) {
        self.inKey.clear();
    }

    pub fn has_inKey(&self) -> bool {
        self.inKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.inKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.inKey.is_none() {
            self.inKey.set_default();
        }
        self.inKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_inKey(&mut self) -> ::std::vec::Vec<u8> {
        self.inKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes inIv = 3;


    pub fn get_inIv(&self) -> &[u8] {
        match self.inIv.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_inIv(&mut self) {
        self.inIv.clear();
    }

    pub fn has_inIv(&self) -> bool {
        self.inIv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inIv(&mut self, v: ::std::vec::Vec<u8>) {
        self.inIv = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inIv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.inIv.is_none() {
            self.inIv.set_default();
        }
        self.inIv.as_mut().unwrap()
    }

    // Take field
    pub fn take_inIv(&mut self) -> ::std::vec::Vec<u8> {
        self.inIv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes outKey = 4;


    pub fn get_outKey(&self) -> &[u8] {
        match self.outKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_outKey(&mut self) {
        self.outKey.clear();
    }

    pub fn has_outKey(&self) -> bool {
        self.outKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.outKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.outKey.is_none() {
            self.outKey.set_default();
        }
        self.outKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_outKey(&mut self) -> ::std::vec::Vec<u8> {
        self.outKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes outIv = 5;


    pub fn get_outIv(&self) -> &[u8] {
        match self.outIv.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_outIv(&mut self) {
        self.outIv.clear();
    }

    pub fn has_outIv(&self) -> bool {
        self.outIv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outIv(&mut self, v: ::std::vec::Vec<u8>) {
        self.outIv = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outIv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.outIv.is_none() {
            self.outIv.set_default();
        }
        self.outIv.as_mut().unwrap()
    }

    // Take field
    pub fn take_outIv(&mut self) -> ::std::vec::Vec<u8> {
        self.outIv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CipherOptionProto {
    fn is_initialized(&self) -> bool {
        if self.suite.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.suite, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.inKey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.inIv)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.outKey)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.outIv)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.suite {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.inKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.inIv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.outKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.outIv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.suite {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.inKey.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.inIv.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.outKey.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.outIv.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CipherOptionProto {
        CipherOptionProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CipherSuiteProto>>(
                "suite",
                |m: &CipherOptionProto| { &m.suite },
                |m: &mut CipherOptionProto| { &mut m.suite },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "inKey",
                |m: &CipherOptionProto| { &m.inKey },
                |m: &mut CipherOptionProto| { &mut m.inKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "inIv",
                |m: &CipherOptionProto| { &m.inIv },
                |m: &mut CipherOptionProto| { &mut m.inIv },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "outKey",
                |m: &CipherOptionProto| { &m.outKey },
                |m: &mut CipherOptionProto| { &mut m.outKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "outIv",
                |m: &CipherOptionProto| { &m.outIv },
                |m: &mut CipherOptionProto| { &mut m.outIv },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CipherOptionProto>(
                "CipherOptionProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CipherOptionProto {
        static instance: ::protobuf::rt::LazyV2<CipherOptionProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CipherOptionProto::new)
    }
}

impl ::protobuf::Clear for CipherOptionProto {
    fn clear(&mut self) {
        self.suite = ::std::option::Option::None;
        self.inKey.clear();
        self.inIv.clear();
        self.outKey.clear();
        self.outIv.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CipherOptionProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CipherOptionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocatedBlocksProto {
    // message fields
    fileLength: ::std::option::Option<u64>,
    pub blocks: ::protobuf::RepeatedField<LocatedBlockProto>,
    underConstruction: ::std::option::Option<bool>,
    pub lastBlock: ::protobuf::SingularPtrField<LocatedBlockProto>,
    isLastBlockComplete: ::std::option::Option<bool>,
    pub fileEncryptionInfo: ::protobuf::SingularPtrField<FileEncryptionInfoProto>,
    pub ecPolicy: ::protobuf::SingularPtrField<ErasureCodingPolicyProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LocatedBlocksProto {
    fn default() -> &'a LocatedBlocksProto {
        <LocatedBlocksProto as ::protobuf::Message>::default_instance()
    }
}

impl LocatedBlocksProto {
    pub fn new() -> LocatedBlocksProto {
        ::std::default::Default::default()
    }

    // required uint64 fileLength = 1;


    pub fn get_fileLength(&self) -> u64 {
        self.fileLength.unwrap_or(0)
    }
    pub fn clear_fileLength(&mut self) {
        self.fileLength = ::std::option::Option::None;
    }

    pub fn has_fileLength(&self) -> bool {
        self.fileLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileLength(&mut self, v: u64) {
        self.fileLength = ::std::option::Option::Some(v);
    }

    // repeated .hadoop.hdfs.LocatedBlockProto blocks = 2;


    pub fn get_blocks(&self) -> &[LocatedBlockProto] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<LocatedBlockProto>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<LocatedBlockProto> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<LocatedBlockProto> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }

    // required bool underConstruction = 3;


    pub fn get_underConstruction(&self) -> bool {
        self.underConstruction.unwrap_or(false)
    }
    pub fn clear_underConstruction(&mut self) {
        self.underConstruction = ::std::option::Option::None;
    }

    pub fn has_underConstruction(&self) -> bool {
        self.underConstruction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_underConstruction(&mut self, v: bool) {
        self.underConstruction = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.LocatedBlockProto lastBlock = 4;


    pub fn get_lastBlock(&self) -> &LocatedBlockProto {
        self.lastBlock.as_ref().unwrap_or_else(|| <LocatedBlockProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lastBlock(&mut self) {
        self.lastBlock.clear();
    }

    pub fn has_lastBlock(&self) -> bool {
        self.lastBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastBlock(&mut self, v: LocatedBlockProto) {
        self.lastBlock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastBlock(&mut self) -> &mut LocatedBlockProto {
        if self.lastBlock.is_none() {
            self.lastBlock.set_default();
        }
        self.lastBlock.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastBlock(&mut self) -> LocatedBlockProto {
        self.lastBlock.take().unwrap_or_else(|| LocatedBlockProto::new())
    }

    // required bool isLastBlockComplete = 5;


    pub fn get_isLastBlockComplete(&self) -> bool {
        self.isLastBlockComplete.unwrap_or(false)
    }
    pub fn clear_isLastBlockComplete(&mut self) {
        self.isLastBlockComplete = ::std::option::Option::None;
    }

    pub fn has_isLastBlockComplete(&self) -> bool {
        self.isLastBlockComplete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isLastBlockComplete(&mut self, v: bool) {
        self.isLastBlockComplete = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.FileEncryptionInfoProto fileEncryptionInfo = 6;


    pub fn get_fileEncryptionInfo(&self) -> &FileEncryptionInfoProto {
        self.fileEncryptionInfo.as_ref().unwrap_or_else(|| <FileEncryptionInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fileEncryptionInfo(&mut self) {
        self.fileEncryptionInfo.clear();
    }

    pub fn has_fileEncryptionInfo(&self) -> bool {
        self.fileEncryptionInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileEncryptionInfo(&mut self, v: FileEncryptionInfoProto) {
        self.fileEncryptionInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileEncryptionInfo(&mut self) -> &mut FileEncryptionInfoProto {
        if self.fileEncryptionInfo.is_none() {
            self.fileEncryptionInfo.set_default();
        }
        self.fileEncryptionInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileEncryptionInfo(&mut self) -> FileEncryptionInfoProto {
        self.fileEncryptionInfo.take().unwrap_or_else(|| FileEncryptionInfoProto::new())
    }

    // optional .hadoop.hdfs.ErasureCodingPolicyProto ecPolicy = 7;


    pub fn get_ecPolicy(&self) -> &ErasureCodingPolicyProto {
        self.ecPolicy.as_ref().unwrap_or_else(|| <ErasureCodingPolicyProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ecPolicy(&mut self) {
        self.ecPolicy.clear();
    }

    pub fn has_ecPolicy(&self) -> bool {
        self.ecPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ecPolicy(&mut self, v: ErasureCodingPolicyProto) {
        self.ecPolicy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ecPolicy(&mut self) -> &mut ErasureCodingPolicyProto {
        if self.ecPolicy.is_none() {
            self.ecPolicy.set_default();
        }
        self.ecPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_ecPolicy(&mut self) -> ErasureCodingPolicyProto {
        self.ecPolicy.take().unwrap_or_else(|| ErasureCodingPolicyProto::new())
    }
}

impl ::protobuf::Message for LocatedBlocksProto {
    fn is_initialized(&self) -> bool {
        if self.fileLength.is_none() {
            return false;
        }
        if self.underConstruction.is_none() {
            return false;
        }
        if self.isLastBlockComplete.is_none() {
            return false;
        }
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lastBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fileEncryptionInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ecPolicy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileLength = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.underConstruction = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastBlock)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isLastBlockComplete = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fileEncryptionInfo)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ecPolicy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fileLength {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.underConstruction {
            my_size += 2;
        }
        if let Some(ref v) = self.lastBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.isLastBlockComplete {
            my_size += 2;
        }
        if let Some(ref v) = self.fileEncryptionInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ecPolicy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fileLength {
            os.write_uint64(1, v)?;
        }
        for v in &self.blocks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.underConstruction {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.lastBlock.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.isLastBlockComplete {
            os.write_bool(5, v)?;
        }
        if let Some(ref v) = self.fileEncryptionInfo.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ecPolicy.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocatedBlocksProto {
        LocatedBlocksProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fileLength",
                |m: &LocatedBlocksProto| { &m.fileLength },
                |m: &mut LocatedBlocksProto| { &mut m.fileLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocatedBlockProto>>(
                "blocks",
                |m: &LocatedBlocksProto| { &m.blocks },
                |m: &mut LocatedBlocksProto| { &mut m.blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "underConstruction",
                |m: &LocatedBlocksProto| { &m.underConstruction },
                |m: &mut LocatedBlocksProto| { &mut m.underConstruction },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocatedBlockProto>>(
                "lastBlock",
                |m: &LocatedBlocksProto| { &m.lastBlock },
                |m: &mut LocatedBlocksProto| { &mut m.lastBlock },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isLastBlockComplete",
                |m: &LocatedBlocksProto| { &m.isLastBlockComplete },
                |m: &mut LocatedBlocksProto| { &mut m.isLastBlockComplete },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileEncryptionInfoProto>>(
                "fileEncryptionInfo",
                |m: &LocatedBlocksProto| { &m.fileEncryptionInfo },
                |m: &mut LocatedBlocksProto| { &mut m.fileEncryptionInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ErasureCodingPolicyProto>>(
                "ecPolicy",
                |m: &LocatedBlocksProto| { &m.ecPolicy },
                |m: &mut LocatedBlocksProto| { &mut m.ecPolicy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LocatedBlocksProto>(
                "LocatedBlocksProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LocatedBlocksProto {
        static instance: ::protobuf::rt::LazyV2<LocatedBlocksProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LocatedBlocksProto::new)
    }
}

impl ::protobuf::Clear for LocatedBlocksProto {
    fn clear(&mut self) {
        self.fileLength = ::std::option::Option::None;
        self.blocks.clear();
        self.underConstruction = ::std::option::Option::None;
        self.lastBlock.clear();
        self.isLastBlockComplete = ::std::option::Option::None;
        self.fileEncryptionInfo.clear();
        self.ecPolicy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocatedBlocksProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocatedBlocksProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ECSchemaOptionEntryProto {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ECSchemaOptionEntryProto {
    fn default() -> &'a ECSchemaOptionEntryProto {
        <ECSchemaOptionEntryProto as ::protobuf::Message>::default_instance()
    }
}

impl ECSchemaOptionEntryProto {
    pub fn new() -> ECSchemaOptionEntryProto {
        ::std::default::Default::default()
    }

    // required string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ECSchemaOptionEntryProto {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.value.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ECSchemaOptionEntryProto {
        ECSchemaOptionEntryProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &ECSchemaOptionEntryProto| { &m.key },
                |m: &mut ECSchemaOptionEntryProto| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &ECSchemaOptionEntryProto| { &m.value },
                |m: &mut ECSchemaOptionEntryProto| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ECSchemaOptionEntryProto>(
                "ECSchemaOptionEntryProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ECSchemaOptionEntryProto {
        static instance: ::protobuf::rt::LazyV2<ECSchemaOptionEntryProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ECSchemaOptionEntryProto::new)
    }
}

impl ::protobuf::Clear for ECSchemaOptionEntryProto {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ECSchemaOptionEntryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ECSchemaOptionEntryProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ECSchemaProto {
    // message fields
    codecName: ::protobuf::SingularField<::std::string::String>,
    dataUnits: ::std::option::Option<u32>,
    parityUnits: ::std::option::Option<u32>,
    pub options: ::protobuf::RepeatedField<ECSchemaOptionEntryProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ECSchemaProto {
    fn default() -> &'a ECSchemaProto {
        <ECSchemaProto as ::protobuf::Message>::default_instance()
    }
}

impl ECSchemaProto {
    pub fn new() -> ECSchemaProto {
        ::std::default::Default::default()
    }

    // required string codecName = 1;


    pub fn get_codecName(&self) -> &str {
        match self.codecName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_codecName(&mut self) {
        self.codecName.clear();
    }

    pub fn has_codecName(&self) -> bool {
        self.codecName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codecName(&mut self, v: ::std::string::String) {
        self.codecName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codecName(&mut self) -> &mut ::std::string::String {
        if self.codecName.is_none() {
            self.codecName.set_default();
        }
        self.codecName.as_mut().unwrap()
    }

    // Take field
    pub fn take_codecName(&mut self) -> ::std::string::String {
        self.codecName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint32 dataUnits = 2;


    pub fn get_dataUnits(&self) -> u32 {
        self.dataUnits.unwrap_or(0)
    }
    pub fn clear_dataUnits(&mut self) {
        self.dataUnits = ::std::option::Option::None;
    }

    pub fn has_dataUnits(&self) -> bool {
        self.dataUnits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dataUnits(&mut self, v: u32) {
        self.dataUnits = ::std::option::Option::Some(v);
    }

    // required uint32 parityUnits = 3;


    pub fn get_parityUnits(&self) -> u32 {
        self.parityUnits.unwrap_or(0)
    }
    pub fn clear_parityUnits(&mut self) {
        self.parityUnits = ::std::option::Option::None;
    }

    pub fn has_parityUnits(&self) -> bool {
        self.parityUnits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parityUnits(&mut self, v: u32) {
        self.parityUnits = ::std::option::Option::Some(v);
    }

    // repeated .hadoop.hdfs.ECSchemaOptionEntryProto options = 4;


    pub fn get_options(&self) -> &[ECSchemaOptionEntryProto] {
        &self.options
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::protobuf::RepeatedField<ECSchemaOptionEntryProto>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options(&mut self) -> &mut ::protobuf::RepeatedField<ECSchemaOptionEntryProto> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::protobuf::RepeatedField<ECSchemaOptionEntryProto> {
        ::std::mem::replace(&mut self.options, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ECSchemaProto {
    fn is_initialized(&self) -> bool {
        if self.codecName.is_none() {
            return false;
        }
        if self.dataUnits.is_none() {
            return false;
        }
        if self.parityUnits.is_none() {
            return false;
        }
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.codecName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dataUnits = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.parityUnits = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.codecName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.dataUnits {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.parityUnits {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.options {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.codecName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.dataUnits {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.parityUnits {
            os.write_uint32(3, v)?;
        }
        for v in &self.options {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ECSchemaProto {
        ECSchemaProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "codecName",
                |m: &ECSchemaProto| { &m.codecName },
                |m: &mut ECSchemaProto| { &mut m.codecName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dataUnits",
                |m: &ECSchemaProto| { &m.dataUnits },
                |m: &mut ECSchemaProto| { &mut m.dataUnits },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "parityUnits",
                |m: &ECSchemaProto| { &m.parityUnits },
                |m: &mut ECSchemaProto| { &mut m.parityUnits },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ECSchemaOptionEntryProto>>(
                "options",
                |m: &ECSchemaProto| { &m.options },
                |m: &mut ECSchemaProto| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ECSchemaProto>(
                "ECSchemaProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ECSchemaProto {
        static instance: ::protobuf::rt::LazyV2<ECSchemaProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ECSchemaProto::new)
    }
}

impl ::protobuf::Clear for ECSchemaProto {
    fn clear(&mut self) {
        self.codecName.clear();
        self.dataUnits = ::std::option::Option::None;
        self.parityUnits = ::std::option::Option::None;
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ECSchemaProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ECSchemaProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ErasureCodingPolicyProto {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    pub schema: ::protobuf::SingularPtrField<ECSchemaProto>,
    cellSize: ::std::option::Option<u32>,
    id: ::std::option::Option<u32>,
    state: ::std::option::Option<ErasureCodingPolicyState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ErasureCodingPolicyProto {
    fn default() -> &'a ErasureCodingPolicyProto {
        <ErasureCodingPolicyProto as ::protobuf::Message>::default_instance()
    }
}

impl ErasureCodingPolicyProto {
    pub fn new() -> ErasureCodingPolicyProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .hadoop.hdfs.ECSchemaProto schema = 2;


    pub fn get_schema(&self) -> &ECSchemaProto {
        self.schema.as_ref().unwrap_or_else(|| <ECSchemaProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: ECSchemaProto) {
        self.schema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut ECSchemaProto {
        if self.schema.is_none() {
            self.schema.set_default();
        }
        self.schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema(&mut self) -> ECSchemaProto {
        self.schema.take().unwrap_or_else(|| ECSchemaProto::new())
    }

    // optional uint32 cellSize = 3;


    pub fn get_cellSize(&self) -> u32 {
        self.cellSize.unwrap_or(0)
    }
    pub fn clear_cellSize(&mut self) {
        self.cellSize = ::std::option::Option::None;
    }

    pub fn has_cellSize(&self) -> bool {
        self.cellSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cellSize(&mut self, v: u32) {
        self.cellSize = ::std::option::Option::Some(v);
    }

    // required uint32 id = 4;


    pub fn get_id(&self) -> u32 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.ErasureCodingPolicyState state = 5;


    pub fn get_state(&self) -> ErasureCodingPolicyState {
        self.state.unwrap_or(ErasureCodingPolicyState::ENABLED)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ErasureCodingPolicyState) {
        self.state = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ErasureCodingPolicyProto {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        for v in &self.schema {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.schema)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cellSize = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.cellSize {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.schema.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.cellSize {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.state {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ErasureCodingPolicyProto {
        ErasureCodingPolicyProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ErasureCodingPolicyProto| { &m.name },
                |m: &mut ErasureCodingPolicyProto| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ECSchemaProto>>(
                "schema",
                |m: &ErasureCodingPolicyProto| { &m.schema },
                |m: &mut ErasureCodingPolicyProto| { &mut m.schema },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cellSize",
                |m: &ErasureCodingPolicyProto| { &m.cellSize },
                |m: &mut ErasureCodingPolicyProto| { &mut m.cellSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &ErasureCodingPolicyProto| { &m.id },
                |m: &mut ErasureCodingPolicyProto| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ErasureCodingPolicyState>>(
                "state",
                |m: &ErasureCodingPolicyProto| { &m.state },
                |m: &mut ErasureCodingPolicyProto| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ErasureCodingPolicyProto>(
                "ErasureCodingPolicyProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ErasureCodingPolicyProto {
        static instance: ::protobuf::rt::LazyV2<ErasureCodingPolicyProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ErasureCodingPolicyProto::new)
    }
}

impl ::protobuf::Clear for ErasureCodingPolicyProto {
    fn clear(&mut self) {
        self.name.clear();
        self.schema.clear();
        self.cellSize = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ErasureCodingPolicyProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ErasureCodingPolicyProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddErasureCodingPolicyResponseProto {
    // message fields
    pub policy: ::protobuf::SingularPtrField<ErasureCodingPolicyProto>,
    succeed: ::std::option::Option<bool>,
    errorMsg: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddErasureCodingPolicyResponseProto {
    fn default() -> &'a AddErasureCodingPolicyResponseProto {
        <AddErasureCodingPolicyResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl AddErasureCodingPolicyResponseProto {
    pub fn new() -> AddErasureCodingPolicyResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ErasureCodingPolicyProto policy = 1;


    pub fn get_policy(&self) -> &ErasureCodingPolicyProto {
        self.policy.as_ref().unwrap_or_else(|| <ErasureCodingPolicyProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_policy(&mut self) {
        self.policy.clear();
    }

    pub fn has_policy(&self) -> bool {
        self.policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_policy(&mut self, v: ErasureCodingPolicyProto) {
        self.policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_policy(&mut self) -> &mut ErasureCodingPolicyProto {
        if self.policy.is_none() {
            self.policy.set_default();
        }
        self.policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_policy(&mut self) -> ErasureCodingPolicyProto {
        self.policy.take().unwrap_or_else(|| ErasureCodingPolicyProto::new())
    }

    // required bool succeed = 2;


    pub fn get_succeed(&self) -> bool {
        self.succeed.unwrap_or(false)
    }
    pub fn clear_succeed(&mut self) {
        self.succeed = ::std::option::Option::None;
    }

    pub fn has_succeed(&self) -> bool {
        self.succeed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_succeed(&mut self, v: bool) {
        self.succeed = ::std::option::Option::Some(v);
    }

    // optional string errorMsg = 3;


    pub fn get_errorMsg(&self) -> &str {
        match self.errorMsg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_errorMsg(&mut self) {
        self.errorMsg.clear();
    }

    pub fn has_errorMsg(&self) -> bool {
        self.errorMsg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorMsg(&mut self, v: ::std::string::String) {
        self.errorMsg = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errorMsg(&mut self) -> &mut ::std::string::String {
        if self.errorMsg.is_none() {
            self.errorMsg.set_default();
        }
        self.errorMsg.as_mut().unwrap()
    }

    // Take field
    pub fn take_errorMsg(&mut self) -> ::std::string::String {
        self.errorMsg.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for AddErasureCodingPolicyResponseProto {
    fn is_initialized(&self) -> bool {
        if self.policy.is_none() {
            return false;
        }
        if self.succeed.is_none() {
            return false;
        }
        for v in &self.policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.policy)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.succeed = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.errorMsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.succeed {
            my_size += 2;
        }
        if let Some(ref v) = self.errorMsg.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.policy.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.succeed {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.errorMsg.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddErasureCodingPolicyResponseProto {
        AddErasureCodingPolicyResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ErasureCodingPolicyProto>>(
                "policy",
                |m: &AddErasureCodingPolicyResponseProto| { &m.policy },
                |m: &mut AddErasureCodingPolicyResponseProto| { &mut m.policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "succeed",
                |m: &AddErasureCodingPolicyResponseProto| { &m.succeed },
                |m: &mut AddErasureCodingPolicyResponseProto| { &mut m.succeed },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "errorMsg",
                |m: &AddErasureCodingPolicyResponseProto| { &m.errorMsg },
                |m: &mut AddErasureCodingPolicyResponseProto| { &mut m.errorMsg },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddErasureCodingPolicyResponseProto>(
                "AddErasureCodingPolicyResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddErasureCodingPolicyResponseProto {
        static instance: ::protobuf::rt::LazyV2<AddErasureCodingPolicyResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddErasureCodingPolicyResponseProto::new)
    }
}

impl ::protobuf::Clear for AddErasureCodingPolicyResponseProto {
    fn clear(&mut self) {
        self.policy.clear();
        self.succeed = ::std::option::Option::None;
        self.errorMsg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddErasureCodingPolicyResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddErasureCodingPolicyResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ECTopologyVerifierResultProto {
    // message fields
    resultMessage: ::protobuf::SingularField<::std::string::String>,
    isSupported: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ECTopologyVerifierResultProto {
    fn default() -> &'a ECTopologyVerifierResultProto {
        <ECTopologyVerifierResultProto as ::protobuf::Message>::default_instance()
    }
}

impl ECTopologyVerifierResultProto {
    pub fn new() -> ECTopologyVerifierResultProto {
        ::std::default::Default::default()
    }

    // required string resultMessage = 1;


    pub fn get_resultMessage(&self) -> &str {
        match self.resultMessage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_resultMessage(&mut self) {
        self.resultMessage.clear();
    }

    pub fn has_resultMessage(&self) -> bool {
        self.resultMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resultMessage(&mut self, v: ::std::string::String) {
        self.resultMessage = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resultMessage(&mut self) -> &mut ::std::string::String {
        if self.resultMessage.is_none() {
            self.resultMessage.set_default();
        }
        self.resultMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_resultMessage(&mut self) -> ::std::string::String {
        self.resultMessage.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bool isSupported = 2;


    pub fn get_isSupported(&self) -> bool {
        self.isSupported.unwrap_or(false)
    }
    pub fn clear_isSupported(&mut self) {
        self.isSupported = ::std::option::Option::None;
    }

    pub fn has_isSupported(&self) -> bool {
        self.isSupported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isSupported(&mut self, v: bool) {
        self.isSupported = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ECTopologyVerifierResultProto {
    fn is_initialized(&self) -> bool {
        if self.resultMessage.is_none() {
            return false;
        }
        if self.isSupported.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resultMessage)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isSupported = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.resultMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.isSupported {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.resultMessage.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.isSupported {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ECTopologyVerifierResultProto {
        ECTopologyVerifierResultProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resultMessage",
                |m: &ECTopologyVerifierResultProto| { &m.resultMessage },
                |m: &mut ECTopologyVerifierResultProto| { &mut m.resultMessage },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isSupported",
                |m: &ECTopologyVerifierResultProto| { &m.isSupported },
                |m: &mut ECTopologyVerifierResultProto| { &mut m.isSupported },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ECTopologyVerifierResultProto>(
                "ECTopologyVerifierResultProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ECTopologyVerifierResultProto {
        static instance: ::protobuf::rt::LazyV2<ECTopologyVerifierResultProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ECTopologyVerifierResultProto::new)
    }
}

impl ::protobuf::Clear for ECTopologyVerifierResultProto {
    fn clear(&mut self) {
        self.resultMessage.clear();
        self.isSupported = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ECTopologyVerifierResultProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ECTopologyVerifierResultProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HdfsPathHandleProto {
    // message fields
    inodeId: ::std::option::Option<u64>,
    mtime: ::std::option::Option<u64>,
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HdfsPathHandleProto {
    fn default() -> &'a HdfsPathHandleProto {
        <HdfsPathHandleProto as ::protobuf::Message>::default_instance()
    }
}

impl HdfsPathHandleProto {
    pub fn new() -> HdfsPathHandleProto {
        ::std::default::Default::default()
    }

    // optional uint64 inodeId = 1;


    pub fn get_inodeId(&self) -> u64 {
        self.inodeId.unwrap_or(0)
    }
    pub fn clear_inodeId(&mut self) {
        self.inodeId = ::std::option::Option::None;
    }

    pub fn has_inodeId(&self) -> bool {
        self.inodeId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inodeId(&mut self, v: u64) {
        self.inodeId = ::std::option::Option::Some(v);
    }

    // optional uint64 mtime = 2;


    pub fn get_mtime(&self) -> u64 {
        self.mtime.unwrap_or(0)
    }
    pub fn clear_mtime(&mut self) {
        self.mtime = ::std::option::Option::None;
    }

    pub fn has_mtime(&self) -> bool {
        self.mtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mtime(&mut self, v: u64) {
        self.mtime = ::std::option::Option::Some(v);
    }

    // optional string path = 3;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for HdfsPathHandleProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.inodeId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mtime = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.inodeId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mtime {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.inodeId {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.mtime {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HdfsPathHandleProto {
        HdfsPathHandleProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "inodeId",
                |m: &HdfsPathHandleProto| { &m.inodeId },
                |m: &mut HdfsPathHandleProto| { &mut m.inodeId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "mtime",
                |m: &HdfsPathHandleProto| { &m.mtime },
                |m: &mut HdfsPathHandleProto| { &mut m.mtime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &HdfsPathHandleProto| { &m.path },
                |m: &mut HdfsPathHandleProto| { &mut m.path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HdfsPathHandleProto>(
                "HdfsPathHandleProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HdfsPathHandleProto {
        static instance: ::protobuf::rt::LazyV2<HdfsPathHandleProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HdfsPathHandleProto::new)
    }
}

impl ::protobuf::Clear for HdfsPathHandleProto {
    fn clear(&mut self) {
        self.inodeId = ::std::option::Option::None;
        self.mtime = ::std::option::Option::None;
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HdfsPathHandleProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HdfsPathHandleProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HdfsFileStatusProto {
    // message fields
    fileType: ::std::option::Option<HdfsFileStatusProto_FileType>,
    path: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    length: ::std::option::Option<u64>,
    pub permission: ::protobuf::SingularPtrField<super::acl::FsPermissionProto>,
    owner: ::protobuf::SingularField<::std::string::String>,
    group: ::protobuf::SingularField<::std::string::String>,
    modification_time: ::std::option::Option<u64>,
    access_time: ::std::option::Option<u64>,
    symlink: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    block_replication: ::std::option::Option<u32>,
    blocksize: ::std::option::Option<u64>,
    pub locations: ::protobuf::SingularPtrField<LocatedBlocksProto>,
    fileId: ::std::option::Option<u64>,
    childrenNum: ::std::option::Option<i32>,
    pub fileEncryptionInfo: ::protobuf::SingularPtrField<FileEncryptionInfoProto>,
    storagePolicy: ::std::option::Option<u32>,
    pub ecPolicy: ::protobuf::SingularPtrField<ErasureCodingPolicyProto>,
    flags: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HdfsFileStatusProto {
    fn default() -> &'a HdfsFileStatusProto {
        <HdfsFileStatusProto as ::protobuf::Message>::default_instance()
    }
}

impl HdfsFileStatusProto {
    pub fn new() -> HdfsFileStatusProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.HdfsFileStatusProto.FileType fileType = 1;


    pub fn get_fileType(&self) -> HdfsFileStatusProto_FileType {
        self.fileType.unwrap_or(HdfsFileStatusProto_FileType::IS_DIR)
    }
    pub fn clear_fileType(&mut self) {
        self.fileType = ::std::option::Option::None;
    }

    pub fn has_fileType(&self) -> bool {
        self.fileType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileType(&mut self, v: HdfsFileStatusProto_FileType) {
        self.fileType = ::std::option::Option::Some(v);
    }

    // required bytes path = 2;


    pub fn get_path(&self) -> &[u8] {
        match self.path.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::vec::Vec<u8>) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::vec::Vec<u8> {
        self.path.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint64 length = 3;


    pub fn get_length(&self) -> u64 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = ::std::option::Option::Some(v);
    }

    // required .hadoop.hdfs.FsPermissionProto permission = 4;


    pub fn get_permission(&self) -> &super::acl::FsPermissionProto {
        self.permission.as_ref().unwrap_or_else(|| <super::acl::FsPermissionProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_permission(&mut self) {
        self.permission.clear();
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: super::acl::FsPermissionProto) {
        self.permission = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permission(&mut self) -> &mut super::acl::FsPermissionProto {
        if self.permission.is_none() {
            self.permission.set_default();
        }
        self.permission.as_mut().unwrap()
    }

    // Take field
    pub fn take_permission(&mut self) -> super::acl::FsPermissionProto {
        self.permission.take().unwrap_or_else(|| super::acl::FsPermissionProto::new())
    }

    // required string owner = 5;


    pub fn get_owner(&self) -> &str {
        match self.owner.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_owner(&mut self) {
        self.owner.clear();
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: ::std::string::String) {
        self.owner = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner(&mut self) -> &mut ::std::string::String {
        if self.owner.is_none() {
            self.owner.set_default();
        }
        self.owner.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner(&mut self) -> ::std::string::String {
        self.owner.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string group = 6;


    pub fn get_group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 modification_time = 7;


    pub fn get_modification_time(&self) -> u64 {
        self.modification_time.unwrap_or(0)
    }
    pub fn clear_modification_time(&mut self) {
        self.modification_time = ::std::option::Option::None;
    }

    pub fn has_modification_time(&self) -> bool {
        self.modification_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modification_time(&mut self, v: u64) {
        self.modification_time = ::std::option::Option::Some(v);
    }

    // required uint64 access_time = 8;


    pub fn get_access_time(&self) -> u64 {
        self.access_time.unwrap_or(0)
    }
    pub fn clear_access_time(&mut self) {
        self.access_time = ::std::option::Option::None;
    }

    pub fn has_access_time(&self) -> bool {
        self.access_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_time(&mut self, v: u64) {
        self.access_time = ::std::option::Option::Some(v);
    }

    // optional bytes symlink = 9;


    pub fn get_symlink(&self) -> &[u8] {
        match self.symlink.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_symlink(&mut self) {
        self.symlink.clear();
    }

    pub fn has_symlink(&self) -> bool {
        self.symlink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symlink(&mut self, v: ::std::vec::Vec<u8>) {
        self.symlink = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_symlink(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.symlink.is_none() {
            self.symlink.set_default();
        }
        self.symlink.as_mut().unwrap()
    }

    // Take field
    pub fn take_symlink(&mut self) -> ::std::vec::Vec<u8> {
        self.symlink.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 block_replication = 10;


    pub fn get_block_replication(&self) -> u32 {
        self.block_replication.unwrap_or(0u32)
    }
    pub fn clear_block_replication(&mut self) {
        self.block_replication = ::std::option::Option::None;
    }

    pub fn has_block_replication(&self) -> bool {
        self.block_replication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_replication(&mut self, v: u32) {
        self.block_replication = ::std::option::Option::Some(v);
    }

    // optional uint64 blocksize = 11;


    pub fn get_blocksize(&self) -> u64 {
        self.blocksize.unwrap_or(0u64)
    }
    pub fn clear_blocksize(&mut self) {
        self.blocksize = ::std::option::Option::None;
    }

    pub fn has_blocksize(&self) -> bool {
        self.blocksize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blocksize(&mut self, v: u64) {
        self.blocksize = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.LocatedBlocksProto locations = 12;


    pub fn get_locations(&self) -> &LocatedBlocksProto {
        self.locations.as_ref().unwrap_or_else(|| <LocatedBlocksProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_locations(&mut self) {
        self.locations.clear();
    }

    pub fn has_locations(&self) -> bool {
        self.locations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locations(&mut self, v: LocatedBlocksProto) {
        self.locations = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locations(&mut self) -> &mut LocatedBlocksProto {
        if self.locations.is_none() {
            self.locations.set_default();
        }
        self.locations.as_mut().unwrap()
    }

    // Take field
    pub fn take_locations(&mut self) -> LocatedBlocksProto {
        self.locations.take().unwrap_or_else(|| LocatedBlocksProto::new())
    }

    // optional uint64 fileId = 13;


    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }
    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }

    // optional int32 childrenNum = 14;


    pub fn get_childrenNum(&self) -> i32 {
        self.childrenNum.unwrap_or(-1i32)
    }
    pub fn clear_childrenNum(&mut self) {
        self.childrenNum = ::std::option::Option::None;
    }

    pub fn has_childrenNum(&self) -> bool {
        self.childrenNum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_childrenNum(&mut self, v: i32) {
        self.childrenNum = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.FileEncryptionInfoProto fileEncryptionInfo = 15;


    pub fn get_fileEncryptionInfo(&self) -> &FileEncryptionInfoProto {
        self.fileEncryptionInfo.as_ref().unwrap_or_else(|| <FileEncryptionInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fileEncryptionInfo(&mut self) {
        self.fileEncryptionInfo.clear();
    }

    pub fn has_fileEncryptionInfo(&self) -> bool {
        self.fileEncryptionInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileEncryptionInfo(&mut self, v: FileEncryptionInfoProto) {
        self.fileEncryptionInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileEncryptionInfo(&mut self) -> &mut FileEncryptionInfoProto {
        if self.fileEncryptionInfo.is_none() {
            self.fileEncryptionInfo.set_default();
        }
        self.fileEncryptionInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileEncryptionInfo(&mut self) -> FileEncryptionInfoProto {
        self.fileEncryptionInfo.take().unwrap_or_else(|| FileEncryptionInfoProto::new())
    }

    // optional uint32 storagePolicy = 16;


    pub fn get_storagePolicy(&self) -> u32 {
        self.storagePolicy.unwrap_or(0u32)
    }
    pub fn clear_storagePolicy(&mut self) {
        self.storagePolicy = ::std::option::Option::None;
    }

    pub fn has_storagePolicy(&self) -> bool {
        self.storagePolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagePolicy(&mut self, v: u32) {
        self.storagePolicy = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.ErasureCodingPolicyProto ecPolicy = 17;


    pub fn get_ecPolicy(&self) -> &ErasureCodingPolicyProto {
        self.ecPolicy.as_ref().unwrap_or_else(|| <ErasureCodingPolicyProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ecPolicy(&mut self) {
        self.ecPolicy.clear();
    }

    pub fn has_ecPolicy(&self) -> bool {
        self.ecPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ecPolicy(&mut self, v: ErasureCodingPolicyProto) {
        self.ecPolicy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ecPolicy(&mut self) -> &mut ErasureCodingPolicyProto {
        if self.ecPolicy.is_none() {
            self.ecPolicy.set_default();
        }
        self.ecPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_ecPolicy(&mut self) -> ErasureCodingPolicyProto {
        self.ecPolicy.take().unwrap_or_else(|| ErasureCodingPolicyProto::new())
    }

    // optional uint32 flags = 18;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0u32)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for HdfsFileStatusProto {
    fn is_initialized(&self) -> bool {
        if self.fileType.is_none() {
            return false;
        }
        if self.path.is_none() {
            return false;
        }
        if self.length.is_none() {
            return false;
        }
        if self.permission.is_none() {
            return false;
        }
        if self.owner.is_none() {
            return false;
        }
        if self.group.is_none() {
            return false;
        }
        if self.modification_time.is_none() {
            return false;
        }
        if self.access_time.is_none() {
            return false;
        }
        for v in &self.permission {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.locations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fileEncryptionInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ecPolicy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.fileType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.permission)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.owner)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.group)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.modification_time = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.access_time = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.symlink)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.block_replication = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blocksize = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.locations)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.childrenNum = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fileEncryptionInfo)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.storagePolicy = ::std::option::Option::Some(tmp);
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ecPolicy)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fileType {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.permission.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.owner.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.modification_time {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.access_time {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.symlink.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        if let Some(v) = self.block_replication {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blocksize {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.locations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.childrenNum {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fileEncryptionInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.storagePolicy {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ecPolicy.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fileType {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.length {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.permission.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.owner.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.group.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.modification_time {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.access_time {
            os.write_uint64(8, v)?;
        }
        if let Some(ref v) = self.symlink.as_ref() {
            os.write_bytes(9, &v)?;
        }
        if let Some(v) = self.block_replication {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.blocksize {
            os.write_uint64(11, v)?;
        }
        if let Some(ref v) = self.locations.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.fileId {
            os.write_uint64(13, v)?;
        }
        if let Some(v) = self.childrenNum {
            os.write_int32(14, v)?;
        }
        if let Some(ref v) = self.fileEncryptionInfo.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.storagePolicy {
            os.write_uint32(16, v)?;
        }
        if let Some(ref v) = self.ecPolicy.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(18, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HdfsFileStatusProto {
        HdfsFileStatusProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HdfsFileStatusProto_FileType>>(
                "fileType",
                |m: &HdfsFileStatusProto| { &m.fileType },
                |m: &mut HdfsFileStatusProto| { &mut m.fileType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "path",
                |m: &HdfsFileStatusProto| { &m.path },
                |m: &mut HdfsFileStatusProto| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "length",
                |m: &HdfsFileStatusProto| { &m.length },
                |m: &mut HdfsFileStatusProto| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::acl::FsPermissionProto>>(
                "permission",
                |m: &HdfsFileStatusProto| { &m.permission },
                |m: &mut HdfsFileStatusProto| { &mut m.permission },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "owner",
                |m: &HdfsFileStatusProto| { &m.owner },
                |m: &mut HdfsFileStatusProto| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "group",
                |m: &HdfsFileStatusProto| { &m.group },
                |m: &mut HdfsFileStatusProto| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "modification_time",
                |m: &HdfsFileStatusProto| { &m.modification_time },
                |m: &mut HdfsFileStatusProto| { &mut m.modification_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "access_time",
                |m: &HdfsFileStatusProto| { &m.access_time },
                |m: &mut HdfsFileStatusProto| { &mut m.access_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "symlink",
                |m: &HdfsFileStatusProto| { &m.symlink },
                |m: &mut HdfsFileStatusProto| { &mut m.symlink },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "block_replication",
                |m: &HdfsFileStatusProto| { &m.block_replication },
                |m: &mut HdfsFileStatusProto| { &mut m.block_replication },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "blocksize",
                |m: &HdfsFileStatusProto| { &m.blocksize },
                |m: &mut HdfsFileStatusProto| { &mut m.blocksize },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocatedBlocksProto>>(
                "locations",
                |m: &HdfsFileStatusProto| { &m.locations },
                |m: &mut HdfsFileStatusProto| { &mut m.locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fileId",
                |m: &HdfsFileStatusProto| { &m.fileId },
                |m: &mut HdfsFileStatusProto| { &mut m.fileId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "childrenNum",
                |m: &HdfsFileStatusProto| { &m.childrenNum },
                |m: &mut HdfsFileStatusProto| { &mut m.childrenNum },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileEncryptionInfoProto>>(
                "fileEncryptionInfo",
                |m: &HdfsFileStatusProto| { &m.fileEncryptionInfo },
                |m: &mut HdfsFileStatusProto| { &mut m.fileEncryptionInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "storagePolicy",
                |m: &HdfsFileStatusProto| { &m.storagePolicy },
                |m: &mut HdfsFileStatusProto| { &mut m.storagePolicy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ErasureCodingPolicyProto>>(
                "ecPolicy",
                |m: &HdfsFileStatusProto| { &m.ecPolicy },
                |m: &mut HdfsFileStatusProto| { &mut m.ecPolicy },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &HdfsFileStatusProto| { &m.flags },
                |m: &mut HdfsFileStatusProto| { &mut m.flags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HdfsFileStatusProto>(
                "HdfsFileStatusProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HdfsFileStatusProto {
        static instance: ::protobuf::rt::LazyV2<HdfsFileStatusProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HdfsFileStatusProto::new)
    }
}

impl ::protobuf::Clear for HdfsFileStatusProto {
    fn clear(&mut self) {
        self.fileType = ::std::option::Option::None;
        self.path.clear();
        self.length = ::std::option::Option::None;
        self.permission.clear();
        self.owner.clear();
        self.group.clear();
        self.modification_time = ::std::option::Option::None;
        self.access_time = ::std::option::Option::None;
        self.symlink.clear();
        self.block_replication = ::std::option::Option::None;
        self.blocksize = ::std::option::Option::None;
        self.locations.clear();
        self.fileId = ::std::option::Option::None;
        self.childrenNum = ::std::option::Option::None;
        self.fileEncryptionInfo.clear();
        self.storagePolicy = ::std::option::Option::None;
        self.ecPolicy.clear();
        self.flags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HdfsFileStatusProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HdfsFileStatusProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum HdfsFileStatusProto_FileType {
    IS_DIR = 1,
    IS_FILE = 2,
    IS_SYMLINK = 3,
}

impl ::protobuf::ProtobufEnum for HdfsFileStatusProto_FileType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HdfsFileStatusProto_FileType> {
        match value {
            1 => ::std::option::Option::Some(HdfsFileStatusProto_FileType::IS_DIR),
            2 => ::std::option::Option::Some(HdfsFileStatusProto_FileType::IS_FILE),
            3 => ::std::option::Option::Some(HdfsFileStatusProto_FileType::IS_SYMLINK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HdfsFileStatusProto_FileType] = &[
            HdfsFileStatusProto_FileType::IS_DIR,
            HdfsFileStatusProto_FileType::IS_FILE,
            HdfsFileStatusProto_FileType::IS_SYMLINK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<HdfsFileStatusProto_FileType>("HdfsFileStatusProto.FileType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for HdfsFileStatusProto_FileType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for HdfsFileStatusProto_FileType {
    fn default() -> Self {
        HdfsFileStatusProto_FileType::IS_DIR
    }
}

impl ::protobuf::reflect::ProtobufValue for HdfsFileStatusProto_FileType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum HdfsFileStatusProto_Flags {
    HAS_ACL = 1,
    HAS_CRYPT = 2,
    HAS_EC = 4,
    SNAPSHOT_ENABLED = 8,
}

impl ::protobuf::ProtobufEnum for HdfsFileStatusProto_Flags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HdfsFileStatusProto_Flags> {
        match value {
            1 => ::std::option::Option::Some(HdfsFileStatusProto_Flags::HAS_ACL),
            2 => ::std::option::Option::Some(HdfsFileStatusProto_Flags::HAS_CRYPT),
            4 => ::std::option::Option::Some(HdfsFileStatusProto_Flags::HAS_EC),
            8 => ::std::option::Option::Some(HdfsFileStatusProto_Flags::SNAPSHOT_ENABLED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HdfsFileStatusProto_Flags] = &[
            HdfsFileStatusProto_Flags::HAS_ACL,
            HdfsFileStatusProto_Flags::HAS_CRYPT,
            HdfsFileStatusProto_Flags::HAS_EC,
            HdfsFileStatusProto_Flags::SNAPSHOT_ENABLED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<HdfsFileStatusProto_Flags>("HdfsFileStatusProto.Flags", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for HdfsFileStatusProto_Flags {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for HdfsFileStatusProto_Flags {
    fn default() -> Self {
        HdfsFileStatusProto_Flags::HAS_ACL
    }
}

impl ::protobuf::reflect::ProtobufValue for HdfsFileStatusProto_Flags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockChecksumOptionsProto {
    // message fields
    blockChecksumType: ::std::option::Option<BlockChecksumTypeProto>,
    stripeLength: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockChecksumOptionsProto {
    fn default() -> &'a BlockChecksumOptionsProto {
        <BlockChecksumOptionsProto as ::protobuf::Message>::default_instance()
    }
}

impl BlockChecksumOptionsProto {
    pub fn new() -> BlockChecksumOptionsProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.BlockChecksumTypeProto blockChecksumType = 1;


    pub fn get_blockChecksumType(&self) -> BlockChecksumTypeProto {
        self.blockChecksumType.unwrap_or(BlockChecksumTypeProto::MD5CRC)
    }
    pub fn clear_blockChecksumType(&mut self) {
        self.blockChecksumType = ::std::option::Option::None;
    }

    pub fn has_blockChecksumType(&self) -> bool {
        self.blockChecksumType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockChecksumType(&mut self, v: BlockChecksumTypeProto) {
        self.blockChecksumType = ::std::option::Option::Some(v);
    }

    // optional uint64 stripeLength = 2;


    pub fn get_stripeLength(&self) -> u64 {
        self.stripeLength.unwrap_or(0)
    }
    pub fn clear_stripeLength(&mut self) {
        self.stripeLength = ::std::option::Option::None;
    }

    pub fn has_stripeLength(&self) -> bool {
        self.stripeLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stripeLength(&mut self, v: u64) {
        self.stripeLength = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BlockChecksumOptionsProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.blockChecksumType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.stripeLength = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.blockChecksumType {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.stripeLength {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.blockChecksumType {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.stripeLength {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockChecksumOptionsProto {
        BlockChecksumOptionsProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BlockChecksumTypeProto>>(
                "blockChecksumType",
                |m: &BlockChecksumOptionsProto| { &m.blockChecksumType },
                |m: &mut BlockChecksumOptionsProto| { &mut m.blockChecksumType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "stripeLength",
                |m: &BlockChecksumOptionsProto| { &m.stripeLength },
                |m: &mut BlockChecksumOptionsProto| { &mut m.stripeLength },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockChecksumOptionsProto>(
                "BlockChecksumOptionsProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockChecksumOptionsProto {
        static instance: ::protobuf::rt::LazyV2<BlockChecksumOptionsProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockChecksumOptionsProto::new)
    }
}

impl ::protobuf::Clear for BlockChecksumOptionsProto {
    fn clear(&mut self) {
        self.blockChecksumType = ::std::option::Option::None;
        self.stripeLength = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockChecksumOptionsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockChecksumOptionsProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FsServerDefaultsProto {
    // message fields
    blockSize: ::std::option::Option<u64>,
    bytesPerChecksum: ::std::option::Option<u32>,
    writePacketSize: ::std::option::Option<u32>,
    replication: ::std::option::Option<u32>,
    fileBufferSize: ::std::option::Option<u32>,
    encryptDataTransfer: ::std::option::Option<bool>,
    trashInterval: ::std::option::Option<u64>,
    checksumType: ::std::option::Option<ChecksumTypeProto>,
    keyProviderUri: ::protobuf::SingularField<::std::string::String>,
    policyId: ::std::option::Option<u32>,
    snapshotTrashRootEnabled: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FsServerDefaultsProto {
    fn default() -> &'a FsServerDefaultsProto {
        <FsServerDefaultsProto as ::protobuf::Message>::default_instance()
    }
}

impl FsServerDefaultsProto {
    pub fn new() -> FsServerDefaultsProto {
        ::std::default::Default::default()
    }

    // required uint64 blockSize = 1;


    pub fn get_blockSize(&self) -> u64 {
        self.blockSize.unwrap_or(0)
    }
    pub fn clear_blockSize(&mut self) {
        self.blockSize = ::std::option::Option::None;
    }

    pub fn has_blockSize(&self) -> bool {
        self.blockSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockSize(&mut self, v: u64) {
        self.blockSize = ::std::option::Option::Some(v);
    }

    // required uint32 bytesPerChecksum = 2;


    pub fn get_bytesPerChecksum(&self) -> u32 {
        self.bytesPerChecksum.unwrap_or(0)
    }
    pub fn clear_bytesPerChecksum(&mut self) {
        self.bytesPerChecksum = ::std::option::Option::None;
    }

    pub fn has_bytesPerChecksum(&self) -> bool {
        self.bytesPerChecksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesPerChecksum(&mut self, v: u32) {
        self.bytesPerChecksum = ::std::option::Option::Some(v);
    }

    // required uint32 writePacketSize = 3;


    pub fn get_writePacketSize(&self) -> u32 {
        self.writePacketSize.unwrap_or(0)
    }
    pub fn clear_writePacketSize(&mut self) {
        self.writePacketSize = ::std::option::Option::None;
    }

    pub fn has_writePacketSize(&self) -> bool {
        self.writePacketSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_writePacketSize(&mut self, v: u32) {
        self.writePacketSize = ::std::option::Option::Some(v);
    }

    // required uint32 replication = 4;


    pub fn get_replication(&self) -> u32 {
        self.replication.unwrap_or(0)
    }
    pub fn clear_replication(&mut self) {
        self.replication = ::std::option::Option::None;
    }

    pub fn has_replication(&self) -> bool {
        self.replication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replication(&mut self, v: u32) {
        self.replication = ::std::option::Option::Some(v);
    }

    // required uint32 fileBufferSize = 5;


    pub fn get_fileBufferSize(&self) -> u32 {
        self.fileBufferSize.unwrap_or(0)
    }
    pub fn clear_fileBufferSize(&mut self) {
        self.fileBufferSize = ::std::option::Option::None;
    }

    pub fn has_fileBufferSize(&self) -> bool {
        self.fileBufferSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileBufferSize(&mut self, v: u32) {
        self.fileBufferSize = ::std::option::Option::Some(v);
    }

    // optional bool encryptDataTransfer = 6;


    pub fn get_encryptDataTransfer(&self) -> bool {
        self.encryptDataTransfer.unwrap_or(false)
    }
    pub fn clear_encryptDataTransfer(&mut self) {
        self.encryptDataTransfer = ::std::option::Option::None;
    }

    pub fn has_encryptDataTransfer(&self) -> bool {
        self.encryptDataTransfer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryptDataTransfer(&mut self, v: bool) {
        self.encryptDataTransfer = ::std::option::Option::Some(v);
    }

    // optional uint64 trashInterval = 7;


    pub fn get_trashInterval(&self) -> u64 {
        self.trashInterval.unwrap_or(0u64)
    }
    pub fn clear_trashInterval(&mut self) {
        self.trashInterval = ::std::option::Option::None;
    }

    pub fn has_trashInterval(&self) -> bool {
        self.trashInterval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trashInterval(&mut self, v: u64) {
        self.trashInterval = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.ChecksumTypeProto checksumType = 8;


    pub fn get_checksumType(&self) -> ChecksumTypeProto {
        self.checksumType.unwrap_or(ChecksumTypeProto::CHECKSUM_CRC32)
    }
    pub fn clear_checksumType(&mut self) {
        self.checksumType = ::std::option::Option::None;
    }

    pub fn has_checksumType(&self) -> bool {
        self.checksumType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checksumType(&mut self, v: ChecksumTypeProto) {
        self.checksumType = ::std::option::Option::Some(v);
    }

    // optional string keyProviderUri = 9;


    pub fn get_keyProviderUri(&self) -> &str {
        match self.keyProviderUri.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_keyProviderUri(&mut self) {
        self.keyProviderUri.clear();
    }

    pub fn has_keyProviderUri(&self) -> bool {
        self.keyProviderUri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyProviderUri(&mut self, v: ::std::string::String) {
        self.keyProviderUri = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyProviderUri(&mut self) -> &mut ::std::string::String {
        if self.keyProviderUri.is_none() {
            self.keyProviderUri.set_default();
        }
        self.keyProviderUri.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyProviderUri(&mut self) -> ::std::string::String {
        self.keyProviderUri.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 policyId = 10;


    pub fn get_policyId(&self) -> u32 {
        self.policyId.unwrap_or(0u32)
    }
    pub fn clear_policyId(&mut self) {
        self.policyId = ::std::option::Option::None;
    }

    pub fn has_policyId(&self) -> bool {
        self.policyId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_policyId(&mut self, v: u32) {
        self.policyId = ::std::option::Option::Some(v);
    }

    // optional bool snapshotTrashRootEnabled = 11;


    pub fn get_snapshotTrashRootEnabled(&self) -> bool {
        self.snapshotTrashRootEnabled.unwrap_or(false)
    }
    pub fn clear_snapshotTrashRootEnabled(&mut self) {
        self.snapshotTrashRootEnabled = ::std::option::Option::None;
    }

    pub fn has_snapshotTrashRootEnabled(&self) -> bool {
        self.snapshotTrashRootEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotTrashRootEnabled(&mut self, v: bool) {
        self.snapshotTrashRootEnabled = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for FsServerDefaultsProto {
    fn is_initialized(&self) -> bool {
        if self.blockSize.is_none() {
            return false;
        }
        if self.bytesPerChecksum.is_none() {
            return false;
        }
        if self.writePacketSize.is_none() {
            return false;
        }
        if self.replication.is_none() {
            return false;
        }
        if self.fileBufferSize.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockSize = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bytesPerChecksum = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.writePacketSize = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.replication = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fileBufferSize = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.encryptDataTransfer = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.trashInterval = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.checksumType, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.keyProviderUri)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.policyId = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.snapshotTrashRootEnabled = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.blockSize {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytesPerChecksum {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.writePacketSize {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.replication {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fileBufferSize {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.encryptDataTransfer {
            my_size += 2;
        }
        if let Some(v) = self.trashInterval {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.checksumType {
            my_size += ::protobuf::rt::enum_size(8, v);
        }
        if let Some(ref v) = self.keyProviderUri.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.policyId {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.snapshotTrashRootEnabled {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.blockSize {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.bytesPerChecksum {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.writePacketSize {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.replication {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.fileBufferSize {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.encryptDataTransfer {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.trashInterval {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.checksumType {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.keyProviderUri.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(v) = self.policyId {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.snapshotTrashRootEnabled {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FsServerDefaultsProto {
        FsServerDefaultsProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "blockSize",
                |m: &FsServerDefaultsProto| { &m.blockSize },
                |m: &mut FsServerDefaultsProto| { &mut m.blockSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "bytesPerChecksum",
                |m: &FsServerDefaultsProto| { &m.bytesPerChecksum },
                |m: &mut FsServerDefaultsProto| { &mut m.bytesPerChecksum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "writePacketSize",
                |m: &FsServerDefaultsProto| { &m.writePacketSize },
                |m: &mut FsServerDefaultsProto| { &mut m.writePacketSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "replication",
                |m: &FsServerDefaultsProto| { &m.replication },
                |m: &mut FsServerDefaultsProto| { &mut m.replication },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "fileBufferSize",
                |m: &FsServerDefaultsProto| { &m.fileBufferSize },
                |m: &mut FsServerDefaultsProto| { &mut m.fileBufferSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "encryptDataTransfer",
                |m: &FsServerDefaultsProto| { &m.encryptDataTransfer },
                |m: &mut FsServerDefaultsProto| { &mut m.encryptDataTransfer },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "trashInterval",
                |m: &FsServerDefaultsProto| { &m.trashInterval },
                |m: &mut FsServerDefaultsProto| { &mut m.trashInterval },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ChecksumTypeProto>>(
                "checksumType",
                |m: &FsServerDefaultsProto| { &m.checksumType },
                |m: &mut FsServerDefaultsProto| { &mut m.checksumType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "keyProviderUri",
                |m: &FsServerDefaultsProto| { &m.keyProviderUri },
                |m: &mut FsServerDefaultsProto| { &mut m.keyProviderUri },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "policyId",
                |m: &FsServerDefaultsProto| { &m.policyId },
                |m: &mut FsServerDefaultsProto| { &mut m.policyId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "snapshotTrashRootEnabled",
                |m: &FsServerDefaultsProto| { &m.snapshotTrashRootEnabled },
                |m: &mut FsServerDefaultsProto| { &mut m.snapshotTrashRootEnabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FsServerDefaultsProto>(
                "FsServerDefaultsProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FsServerDefaultsProto {
        static instance: ::protobuf::rt::LazyV2<FsServerDefaultsProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FsServerDefaultsProto::new)
    }
}

impl ::protobuf::Clear for FsServerDefaultsProto {
    fn clear(&mut self) {
        self.blockSize = ::std::option::Option::None;
        self.bytesPerChecksum = ::std::option::Option::None;
        self.writePacketSize = ::std::option::Option::None;
        self.replication = ::std::option::Option::None;
        self.fileBufferSize = ::std::option::Option::None;
        self.encryptDataTransfer = ::std::option::Option::None;
        self.trashInterval = ::std::option::Option::None;
        self.checksumType = ::std::option::Option::None;
        self.keyProviderUri.clear();
        self.policyId = ::std::option::Option::None;
        self.snapshotTrashRootEnabled = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FsServerDefaultsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FsServerDefaultsProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DirectoryListingProto {
    // message fields
    pub partialListing: ::protobuf::RepeatedField<HdfsFileStatusProto>,
    remainingEntries: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DirectoryListingProto {
    fn default() -> &'a DirectoryListingProto {
        <DirectoryListingProto as ::protobuf::Message>::default_instance()
    }
}

impl DirectoryListingProto {
    pub fn new() -> DirectoryListingProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.HdfsFileStatusProto partialListing = 1;


    pub fn get_partialListing(&self) -> &[HdfsFileStatusProto] {
        &self.partialListing
    }
    pub fn clear_partialListing(&mut self) {
        self.partialListing.clear();
    }

    // Param is passed by value, moved
    pub fn set_partialListing(&mut self, v: ::protobuf::RepeatedField<HdfsFileStatusProto>) {
        self.partialListing = v;
    }

    // Mutable pointer to the field.
    pub fn mut_partialListing(&mut self) -> &mut ::protobuf::RepeatedField<HdfsFileStatusProto> {
        &mut self.partialListing
    }

    // Take field
    pub fn take_partialListing(&mut self) -> ::protobuf::RepeatedField<HdfsFileStatusProto> {
        ::std::mem::replace(&mut self.partialListing, ::protobuf::RepeatedField::new())
    }

    // required uint32 remainingEntries = 2;


    pub fn get_remainingEntries(&self) -> u32 {
        self.remainingEntries.unwrap_or(0)
    }
    pub fn clear_remainingEntries(&mut self) {
        self.remainingEntries = ::std::option::Option::None;
    }

    pub fn has_remainingEntries(&self) -> bool {
        self.remainingEntries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remainingEntries(&mut self, v: u32) {
        self.remainingEntries = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DirectoryListingProto {
    fn is_initialized(&self) -> bool {
        if self.remainingEntries.is_none() {
            return false;
        }
        for v in &self.partialListing {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.partialListing)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.remainingEntries = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.partialListing {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.remainingEntries {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.partialListing {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.remainingEntries {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DirectoryListingProto {
        DirectoryListingProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HdfsFileStatusProto>>(
                "partialListing",
                |m: &DirectoryListingProto| { &m.partialListing },
                |m: &mut DirectoryListingProto| { &mut m.partialListing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "remainingEntries",
                |m: &DirectoryListingProto| { &m.remainingEntries },
                |m: &mut DirectoryListingProto| { &mut m.remainingEntries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DirectoryListingProto>(
                "DirectoryListingProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DirectoryListingProto {
        static instance: ::protobuf::rt::LazyV2<DirectoryListingProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DirectoryListingProto::new)
    }
}

impl ::protobuf::Clear for DirectoryListingProto {
    fn clear(&mut self) {
        self.partialListing.clear();
        self.remainingEntries = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirectoryListingProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectoryListingProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoteExceptionProto {
    // message fields
    className: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoteExceptionProto {
    fn default() -> &'a RemoteExceptionProto {
        <RemoteExceptionProto as ::protobuf::Message>::default_instance()
    }
}

impl RemoteExceptionProto {
    pub fn new() -> RemoteExceptionProto {
        ::std::default::Default::default()
    }

    // required string className = 1;


    pub fn get_className(&self) -> &str {
        match self.className.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_className(&mut self) {
        self.className.clear();
    }

    pub fn has_className(&self) -> bool {
        self.className.is_some()
    }

    // Param is passed by value, moved
    pub fn set_className(&mut self, v: ::std::string::String) {
        self.className = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_className(&mut self) -> &mut ::std::string::String {
        if self.className.is_none() {
            self.className.set_default();
        }
        self.className.as_mut().unwrap()
    }

    // Take field
    pub fn take_className(&mut self) -> ::std::string::String {
        self.className.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 2;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for RemoteExceptionProto {
    fn is_initialized(&self) -> bool {
        if self.className.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.className)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.className.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.className.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoteExceptionProto {
        RemoteExceptionProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "className",
                |m: &RemoteExceptionProto| { &m.className },
                |m: &mut RemoteExceptionProto| { &mut m.className },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &RemoteExceptionProto| { &m.message },
                |m: &mut RemoteExceptionProto| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoteExceptionProto>(
                "RemoteExceptionProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RemoteExceptionProto {
        static instance: ::protobuf::rt::LazyV2<RemoteExceptionProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoteExceptionProto::new)
    }
}

impl ::protobuf::Clear for RemoteExceptionProto {
    fn clear(&mut self) {
        self.className.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoteExceptionProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoteExceptionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchedDirectoryListingProto {
    // message fields
    pub partialListing: ::protobuf::RepeatedField<HdfsFileStatusProto>,
    parentIdx: ::std::option::Option<u32>,
    pub exception: ::protobuf::SingularPtrField<RemoteExceptionProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchedDirectoryListingProto {
    fn default() -> &'a BatchedDirectoryListingProto {
        <BatchedDirectoryListingProto as ::protobuf::Message>::default_instance()
    }
}

impl BatchedDirectoryListingProto {
    pub fn new() -> BatchedDirectoryListingProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.HdfsFileStatusProto partialListing = 1;


    pub fn get_partialListing(&self) -> &[HdfsFileStatusProto] {
        &self.partialListing
    }
    pub fn clear_partialListing(&mut self) {
        self.partialListing.clear();
    }

    // Param is passed by value, moved
    pub fn set_partialListing(&mut self, v: ::protobuf::RepeatedField<HdfsFileStatusProto>) {
        self.partialListing = v;
    }

    // Mutable pointer to the field.
    pub fn mut_partialListing(&mut self) -> &mut ::protobuf::RepeatedField<HdfsFileStatusProto> {
        &mut self.partialListing
    }

    // Take field
    pub fn take_partialListing(&mut self) -> ::protobuf::RepeatedField<HdfsFileStatusProto> {
        ::std::mem::replace(&mut self.partialListing, ::protobuf::RepeatedField::new())
    }

    // required uint32 parentIdx = 2;


    pub fn get_parentIdx(&self) -> u32 {
        self.parentIdx.unwrap_or(0)
    }
    pub fn clear_parentIdx(&mut self) {
        self.parentIdx = ::std::option::Option::None;
    }

    pub fn has_parentIdx(&self) -> bool {
        self.parentIdx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parentIdx(&mut self, v: u32) {
        self.parentIdx = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.RemoteExceptionProto exception = 3;


    pub fn get_exception(&self) -> &RemoteExceptionProto {
        self.exception.as_ref().unwrap_or_else(|| <RemoteExceptionProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_exception(&mut self) {
        self.exception.clear();
    }

    pub fn has_exception(&self) -> bool {
        self.exception.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exception(&mut self, v: RemoteExceptionProto) {
        self.exception = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exception(&mut self) -> &mut RemoteExceptionProto {
        if self.exception.is_none() {
            self.exception.set_default();
        }
        self.exception.as_mut().unwrap()
    }

    // Take field
    pub fn take_exception(&mut self) -> RemoteExceptionProto {
        self.exception.take().unwrap_or_else(|| RemoteExceptionProto::new())
    }
}

impl ::protobuf::Message for BatchedDirectoryListingProto {
    fn is_initialized(&self) -> bool {
        if self.parentIdx.is_none() {
            return false;
        }
        for v in &self.partialListing {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exception {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.partialListing)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.parentIdx = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exception)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.partialListing {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.parentIdx {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.exception.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.partialListing {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.parentIdx {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.exception.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchedDirectoryListingProto {
        BatchedDirectoryListingProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HdfsFileStatusProto>>(
                "partialListing",
                |m: &BatchedDirectoryListingProto| { &m.partialListing },
                |m: &mut BatchedDirectoryListingProto| { &mut m.partialListing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "parentIdx",
                |m: &BatchedDirectoryListingProto| { &m.parentIdx },
                |m: &mut BatchedDirectoryListingProto| { &mut m.parentIdx },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RemoteExceptionProto>>(
                "exception",
                |m: &BatchedDirectoryListingProto| { &m.exception },
                |m: &mut BatchedDirectoryListingProto| { &mut m.exception },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchedDirectoryListingProto>(
                "BatchedDirectoryListingProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchedDirectoryListingProto {
        static instance: ::protobuf::rt::LazyV2<BatchedDirectoryListingProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchedDirectoryListingProto::new)
    }
}

impl ::protobuf::Clear for BatchedDirectoryListingProto {
    fn clear(&mut self) {
        self.partialListing.clear();
        self.parentIdx = ::std::option::Option::None;
        self.exception.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchedDirectoryListingProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchedDirectoryListingProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshottableDirectoryStatusProto {
    // message fields
    pub dirStatus: ::protobuf::SingularPtrField<HdfsFileStatusProto>,
    snapshot_quota: ::std::option::Option<u32>,
    snapshot_number: ::std::option::Option<u32>,
    parent_fullpath: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshottableDirectoryStatusProto {
    fn default() -> &'a SnapshottableDirectoryStatusProto {
        <SnapshottableDirectoryStatusProto as ::protobuf::Message>::default_instance()
    }
}

impl SnapshottableDirectoryStatusProto {
    pub fn new() -> SnapshottableDirectoryStatusProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.HdfsFileStatusProto dirStatus = 1;


    pub fn get_dirStatus(&self) -> &HdfsFileStatusProto {
        self.dirStatus.as_ref().unwrap_or_else(|| <HdfsFileStatusProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dirStatus(&mut self) {
        self.dirStatus.clear();
    }

    pub fn has_dirStatus(&self) -> bool {
        self.dirStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dirStatus(&mut self, v: HdfsFileStatusProto) {
        self.dirStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dirStatus(&mut self) -> &mut HdfsFileStatusProto {
        if self.dirStatus.is_none() {
            self.dirStatus.set_default();
        }
        self.dirStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_dirStatus(&mut self) -> HdfsFileStatusProto {
        self.dirStatus.take().unwrap_or_else(|| HdfsFileStatusProto::new())
    }

    // required uint32 snapshot_quota = 2;


    pub fn get_snapshot_quota(&self) -> u32 {
        self.snapshot_quota.unwrap_or(0)
    }
    pub fn clear_snapshot_quota(&mut self) {
        self.snapshot_quota = ::std::option::Option::None;
    }

    pub fn has_snapshot_quota(&self) -> bool {
        self.snapshot_quota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshot_quota(&mut self, v: u32) {
        self.snapshot_quota = ::std::option::Option::Some(v);
    }

    // required uint32 snapshot_number = 3;


    pub fn get_snapshot_number(&self) -> u32 {
        self.snapshot_number.unwrap_or(0)
    }
    pub fn clear_snapshot_number(&mut self) {
        self.snapshot_number = ::std::option::Option::None;
    }

    pub fn has_snapshot_number(&self) -> bool {
        self.snapshot_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshot_number(&mut self, v: u32) {
        self.snapshot_number = ::std::option::Option::Some(v);
    }

    // required bytes parent_fullpath = 4;


    pub fn get_parent_fullpath(&self) -> &[u8] {
        match self.parent_fullpath.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_parent_fullpath(&mut self) {
        self.parent_fullpath.clear();
    }

    pub fn has_parent_fullpath(&self) -> bool {
        self.parent_fullpath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_fullpath(&mut self, v: ::std::vec::Vec<u8>) {
        self.parent_fullpath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_fullpath(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.parent_fullpath.is_none() {
            self.parent_fullpath.set_default();
        }
        self.parent_fullpath.as_mut().unwrap()
    }

    // Take field
    pub fn take_parent_fullpath(&mut self) -> ::std::vec::Vec<u8> {
        self.parent_fullpath.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SnapshottableDirectoryStatusProto {
    fn is_initialized(&self) -> bool {
        if self.dirStatus.is_none() {
            return false;
        }
        if self.snapshot_quota.is_none() {
            return false;
        }
        if self.snapshot_number.is_none() {
            return false;
        }
        if self.parent_fullpath.is_none() {
            return false;
        }
        for v in &self.dirStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dirStatus)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.snapshot_quota = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.snapshot_number = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.parent_fullpath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dirStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.snapshot_quota {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.snapshot_number {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.parent_fullpath.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dirStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.snapshot_quota {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.snapshot_number {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.parent_fullpath.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshottableDirectoryStatusProto {
        SnapshottableDirectoryStatusProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HdfsFileStatusProto>>(
                "dirStatus",
                |m: &SnapshottableDirectoryStatusProto| { &m.dirStatus },
                |m: &mut SnapshottableDirectoryStatusProto| { &mut m.dirStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "snapshot_quota",
                |m: &SnapshottableDirectoryStatusProto| { &m.snapshot_quota },
                |m: &mut SnapshottableDirectoryStatusProto| { &mut m.snapshot_quota },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "snapshot_number",
                |m: &SnapshottableDirectoryStatusProto| { &m.snapshot_number },
                |m: &mut SnapshottableDirectoryStatusProto| { &mut m.snapshot_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "parent_fullpath",
                |m: &SnapshottableDirectoryStatusProto| { &m.parent_fullpath },
                |m: &mut SnapshottableDirectoryStatusProto| { &mut m.parent_fullpath },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SnapshottableDirectoryStatusProto>(
                "SnapshottableDirectoryStatusProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SnapshottableDirectoryStatusProto {
        static instance: ::protobuf::rt::LazyV2<SnapshottableDirectoryStatusProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SnapshottableDirectoryStatusProto::new)
    }
}

impl ::protobuf::Clear for SnapshottableDirectoryStatusProto {
    fn clear(&mut self) {
        self.dirStatus.clear();
        self.snapshot_quota = ::std::option::Option::None;
        self.snapshot_number = ::std::option::Option::None;
        self.parent_fullpath.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshottableDirectoryStatusProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshottableDirectoryStatusProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotStatusProto {
    // message fields
    pub dirStatus: ::protobuf::SingularPtrField<HdfsFileStatusProto>,
    snapshotID: ::std::option::Option<u32>,
    parent_fullpath: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    isDeleted: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotStatusProto {
    fn default() -> &'a SnapshotStatusProto {
        <SnapshotStatusProto as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotStatusProto {
    pub fn new() -> SnapshotStatusProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.HdfsFileStatusProto dirStatus = 1;


    pub fn get_dirStatus(&self) -> &HdfsFileStatusProto {
        self.dirStatus.as_ref().unwrap_or_else(|| <HdfsFileStatusProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dirStatus(&mut self) {
        self.dirStatus.clear();
    }

    pub fn has_dirStatus(&self) -> bool {
        self.dirStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dirStatus(&mut self, v: HdfsFileStatusProto) {
        self.dirStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dirStatus(&mut self) -> &mut HdfsFileStatusProto {
        if self.dirStatus.is_none() {
            self.dirStatus.set_default();
        }
        self.dirStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_dirStatus(&mut self) -> HdfsFileStatusProto {
        self.dirStatus.take().unwrap_or_else(|| HdfsFileStatusProto::new())
    }

    // required uint32 snapshotID = 2;


    pub fn get_snapshotID(&self) -> u32 {
        self.snapshotID.unwrap_or(0)
    }
    pub fn clear_snapshotID(&mut self) {
        self.snapshotID = ::std::option::Option::None;
    }

    pub fn has_snapshotID(&self) -> bool {
        self.snapshotID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotID(&mut self, v: u32) {
        self.snapshotID = ::std::option::Option::Some(v);
    }

    // required bytes parent_fullpath = 3;


    pub fn get_parent_fullpath(&self) -> &[u8] {
        match self.parent_fullpath.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_parent_fullpath(&mut self) {
        self.parent_fullpath.clear();
    }

    pub fn has_parent_fullpath(&self) -> bool {
        self.parent_fullpath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_fullpath(&mut self, v: ::std::vec::Vec<u8>) {
        self.parent_fullpath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_fullpath(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.parent_fullpath.is_none() {
            self.parent_fullpath.set_default();
        }
        self.parent_fullpath.as_mut().unwrap()
    }

    // Take field
    pub fn take_parent_fullpath(&mut self) -> ::std::vec::Vec<u8> {
        self.parent_fullpath.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bool isDeleted = 4;


    pub fn get_isDeleted(&self) -> bool {
        self.isDeleted.unwrap_or(false)
    }
    pub fn clear_isDeleted(&mut self) {
        self.isDeleted = ::std::option::Option::None;
    }

    pub fn has_isDeleted(&self) -> bool {
        self.isDeleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isDeleted(&mut self, v: bool) {
        self.isDeleted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SnapshotStatusProto {
    fn is_initialized(&self) -> bool {
        if self.dirStatus.is_none() {
            return false;
        }
        if self.snapshotID.is_none() {
            return false;
        }
        if self.parent_fullpath.is_none() {
            return false;
        }
        if self.isDeleted.is_none() {
            return false;
        }
        for v in &self.dirStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dirStatus)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.snapshotID = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.parent_fullpath)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isDeleted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dirStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.snapshotID {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.parent_fullpath.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.isDeleted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dirStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.snapshotID {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.parent_fullpath.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.isDeleted {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotStatusProto {
        SnapshotStatusProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HdfsFileStatusProto>>(
                "dirStatus",
                |m: &SnapshotStatusProto| { &m.dirStatus },
                |m: &mut SnapshotStatusProto| { &mut m.dirStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "snapshotID",
                |m: &SnapshotStatusProto| { &m.snapshotID },
                |m: &mut SnapshotStatusProto| { &mut m.snapshotID },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "parent_fullpath",
                |m: &SnapshotStatusProto| { &m.parent_fullpath },
                |m: &mut SnapshotStatusProto| { &mut m.parent_fullpath },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isDeleted",
                |m: &SnapshotStatusProto| { &m.isDeleted },
                |m: &mut SnapshotStatusProto| { &mut m.isDeleted },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SnapshotStatusProto>(
                "SnapshotStatusProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SnapshotStatusProto {
        static instance: ::protobuf::rt::LazyV2<SnapshotStatusProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SnapshotStatusProto::new)
    }
}

impl ::protobuf::Clear for SnapshotStatusProto {
    fn clear(&mut self) {
        self.dirStatus.clear();
        self.snapshotID = ::std::option::Option::None;
        self.parent_fullpath.clear();
        self.isDeleted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotStatusProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotStatusProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshottableDirectoryListingProto {
    // message fields
    pub snapshottableDirListing: ::protobuf::RepeatedField<SnapshottableDirectoryStatusProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshottableDirectoryListingProto {
    fn default() -> &'a SnapshottableDirectoryListingProto {
        <SnapshottableDirectoryListingProto as ::protobuf::Message>::default_instance()
    }
}

impl SnapshottableDirectoryListingProto {
    pub fn new() -> SnapshottableDirectoryListingProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.SnapshottableDirectoryStatusProto snapshottableDirListing = 1;


    pub fn get_snapshottableDirListing(&self) -> &[SnapshottableDirectoryStatusProto] {
        &self.snapshottableDirListing
    }
    pub fn clear_snapshottableDirListing(&mut self) {
        self.snapshottableDirListing.clear();
    }

    // Param is passed by value, moved
    pub fn set_snapshottableDirListing(&mut self, v: ::protobuf::RepeatedField<SnapshottableDirectoryStatusProto>) {
        self.snapshottableDirListing = v;
    }

    // Mutable pointer to the field.
    pub fn mut_snapshottableDirListing(&mut self) -> &mut ::protobuf::RepeatedField<SnapshottableDirectoryStatusProto> {
        &mut self.snapshottableDirListing
    }

    // Take field
    pub fn take_snapshottableDirListing(&mut self) -> ::protobuf::RepeatedField<SnapshottableDirectoryStatusProto> {
        ::std::mem::replace(&mut self.snapshottableDirListing, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SnapshottableDirectoryListingProto {
    fn is_initialized(&self) -> bool {
        for v in &self.snapshottableDirListing {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.snapshottableDirListing)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.snapshottableDirListing {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.snapshottableDirListing {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshottableDirectoryListingProto {
        SnapshottableDirectoryListingProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SnapshottableDirectoryStatusProto>>(
                "snapshottableDirListing",
                |m: &SnapshottableDirectoryListingProto| { &m.snapshottableDirListing },
                |m: &mut SnapshottableDirectoryListingProto| { &mut m.snapshottableDirListing },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SnapshottableDirectoryListingProto>(
                "SnapshottableDirectoryListingProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SnapshottableDirectoryListingProto {
        static instance: ::protobuf::rt::LazyV2<SnapshottableDirectoryListingProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SnapshottableDirectoryListingProto::new)
    }
}

impl ::protobuf::Clear for SnapshottableDirectoryListingProto {
    fn clear(&mut self) {
        self.snapshottableDirListing.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshottableDirectoryListingProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshottableDirectoryListingProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotListingProto {
    // message fields
    pub snapshotListing: ::protobuf::RepeatedField<SnapshotStatusProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotListingProto {
    fn default() -> &'a SnapshotListingProto {
        <SnapshotListingProto as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotListingProto {
    pub fn new() -> SnapshotListingProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.SnapshotStatusProto snapshotListing = 1;


    pub fn get_snapshotListing(&self) -> &[SnapshotStatusProto] {
        &self.snapshotListing
    }
    pub fn clear_snapshotListing(&mut self) {
        self.snapshotListing.clear();
    }

    // Param is passed by value, moved
    pub fn set_snapshotListing(&mut self, v: ::protobuf::RepeatedField<SnapshotStatusProto>) {
        self.snapshotListing = v;
    }

    // Mutable pointer to the field.
    pub fn mut_snapshotListing(&mut self) -> &mut ::protobuf::RepeatedField<SnapshotStatusProto> {
        &mut self.snapshotListing
    }

    // Take field
    pub fn take_snapshotListing(&mut self) -> ::protobuf::RepeatedField<SnapshotStatusProto> {
        ::std::mem::replace(&mut self.snapshotListing, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SnapshotListingProto {
    fn is_initialized(&self) -> bool {
        for v in &self.snapshotListing {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.snapshotListing)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.snapshotListing {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.snapshotListing {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotListingProto {
        SnapshotListingProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SnapshotStatusProto>>(
                "snapshotListing",
                |m: &SnapshotListingProto| { &m.snapshotListing },
                |m: &mut SnapshotListingProto| { &mut m.snapshotListing },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SnapshotListingProto>(
                "SnapshotListingProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SnapshotListingProto {
        static instance: ::protobuf::rt::LazyV2<SnapshotListingProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SnapshotListingProto::new)
    }
}

impl ::protobuf::Clear for SnapshotListingProto {
    fn clear(&mut self) {
        self.snapshotListing.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotListingProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotListingProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotDiffReportEntryProto {
    // message fields
    fullpath: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    modificationLabel: ::protobuf::SingularField<::std::string::String>,
    targetPath: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotDiffReportEntryProto {
    fn default() -> &'a SnapshotDiffReportEntryProto {
        <SnapshotDiffReportEntryProto as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotDiffReportEntryProto {
    pub fn new() -> SnapshotDiffReportEntryProto {
        ::std::default::Default::default()
    }

    // required bytes fullpath = 1;


    pub fn get_fullpath(&self) -> &[u8] {
        match self.fullpath.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_fullpath(&mut self) {
        self.fullpath.clear();
    }

    pub fn has_fullpath(&self) -> bool {
        self.fullpath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fullpath(&mut self, v: ::std::vec::Vec<u8>) {
        self.fullpath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fullpath(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fullpath.is_none() {
            self.fullpath.set_default();
        }
        self.fullpath.as_mut().unwrap()
    }

    // Take field
    pub fn take_fullpath(&mut self) -> ::std::vec::Vec<u8> {
        self.fullpath.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required string modificationLabel = 2;


    pub fn get_modificationLabel(&self) -> &str {
        match self.modificationLabel.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_modificationLabel(&mut self) {
        self.modificationLabel.clear();
    }

    pub fn has_modificationLabel(&self) -> bool {
        self.modificationLabel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modificationLabel(&mut self, v: ::std::string::String) {
        self.modificationLabel = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modificationLabel(&mut self) -> &mut ::std::string::String {
        if self.modificationLabel.is_none() {
            self.modificationLabel.set_default();
        }
        self.modificationLabel.as_mut().unwrap()
    }

    // Take field
    pub fn take_modificationLabel(&mut self) -> ::std::string::String {
        self.modificationLabel.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes targetPath = 3;


    pub fn get_targetPath(&self) -> &[u8] {
        match self.targetPath.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_targetPath(&mut self) {
        self.targetPath.clear();
    }

    pub fn has_targetPath(&self) -> bool {
        self.targetPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetPath(&mut self, v: ::std::vec::Vec<u8>) {
        self.targetPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetPath(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.targetPath.is_none() {
            self.targetPath.set_default();
        }
        self.targetPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetPath(&mut self) -> ::std::vec::Vec<u8> {
        self.targetPath.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SnapshotDiffReportEntryProto {
    fn is_initialized(&self) -> bool {
        if self.fullpath.is_none() {
            return false;
        }
        if self.modificationLabel.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.fullpath)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.modificationLabel)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.targetPath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fullpath.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.modificationLabel.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.targetPath.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fullpath.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.modificationLabel.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.targetPath.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotDiffReportEntryProto {
        SnapshotDiffReportEntryProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "fullpath",
                |m: &SnapshotDiffReportEntryProto| { &m.fullpath },
                |m: &mut SnapshotDiffReportEntryProto| { &mut m.fullpath },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "modificationLabel",
                |m: &SnapshotDiffReportEntryProto| { &m.modificationLabel },
                |m: &mut SnapshotDiffReportEntryProto| { &mut m.modificationLabel },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "targetPath",
                |m: &SnapshotDiffReportEntryProto| { &m.targetPath },
                |m: &mut SnapshotDiffReportEntryProto| { &mut m.targetPath },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SnapshotDiffReportEntryProto>(
                "SnapshotDiffReportEntryProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SnapshotDiffReportEntryProto {
        static instance: ::protobuf::rt::LazyV2<SnapshotDiffReportEntryProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SnapshotDiffReportEntryProto::new)
    }
}

impl ::protobuf::Clear for SnapshotDiffReportEntryProto {
    fn clear(&mut self) {
        self.fullpath.clear();
        self.modificationLabel.clear();
        self.targetPath.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotDiffReportEntryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotDiffReportEntryProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotDiffReportProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    fromSnapshot: ::protobuf::SingularField<::std::string::String>,
    toSnapshot: ::protobuf::SingularField<::std::string::String>,
    pub diffReportEntries: ::protobuf::RepeatedField<SnapshotDiffReportEntryProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotDiffReportProto {
    fn default() -> &'a SnapshotDiffReportProto {
        <SnapshotDiffReportProto as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotDiffReportProto {
    pub fn new() -> SnapshotDiffReportProto {
        ::std::default::Default::default()
    }

    // required string snapshotRoot = 1;


    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string fromSnapshot = 2;


    pub fn get_fromSnapshot(&self) -> &str {
        match self.fromSnapshot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fromSnapshot(&mut self) {
        self.fromSnapshot.clear();
    }

    pub fn has_fromSnapshot(&self) -> bool {
        self.fromSnapshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromSnapshot(&mut self, v: ::std::string::String) {
        self.fromSnapshot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fromSnapshot(&mut self) -> &mut ::std::string::String {
        if self.fromSnapshot.is_none() {
            self.fromSnapshot.set_default();
        }
        self.fromSnapshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_fromSnapshot(&mut self) -> ::std::string::String {
        self.fromSnapshot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string toSnapshot = 3;


    pub fn get_toSnapshot(&self) -> &str {
        match self.toSnapshot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_toSnapshot(&mut self) {
        self.toSnapshot.clear();
    }

    pub fn has_toSnapshot(&self) -> bool {
        self.toSnapshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toSnapshot(&mut self, v: ::std::string::String) {
        self.toSnapshot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toSnapshot(&mut self) -> &mut ::std::string::String {
        if self.toSnapshot.is_none() {
            self.toSnapshot.set_default();
        }
        self.toSnapshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_toSnapshot(&mut self) -> ::std::string::String {
        self.toSnapshot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .hadoop.hdfs.SnapshotDiffReportEntryProto diffReportEntries = 4;


    pub fn get_diffReportEntries(&self) -> &[SnapshotDiffReportEntryProto] {
        &self.diffReportEntries
    }
    pub fn clear_diffReportEntries(&mut self) {
        self.diffReportEntries.clear();
    }

    // Param is passed by value, moved
    pub fn set_diffReportEntries(&mut self, v: ::protobuf::RepeatedField<SnapshotDiffReportEntryProto>) {
        self.diffReportEntries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_diffReportEntries(&mut self) -> &mut ::protobuf::RepeatedField<SnapshotDiffReportEntryProto> {
        &mut self.diffReportEntries
    }

    // Take field
    pub fn take_diffReportEntries(&mut self) -> ::protobuf::RepeatedField<SnapshotDiffReportEntryProto> {
        ::std::mem::replace(&mut self.diffReportEntries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SnapshotDiffReportProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        if self.fromSnapshot.is_none() {
            return false;
        }
        if self.toSnapshot.is_none() {
            return false;
        }
        for v in &self.diffReportEntries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fromSnapshot)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.toSnapshot)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.diffReportEntries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fromSnapshot.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.toSnapshot.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.diffReportEntries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fromSnapshot.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.toSnapshot.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.diffReportEntries {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotDiffReportProto {
        SnapshotDiffReportProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snapshotRoot",
                |m: &SnapshotDiffReportProto| { &m.snapshotRoot },
                |m: &mut SnapshotDiffReportProto| { &mut m.snapshotRoot },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fromSnapshot",
                |m: &SnapshotDiffReportProto| { &m.fromSnapshot },
                |m: &mut SnapshotDiffReportProto| { &mut m.fromSnapshot },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "toSnapshot",
                |m: &SnapshotDiffReportProto| { &m.toSnapshot },
                |m: &mut SnapshotDiffReportProto| { &mut m.toSnapshot },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SnapshotDiffReportEntryProto>>(
                "diffReportEntries",
                |m: &SnapshotDiffReportProto| { &m.diffReportEntries },
                |m: &mut SnapshotDiffReportProto| { &mut m.diffReportEntries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SnapshotDiffReportProto>(
                "SnapshotDiffReportProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SnapshotDiffReportProto {
        static instance: ::protobuf::rt::LazyV2<SnapshotDiffReportProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SnapshotDiffReportProto::new)
    }
}

impl ::protobuf::Clear for SnapshotDiffReportProto {
    fn clear(&mut self) {
        self.snapshotRoot.clear();
        self.fromSnapshot.clear();
        self.toSnapshot.clear();
        self.diffReportEntries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotDiffReportProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotDiffReportProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotDiffReportListingEntryProto {
    // message fields
    fullpath: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    dirId: ::std::option::Option<u64>,
    isReference: ::std::option::Option<bool>,
    targetPath: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    fileId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotDiffReportListingEntryProto {
    fn default() -> &'a SnapshotDiffReportListingEntryProto {
        <SnapshotDiffReportListingEntryProto as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotDiffReportListingEntryProto {
    pub fn new() -> SnapshotDiffReportListingEntryProto {
        ::std::default::Default::default()
    }

    // required bytes fullpath = 1;


    pub fn get_fullpath(&self) -> &[u8] {
        match self.fullpath.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_fullpath(&mut self) {
        self.fullpath.clear();
    }

    pub fn has_fullpath(&self) -> bool {
        self.fullpath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fullpath(&mut self, v: ::std::vec::Vec<u8>) {
        self.fullpath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fullpath(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fullpath.is_none() {
            self.fullpath.set_default();
        }
        self.fullpath.as_mut().unwrap()
    }

    // Take field
    pub fn take_fullpath(&mut self) -> ::std::vec::Vec<u8> {
        self.fullpath.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint64 dirId = 2;


    pub fn get_dirId(&self) -> u64 {
        self.dirId.unwrap_or(0)
    }
    pub fn clear_dirId(&mut self) {
        self.dirId = ::std::option::Option::None;
    }

    pub fn has_dirId(&self) -> bool {
        self.dirId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dirId(&mut self, v: u64) {
        self.dirId = ::std::option::Option::Some(v);
    }

    // required bool isReference = 3;


    pub fn get_isReference(&self) -> bool {
        self.isReference.unwrap_or(false)
    }
    pub fn clear_isReference(&mut self) {
        self.isReference = ::std::option::Option::None;
    }

    pub fn has_isReference(&self) -> bool {
        self.isReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isReference(&mut self, v: bool) {
        self.isReference = ::std::option::Option::Some(v);
    }

    // optional bytes targetPath = 4;


    pub fn get_targetPath(&self) -> &[u8] {
        match self.targetPath.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_targetPath(&mut self) {
        self.targetPath.clear();
    }

    pub fn has_targetPath(&self) -> bool {
        self.targetPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetPath(&mut self, v: ::std::vec::Vec<u8>) {
        self.targetPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetPath(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.targetPath.is_none() {
            self.targetPath.set_default();
        }
        self.targetPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetPath(&mut self) -> ::std::vec::Vec<u8> {
        self.targetPath.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 fileId = 5;


    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0)
    }
    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SnapshotDiffReportListingEntryProto {
    fn is_initialized(&self) -> bool {
        if self.fullpath.is_none() {
            return false;
        }
        if self.dirId.is_none() {
            return false;
        }
        if self.isReference.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.fullpath)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dirId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isReference = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.targetPath)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fullpath.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.dirId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.isReference {
            my_size += 2;
        }
        if let Some(ref v) = self.targetPath.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fullpath.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.dirId {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.isReference {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.targetPath.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.fileId {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotDiffReportListingEntryProto {
        SnapshotDiffReportListingEntryProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "fullpath",
                |m: &SnapshotDiffReportListingEntryProto| { &m.fullpath },
                |m: &mut SnapshotDiffReportListingEntryProto| { &mut m.fullpath },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "dirId",
                |m: &SnapshotDiffReportListingEntryProto| { &m.dirId },
                |m: &mut SnapshotDiffReportListingEntryProto| { &mut m.dirId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isReference",
                |m: &SnapshotDiffReportListingEntryProto| { &m.isReference },
                |m: &mut SnapshotDiffReportListingEntryProto| { &mut m.isReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "targetPath",
                |m: &SnapshotDiffReportListingEntryProto| { &m.targetPath },
                |m: &mut SnapshotDiffReportListingEntryProto| { &mut m.targetPath },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fileId",
                |m: &SnapshotDiffReportListingEntryProto| { &m.fileId },
                |m: &mut SnapshotDiffReportListingEntryProto| { &mut m.fileId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SnapshotDiffReportListingEntryProto>(
                "SnapshotDiffReportListingEntryProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SnapshotDiffReportListingEntryProto {
        static instance: ::protobuf::rt::LazyV2<SnapshotDiffReportListingEntryProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SnapshotDiffReportListingEntryProto::new)
    }
}

impl ::protobuf::Clear for SnapshotDiffReportListingEntryProto {
    fn clear(&mut self) {
        self.fullpath.clear();
        self.dirId = ::std::option::Option::None;
        self.isReference = ::std::option::Option::None;
        self.targetPath.clear();
        self.fileId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotDiffReportListingEntryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotDiffReportListingEntryProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotDiffReportCursorProto {
    // message fields
    startPath: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    index: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotDiffReportCursorProto {
    fn default() -> &'a SnapshotDiffReportCursorProto {
        <SnapshotDiffReportCursorProto as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotDiffReportCursorProto {
    pub fn new() -> SnapshotDiffReportCursorProto {
        ::std::default::Default::default()
    }

    // required bytes startPath = 1;


    pub fn get_startPath(&self) -> &[u8] {
        match self.startPath.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_startPath(&mut self) {
        self.startPath.clear();
    }

    pub fn has_startPath(&self) -> bool {
        self.startPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startPath(&mut self, v: ::std::vec::Vec<u8>) {
        self.startPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startPath(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.startPath.is_none() {
            self.startPath.set_default();
        }
        self.startPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_startPath(&mut self) -> ::std::vec::Vec<u8> {
        self.startPath.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required int32 index = 2;


    pub fn get_index(&self) -> i32 {
        self.index.unwrap_or(-1i32)
    }
    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SnapshotDiffReportCursorProto {
    fn is_initialized(&self) -> bool {
        if self.startPath.is_none() {
            return false;
        }
        if self.index.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.startPath)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.startPath.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.startPath.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.index {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotDiffReportCursorProto {
        SnapshotDiffReportCursorProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "startPath",
                |m: &SnapshotDiffReportCursorProto| { &m.startPath },
                |m: &mut SnapshotDiffReportCursorProto| { &mut m.startPath },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "index",
                |m: &SnapshotDiffReportCursorProto| { &m.index },
                |m: &mut SnapshotDiffReportCursorProto| { &mut m.index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SnapshotDiffReportCursorProto>(
                "SnapshotDiffReportCursorProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SnapshotDiffReportCursorProto {
        static instance: ::protobuf::rt::LazyV2<SnapshotDiffReportCursorProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SnapshotDiffReportCursorProto::new)
    }
}

impl ::protobuf::Clear for SnapshotDiffReportCursorProto {
    fn clear(&mut self) {
        self.startPath.clear();
        self.index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotDiffReportCursorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotDiffReportCursorProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotDiffReportListingProto {
    // message fields
    pub modifiedEntries: ::protobuf::RepeatedField<SnapshotDiffReportListingEntryProto>,
    pub createdEntries: ::protobuf::RepeatedField<SnapshotDiffReportListingEntryProto>,
    pub deletedEntries: ::protobuf::RepeatedField<SnapshotDiffReportListingEntryProto>,
    isFromEarlier: ::std::option::Option<bool>,
    pub cursor: ::protobuf::SingularPtrField<SnapshotDiffReportCursorProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotDiffReportListingProto {
    fn default() -> &'a SnapshotDiffReportListingProto {
        <SnapshotDiffReportListingProto as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotDiffReportListingProto {
    pub fn new() -> SnapshotDiffReportListingProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.SnapshotDiffReportListingEntryProto modifiedEntries = 1;


    pub fn get_modifiedEntries(&self) -> &[SnapshotDiffReportListingEntryProto] {
        &self.modifiedEntries
    }
    pub fn clear_modifiedEntries(&mut self) {
        self.modifiedEntries.clear();
    }

    // Param is passed by value, moved
    pub fn set_modifiedEntries(&mut self, v: ::protobuf::RepeatedField<SnapshotDiffReportListingEntryProto>) {
        self.modifiedEntries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_modifiedEntries(&mut self) -> &mut ::protobuf::RepeatedField<SnapshotDiffReportListingEntryProto> {
        &mut self.modifiedEntries
    }

    // Take field
    pub fn take_modifiedEntries(&mut self) -> ::protobuf::RepeatedField<SnapshotDiffReportListingEntryProto> {
        ::std::mem::replace(&mut self.modifiedEntries, ::protobuf::RepeatedField::new())
    }

    // repeated .hadoop.hdfs.SnapshotDiffReportListingEntryProto createdEntries = 2;


    pub fn get_createdEntries(&self) -> &[SnapshotDiffReportListingEntryProto] {
        &self.createdEntries
    }
    pub fn clear_createdEntries(&mut self) {
        self.createdEntries.clear();
    }

    // Param is passed by value, moved
    pub fn set_createdEntries(&mut self, v: ::protobuf::RepeatedField<SnapshotDiffReportListingEntryProto>) {
        self.createdEntries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_createdEntries(&mut self) -> &mut ::protobuf::RepeatedField<SnapshotDiffReportListingEntryProto> {
        &mut self.createdEntries
    }

    // Take field
    pub fn take_createdEntries(&mut self) -> ::protobuf::RepeatedField<SnapshotDiffReportListingEntryProto> {
        ::std::mem::replace(&mut self.createdEntries, ::protobuf::RepeatedField::new())
    }

    // repeated .hadoop.hdfs.SnapshotDiffReportListingEntryProto deletedEntries = 3;


    pub fn get_deletedEntries(&self) -> &[SnapshotDiffReportListingEntryProto] {
        &self.deletedEntries
    }
    pub fn clear_deletedEntries(&mut self) {
        self.deletedEntries.clear();
    }

    // Param is passed by value, moved
    pub fn set_deletedEntries(&mut self, v: ::protobuf::RepeatedField<SnapshotDiffReportListingEntryProto>) {
        self.deletedEntries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_deletedEntries(&mut self) -> &mut ::protobuf::RepeatedField<SnapshotDiffReportListingEntryProto> {
        &mut self.deletedEntries
    }

    // Take field
    pub fn take_deletedEntries(&mut self) -> ::protobuf::RepeatedField<SnapshotDiffReportListingEntryProto> {
        ::std::mem::replace(&mut self.deletedEntries, ::protobuf::RepeatedField::new())
    }

    // required bool isFromEarlier = 4;


    pub fn get_isFromEarlier(&self) -> bool {
        self.isFromEarlier.unwrap_or(false)
    }
    pub fn clear_isFromEarlier(&mut self) {
        self.isFromEarlier = ::std::option::Option::None;
    }

    pub fn has_isFromEarlier(&self) -> bool {
        self.isFromEarlier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isFromEarlier(&mut self, v: bool) {
        self.isFromEarlier = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.SnapshotDiffReportCursorProto cursor = 5;


    pub fn get_cursor(&self) -> &SnapshotDiffReportCursorProto {
        self.cursor.as_ref().unwrap_or_else(|| <SnapshotDiffReportCursorProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    pub fn has_cursor(&self) -> bool {
        self.cursor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: SnapshotDiffReportCursorProto) {
        self.cursor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut SnapshotDiffReportCursorProto {
        if self.cursor.is_none() {
            self.cursor.set_default();
        }
        self.cursor.as_mut().unwrap()
    }

    // Take field
    pub fn take_cursor(&mut self) -> SnapshotDiffReportCursorProto {
        self.cursor.take().unwrap_or_else(|| SnapshotDiffReportCursorProto::new())
    }
}

impl ::protobuf::Message for SnapshotDiffReportListingProto {
    fn is_initialized(&self) -> bool {
        if self.isFromEarlier.is_none() {
            return false;
        }
        for v in &self.modifiedEntries {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.createdEntries {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deletedEntries {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cursor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.modifiedEntries)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.createdEntries)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.deletedEntries)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isFromEarlier = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cursor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.modifiedEntries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.createdEntries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.deletedEntries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.isFromEarlier {
            my_size += 2;
        }
        if let Some(ref v) = self.cursor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.modifiedEntries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.createdEntries {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.deletedEntries {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.isFromEarlier {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.cursor.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotDiffReportListingProto {
        SnapshotDiffReportListingProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SnapshotDiffReportListingEntryProto>>(
                "modifiedEntries",
                |m: &SnapshotDiffReportListingProto| { &m.modifiedEntries },
                |m: &mut SnapshotDiffReportListingProto| { &mut m.modifiedEntries },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SnapshotDiffReportListingEntryProto>>(
                "createdEntries",
                |m: &SnapshotDiffReportListingProto| { &m.createdEntries },
                |m: &mut SnapshotDiffReportListingProto| { &mut m.createdEntries },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SnapshotDiffReportListingEntryProto>>(
                "deletedEntries",
                |m: &SnapshotDiffReportListingProto| { &m.deletedEntries },
                |m: &mut SnapshotDiffReportListingProto| { &mut m.deletedEntries },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isFromEarlier",
                |m: &SnapshotDiffReportListingProto| { &m.isFromEarlier },
                |m: &mut SnapshotDiffReportListingProto| { &mut m.isFromEarlier },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SnapshotDiffReportCursorProto>>(
                "cursor",
                |m: &SnapshotDiffReportListingProto| { &m.cursor },
                |m: &mut SnapshotDiffReportListingProto| { &mut m.cursor },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SnapshotDiffReportListingProto>(
                "SnapshotDiffReportListingProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SnapshotDiffReportListingProto {
        static instance: ::protobuf::rt::LazyV2<SnapshotDiffReportListingProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SnapshotDiffReportListingProto::new)
    }
}

impl ::protobuf::Clear for SnapshotDiffReportListingProto {
    fn clear(&mut self) {
        self.modifiedEntries.clear();
        self.createdEntries.clear();
        self.deletedEntries.clear();
        self.isFromEarlier = ::std::option::Option::None;
        self.cursor.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotDiffReportListingProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotDiffReportListingProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockProto {
    // message fields
    blockId: ::std::option::Option<u64>,
    genStamp: ::std::option::Option<u64>,
    numBytes: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockProto {
    fn default() -> &'a BlockProto {
        <BlockProto as ::protobuf::Message>::default_instance()
    }
}

impl BlockProto {
    pub fn new() -> BlockProto {
        ::std::default::Default::default()
    }

    // required uint64 blockId = 1;


    pub fn get_blockId(&self) -> u64 {
        self.blockId.unwrap_or(0)
    }
    pub fn clear_blockId(&mut self) {
        self.blockId = ::std::option::Option::None;
    }

    pub fn has_blockId(&self) -> bool {
        self.blockId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockId(&mut self, v: u64) {
        self.blockId = ::std::option::Option::Some(v);
    }

    // required uint64 genStamp = 2;


    pub fn get_genStamp(&self) -> u64 {
        self.genStamp.unwrap_or(0)
    }
    pub fn clear_genStamp(&mut self) {
        self.genStamp = ::std::option::Option::None;
    }

    pub fn has_genStamp(&self) -> bool {
        self.genStamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_genStamp(&mut self, v: u64) {
        self.genStamp = ::std::option::Option::Some(v);
    }

    // optional uint64 numBytes = 3;


    pub fn get_numBytes(&self) -> u64 {
        self.numBytes.unwrap_or(0u64)
    }
    pub fn clear_numBytes(&mut self) {
        self.numBytes = ::std::option::Option::None;
    }

    pub fn has_numBytes(&self) -> bool {
        self.numBytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numBytes(&mut self, v: u64) {
        self.numBytes = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BlockProto {
    fn is_initialized(&self) -> bool {
        if self.blockId.is_none() {
            return false;
        }
        if self.genStamp.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.genStamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.numBytes = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.blockId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.genStamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numBytes {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.blockId {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.genStamp {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.numBytes {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockProto {
        BlockProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "blockId",
                |m: &BlockProto| { &m.blockId },
                |m: &mut BlockProto| { &mut m.blockId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "genStamp",
                |m: &BlockProto| { &m.genStamp },
                |m: &mut BlockProto| { &mut m.genStamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "numBytes",
                |m: &BlockProto| { &m.numBytes },
                |m: &mut BlockProto| { &mut m.numBytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockProto>(
                "BlockProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockProto {
        static instance: ::protobuf::rt::LazyV2<BlockProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockProto::new)
    }
}

impl ::protobuf::Clear for BlockProto {
    fn clear(&mut self) {
        self.blockId = ::std::option::Option::None;
        self.genStamp = ::std::option::Option::None;
        self.numBytes = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotInfoProto {
    // message fields
    snapshotName: ::protobuf::SingularField<::std::string::String>,
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    pub permission: ::protobuf::SingularPtrField<super::acl::FsPermissionProto>,
    owner: ::protobuf::SingularField<::std::string::String>,
    group: ::protobuf::SingularField<::std::string::String>,
    createTime: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotInfoProto {
    fn default() -> &'a SnapshotInfoProto {
        <SnapshotInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotInfoProto {
    pub fn new() -> SnapshotInfoProto {
        ::std::default::Default::default()
    }

    // required string snapshotName = 1;


    pub fn get_snapshotName(&self) -> &str {
        match self.snapshotName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotName(&mut self) {
        self.snapshotName.clear();
    }

    pub fn has_snapshotName(&self) -> bool {
        self.snapshotName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotName(&mut self, v: ::std::string::String) {
        self.snapshotName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotName(&mut self) -> &mut ::std::string::String {
        if self.snapshotName.is_none() {
            self.snapshotName.set_default();
        }
        self.snapshotName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotName(&mut self) -> ::std::string::String {
        self.snapshotName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string snapshotRoot = 2;


    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.FsPermissionProto permission = 3;


    pub fn get_permission(&self) -> &super::acl::FsPermissionProto {
        self.permission.as_ref().unwrap_or_else(|| <super::acl::FsPermissionProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_permission(&mut self) {
        self.permission.clear();
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: super::acl::FsPermissionProto) {
        self.permission = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permission(&mut self) -> &mut super::acl::FsPermissionProto {
        if self.permission.is_none() {
            self.permission.set_default();
        }
        self.permission.as_mut().unwrap()
    }

    // Take field
    pub fn take_permission(&mut self) -> super::acl::FsPermissionProto {
        self.permission.take().unwrap_or_else(|| super::acl::FsPermissionProto::new())
    }

    // required string owner = 4;


    pub fn get_owner(&self) -> &str {
        match self.owner.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_owner(&mut self) {
        self.owner.clear();
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: ::std::string::String) {
        self.owner = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner(&mut self) -> &mut ::std::string::String {
        if self.owner.is_none() {
            self.owner.set_default();
        }
        self.owner.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner(&mut self) -> ::std::string::String {
        self.owner.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string group = 5;


    pub fn get_group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string createTime = 6;


    pub fn get_createTime(&self) -> &str {
        match self.createTime.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_createTime(&mut self) {
        self.createTime.clear();
    }

    pub fn has_createTime(&self) -> bool {
        self.createTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createTime(&mut self, v: ::std::string::String) {
        self.createTime = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_createTime(&mut self) -> &mut ::std::string::String {
        if self.createTime.is_none() {
            self.createTime.set_default();
        }
        self.createTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_createTime(&mut self) -> ::std::string::String {
        self.createTime.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for SnapshotInfoProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotName.is_none() {
            return false;
        }
        if self.snapshotRoot.is_none() {
            return false;
        }
        if self.permission.is_none() {
            return false;
        }
        if self.owner.is_none() {
            return false;
        }
        if self.group.is_none() {
            return false;
        }
        if self.createTime.is_none() {
            return false;
        }
        for v in &self.permission {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.permission)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.owner)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.group)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.createTime)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.permission.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.owner.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.createTime.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.permission.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.owner.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.group.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.createTime.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotInfoProto {
        SnapshotInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snapshotName",
                |m: &SnapshotInfoProto| { &m.snapshotName },
                |m: &mut SnapshotInfoProto| { &mut m.snapshotName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snapshotRoot",
                |m: &SnapshotInfoProto| { &m.snapshotRoot },
                |m: &mut SnapshotInfoProto| { &mut m.snapshotRoot },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::acl::FsPermissionProto>>(
                "permission",
                |m: &SnapshotInfoProto| { &m.permission },
                |m: &mut SnapshotInfoProto| { &mut m.permission },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "owner",
                |m: &SnapshotInfoProto| { &m.owner },
                |m: &mut SnapshotInfoProto| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "group",
                |m: &SnapshotInfoProto| { &m.group },
                |m: &mut SnapshotInfoProto| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "createTime",
                |m: &SnapshotInfoProto| { &m.createTime },
                |m: &mut SnapshotInfoProto| { &mut m.createTime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SnapshotInfoProto>(
                "SnapshotInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SnapshotInfoProto {
        static instance: ::protobuf::rt::LazyV2<SnapshotInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SnapshotInfoProto::new)
    }
}

impl ::protobuf::Clear for SnapshotInfoProto {
    fn clear(&mut self) {
        self.snapshotName.clear();
        self.snapshotRoot.clear();
        self.permission.clear();
        self.owner.clear();
        self.group.clear();
        self.createTime.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollingUpgradeStatusProto {
    // message fields
    blockPoolId: ::protobuf::SingularField<::std::string::String>,
    finalized: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RollingUpgradeStatusProto {
    fn default() -> &'a RollingUpgradeStatusProto {
        <RollingUpgradeStatusProto as ::protobuf::Message>::default_instance()
    }
}

impl RollingUpgradeStatusProto {
    pub fn new() -> RollingUpgradeStatusProto {
        ::std::default::Default::default()
    }

    // required string blockPoolId = 1;


    pub fn get_blockPoolId(&self) -> &str {
        match self.blockPoolId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_blockPoolId(&mut self) {
        self.blockPoolId.clear();
    }

    pub fn has_blockPoolId(&self) -> bool {
        self.blockPoolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockPoolId(&mut self, v: ::std::string::String) {
        self.blockPoolId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockPoolId(&mut self) -> &mut ::std::string::String {
        if self.blockPoolId.is_none() {
            self.blockPoolId.set_default();
        }
        self.blockPoolId.as_mut().unwrap()
    }

    // Take field
    pub fn take_blockPoolId(&mut self) -> ::std::string::String {
        self.blockPoolId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool finalized = 2;


    pub fn get_finalized(&self) -> bool {
        self.finalized.unwrap_or(false)
    }
    pub fn clear_finalized(&mut self) {
        self.finalized = ::std::option::Option::None;
    }

    pub fn has_finalized(&self) -> bool {
        self.finalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_finalized(&mut self, v: bool) {
        self.finalized = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RollingUpgradeStatusProto {
    fn is_initialized(&self) -> bool {
        if self.blockPoolId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.blockPoolId)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.finalized = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.blockPoolId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.finalized {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.blockPoolId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.finalized {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RollingUpgradeStatusProto {
        RollingUpgradeStatusProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blockPoolId",
                |m: &RollingUpgradeStatusProto| { &m.blockPoolId },
                |m: &mut RollingUpgradeStatusProto| { &mut m.blockPoolId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "finalized",
                |m: &RollingUpgradeStatusProto| { &m.finalized },
                |m: &mut RollingUpgradeStatusProto| { &mut m.finalized },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RollingUpgradeStatusProto>(
                "RollingUpgradeStatusProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RollingUpgradeStatusProto {
        static instance: ::protobuf::rt::LazyV2<RollingUpgradeStatusProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RollingUpgradeStatusProto::new)
    }
}

impl ::protobuf::Clear for RollingUpgradeStatusProto {
    fn clear(&mut self) {
        self.blockPoolId.clear();
        self.finalized = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollingUpgradeStatusProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpgradeStatusProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageUuidsProto {
    // message fields
    pub storageUuids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorageUuidsProto {
    fn default() -> &'a StorageUuidsProto {
        <StorageUuidsProto as ::protobuf::Message>::default_instance()
    }
}

impl StorageUuidsProto {
    pub fn new() -> StorageUuidsProto {
        ::std::default::Default::default()
    }

    // repeated string storageUuids = 1;


    pub fn get_storageUuids(&self) -> &[::std::string::String] {
        &self.storageUuids
    }
    pub fn clear_storageUuids(&mut self) {
        self.storageUuids.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageUuids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.storageUuids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageUuids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.storageUuids
    }

    // Take field
    pub fn take_storageUuids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.storageUuids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StorageUuidsProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.storageUuids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.storageUuids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.storageUuids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageUuidsProto {
        StorageUuidsProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storageUuids",
                |m: &StorageUuidsProto| { &m.storageUuids },
                |m: &mut StorageUuidsProto| { &mut m.storageUuids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StorageUuidsProto>(
                "StorageUuidsProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StorageUuidsProto {
        static instance: ::protobuf::rt::LazyV2<StorageUuidsProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StorageUuidsProto::new)
    }
}

impl ::protobuf::Clear for StorageUuidsProto {
    fn clear(&mut self) {
        self.storageUuids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageUuidsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageUuidsProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockTokenSecretProto {
    // message fields
    expiryDate: ::std::option::Option<u64>,
    keyId: ::std::option::Option<u32>,
    userId: ::protobuf::SingularField<::std::string::String>,
    blockPoolId: ::protobuf::SingularField<::std::string::String>,
    blockId: ::std::option::Option<u64>,
    pub modes: ::std::vec::Vec<AccessModeProto>,
    pub storageTypes: ::std::vec::Vec<StorageTypeProto>,
    pub storageIds: ::protobuf::RepeatedField<::std::string::String>,
    handshakeSecret: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockTokenSecretProto {
    fn default() -> &'a BlockTokenSecretProto {
        <BlockTokenSecretProto as ::protobuf::Message>::default_instance()
    }
}

impl BlockTokenSecretProto {
    pub fn new() -> BlockTokenSecretProto {
        ::std::default::Default::default()
    }

    // optional uint64 expiryDate = 1;


    pub fn get_expiryDate(&self) -> u64 {
        self.expiryDate.unwrap_or(0)
    }
    pub fn clear_expiryDate(&mut self) {
        self.expiryDate = ::std::option::Option::None;
    }

    pub fn has_expiryDate(&self) -> bool {
        self.expiryDate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiryDate(&mut self, v: u64) {
        self.expiryDate = ::std::option::Option::Some(v);
    }

    // optional uint32 keyId = 2;


    pub fn get_keyId(&self) -> u32 {
        self.keyId.unwrap_or(0)
    }
    pub fn clear_keyId(&mut self) {
        self.keyId = ::std::option::Option::None;
    }

    pub fn has_keyId(&self) -> bool {
        self.keyId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyId(&mut self, v: u32) {
        self.keyId = ::std::option::Option::Some(v);
    }

    // optional string userId = 3;


    pub fn get_userId(&self) -> &str {
        match self.userId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_userId(&mut self) {
        self.userId.clear();
    }

    pub fn has_userId(&self) -> bool {
        self.userId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_userId(&mut self, v: ::std::string::String) {
        self.userId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_userId(&mut self) -> &mut ::std::string::String {
        if self.userId.is_none() {
            self.userId.set_default();
        }
        self.userId.as_mut().unwrap()
    }

    // Take field
    pub fn take_userId(&mut self) -> ::std::string::String {
        self.userId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string blockPoolId = 4;


    pub fn get_blockPoolId(&self) -> &str {
        match self.blockPoolId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_blockPoolId(&mut self) {
        self.blockPoolId.clear();
    }

    pub fn has_blockPoolId(&self) -> bool {
        self.blockPoolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockPoolId(&mut self, v: ::std::string::String) {
        self.blockPoolId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockPoolId(&mut self) -> &mut ::std::string::String {
        if self.blockPoolId.is_none() {
            self.blockPoolId.set_default();
        }
        self.blockPoolId.as_mut().unwrap()
    }

    // Take field
    pub fn take_blockPoolId(&mut self) -> ::std::string::String {
        self.blockPoolId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 blockId = 5;


    pub fn get_blockId(&self) -> u64 {
        self.blockId.unwrap_or(0)
    }
    pub fn clear_blockId(&mut self) {
        self.blockId = ::std::option::Option::None;
    }

    pub fn has_blockId(&self) -> bool {
        self.blockId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockId(&mut self, v: u64) {
        self.blockId = ::std::option::Option::Some(v);
    }

    // repeated .hadoop.hdfs.AccessModeProto modes = 6;


    pub fn get_modes(&self) -> &[AccessModeProto] {
        &self.modes
    }
    pub fn clear_modes(&mut self) {
        self.modes.clear();
    }

    // Param is passed by value, moved
    pub fn set_modes(&mut self, v: ::std::vec::Vec<AccessModeProto>) {
        self.modes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_modes(&mut self) -> &mut ::std::vec::Vec<AccessModeProto> {
        &mut self.modes
    }

    // Take field
    pub fn take_modes(&mut self) -> ::std::vec::Vec<AccessModeProto> {
        ::std::mem::replace(&mut self.modes, ::std::vec::Vec::new())
    }

    // repeated .hadoop.hdfs.StorageTypeProto storageTypes = 7;


    pub fn get_storageTypes(&self) -> &[StorageTypeProto] {
        &self.storageTypes
    }
    pub fn clear_storageTypes(&mut self) {
        self.storageTypes.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageTypes(&mut self, v: ::std::vec::Vec<StorageTypeProto>) {
        self.storageTypes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageTypes(&mut self) -> &mut ::std::vec::Vec<StorageTypeProto> {
        &mut self.storageTypes
    }

    // Take field
    pub fn take_storageTypes(&mut self) -> ::std::vec::Vec<StorageTypeProto> {
        ::std::mem::replace(&mut self.storageTypes, ::std::vec::Vec::new())
    }

    // repeated string storageIds = 8;


    pub fn get_storageIds(&self) -> &[::std::string::String] {
        &self.storageIds
    }
    pub fn clear_storageIds(&mut self) {
        self.storageIds.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageIds(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.storageIds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageIds(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.storageIds
    }

    // Take field
    pub fn take_storageIds(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.storageIds, ::protobuf::RepeatedField::new())
    }

    // optional bytes handshakeSecret = 9;


    pub fn get_handshakeSecret(&self) -> &[u8] {
        match self.handshakeSecret.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_handshakeSecret(&mut self) {
        self.handshakeSecret.clear();
    }

    pub fn has_handshakeSecret(&self) -> bool {
        self.handshakeSecret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handshakeSecret(&mut self, v: ::std::vec::Vec<u8>) {
        self.handshakeSecret = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handshakeSecret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.handshakeSecret.is_none() {
            self.handshakeSecret.set_default();
        }
        self.handshakeSecret.as_mut().unwrap()
    }

    // Take field
    pub fn take_handshakeSecret(&mut self) -> ::std::vec::Vec<u8> {
        self.handshakeSecret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BlockTokenSecretProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.expiryDate = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.keyId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.userId)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.blockPoolId)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockId = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.modes, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.storageTypes, 7, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.storageIds)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.handshakeSecret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.expiryDate {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.keyId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.userId.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.blockPoolId.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.blockId {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.modes {
            my_size += ::protobuf::rt::enum_size(6, *value);
        };
        for value in &self.storageTypes {
            my_size += ::protobuf::rt::enum_size(7, *value);
        };
        for value in &self.storageIds {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if let Some(ref v) = self.handshakeSecret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.expiryDate {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.keyId {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.userId.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.blockPoolId.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.blockId {
            os.write_uint64(5, v)?;
        }
        for v in &self.modes {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.storageTypes {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.storageIds {
            os.write_string(8, &v)?;
        };
        if let Some(ref v) = self.handshakeSecret.as_ref() {
            os.write_bytes(9, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockTokenSecretProto {
        BlockTokenSecretProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "expiryDate",
                |m: &BlockTokenSecretProto| { &m.expiryDate },
                |m: &mut BlockTokenSecretProto| { &mut m.expiryDate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "keyId",
                |m: &BlockTokenSecretProto| { &m.keyId },
                |m: &mut BlockTokenSecretProto| { &mut m.keyId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "userId",
                |m: &BlockTokenSecretProto| { &m.userId },
                |m: &mut BlockTokenSecretProto| { &mut m.userId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blockPoolId",
                |m: &BlockTokenSecretProto| { &m.blockPoolId },
                |m: &mut BlockTokenSecretProto| { &mut m.blockPoolId },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "blockId",
                |m: &BlockTokenSecretProto| { &m.blockId },
                |m: &mut BlockTokenSecretProto| { &mut m.blockId },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AccessModeProto>>(
                "modes",
                |m: &BlockTokenSecretProto| { &m.modes },
                |m: &mut BlockTokenSecretProto| { &mut m.modes },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StorageTypeProto>>(
                "storageTypes",
                |m: &BlockTokenSecretProto| { &m.storageTypes },
                |m: &mut BlockTokenSecretProto| { &mut m.storageTypes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storageIds",
                |m: &BlockTokenSecretProto| { &m.storageIds },
                |m: &mut BlockTokenSecretProto| { &mut m.storageIds },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "handshakeSecret",
                |m: &BlockTokenSecretProto| { &m.handshakeSecret },
                |m: &mut BlockTokenSecretProto| { &mut m.handshakeSecret },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockTokenSecretProto>(
                "BlockTokenSecretProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlockTokenSecretProto {
        static instance: ::protobuf::rt::LazyV2<BlockTokenSecretProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlockTokenSecretProto::new)
    }
}

impl ::protobuf::Clear for BlockTokenSecretProto {
    fn clear(&mut self) {
        self.expiryDate = ::std::option::Option::None;
        self.keyId = ::std::option::Option::None;
        self.userId.clear();
        self.blockPoolId.clear();
        self.blockId = ::std::option::Option::None;
        self.modes.clear();
        self.storageTypes.clear();
        self.storageIds.clear();
        self.handshakeSecret.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockTokenSecretProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockTokenSecretProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StorageTypeProto {
    DISK = 1,
    SSD = 2,
    ARCHIVE = 3,
    RAM_DISK = 4,
    PROVIDED = 5,
    NVDIMM = 6,
}

impl ::protobuf::ProtobufEnum for StorageTypeProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StorageTypeProto> {
        match value {
            1 => ::std::option::Option::Some(StorageTypeProto::DISK),
            2 => ::std::option::Option::Some(StorageTypeProto::SSD),
            3 => ::std::option::Option::Some(StorageTypeProto::ARCHIVE),
            4 => ::std::option::Option::Some(StorageTypeProto::RAM_DISK),
            5 => ::std::option::Option::Some(StorageTypeProto::PROVIDED),
            6 => ::std::option::Option::Some(StorageTypeProto::NVDIMM),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StorageTypeProto] = &[
            StorageTypeProto::DISK,
            StorageTypeProto::SSD,
            StorageTypeProto::ARCHIVE,
            StorageTypeProto::RAM_DISK,
            StorageTypeProto::PROVIDED,
            StorageTypeProto::NVDIMM,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<StorageTypeProto>("StorageTypeProto", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for StorageTypeProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for StorageTypeProto {
    fn default() -> Self {
        StorageTypeProto::DISK
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageTypeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BlockTypeProto {
    CONTIGUOUS = 0,
    STRIPED = 1,
}

impl ::protobuf::ProtobufEnum for BlockTypeProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BlockTypeProto> {
        match value {
            0 => ::std::option::Option::Some(BlockTypeProto::CONTIGUOUS),
            1 => ::std::option::Option::Some(BlockTypeProto::STRIPED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BlockTypeProto] = &[
            BlockTypeProto::CONTIGUOUS,
            BlockTypeProto::STRIPED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BlockTypeProto>("BlockTypeProto", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BlockTypeProto {
}

impl ::std::default::Default for BlockTypeProto {
    fn default() -> Self {
        BlockTypeProto::CONTIGUOUS
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockTypeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CipherSuiteProto {
    UNKNOWN = 1,
    AES_CTR_NOPADDING = 2,
    SM4_CTR_NOPADDING = 3,
}

impl ::protobuf::ProtobufEnum for CipherSuiteProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CipherSuiteProto> {
        match value {
            1 => ::std::option::Option::Some(CipherSuiteProto::UNKNOWN),
            2 => ::std::option::Option::Some(CipherSuiteProto::AES_CTR_NOPADDING),
            3 => ::std::option::Option::Some(CipherSuiteProto::SM4_CTR_NOPADDING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CipherSuiteProto] = &[
            CipherSuiteProto::UNKNOWN,
            CipherSuiteProto::AES_CTR_NOPADDING,
            CipherSuiteProto::SM4_CTR_NOPADDING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CipherSuiteProto>("CipherSuiteProto", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CipherSuiteProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CipherSuiteProto {
    fn default() -> Self {
        CipherSuiteProto::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for CipherSuiteProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CryptoProtocolVersionProto {
    UNKNOWN_PROTOCOL_VERSION = 1,
    ENCRYPTION_ZONES = 2,
}

impl ::protobuf::ProtobufEnum for CryptoProtocolVersionProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CryptoProtocolVersionProto> {
        match value {
            1 => ::std::option::Option::Some(CryptoProtocolVersionProto::UNKNOWN_PROTOCOL_VERSION),
            2 => ::std::option::Option::Some(CryptoProtocolVersionProto::ENCRYPTION_ZONES),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CryptoProtocolVersionProto] = &[
            CryptoProtocolVersionProto::UNKNOWN_PROTOCOL_VERSION,
            CryptoProtocolVersionProto::ENCRYPTION_ZONES,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CryptoProtocolVersionProto>("CryptoProtocolVersionProto", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CryptoProtocolVersionProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CryptoProtocolVersionProto {
    fn default() -> Self {
        CryptoProtocolVersionProto::UNKNOWN_PROTOCOL_VERSION
    }
}

impl ::protobuf::reflect::ProtobufValue for CryptoProtocolVersionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ErasureCodingPolicyState {
    DISABLED = 1,
    ENABLED = 2,
    REMOVED = 3,
}

impl ::protobuf::ProtobufEnum for ErasureCodingPolicyState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ErasureCodingPolicyState> {
        match value {
            1 => ::std::option::Option::Some(ErasureCodingPolicyState::DISABLED),
            2 => ::std::option::Option::Some(ErasureCodingPolicyState::ENABLED),
            3 => ::std::option::Option::Some(ErasureCodingPolicyState::REMOVED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ErasureCodingPolicyState] = &[
            ErasureCodingPolicyState::DISABLED,
            ErasureCodingPolicyState::ENABLED,
            ErasureCodingPolicyState::REMOVED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ErasureCodingPolicyState>("ErasureCodingPolicyState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ErasureCodingPolicyState {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ErasureCodingPolicyState {
    fn default() -> Self {
        ErasureCodingPolicyState::DISABLED
    }
}

impl ::protobuf::reflect::ProtobufValue for ErasureCodingPolicyState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ChecksumTypeProto {
    CHECKSUM_NULL = 0,
    CHECKSUM_CRC32 = 1,
    CHECKSUM_CRC32C = 2,
}

impl ::protobuf::ProtobufEnum for ChecksumTypeProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ChecksumTypeProto> {
        match value {
            0 => ::std::option::Option::Some(ChecksumTypeProto::CHECKSUM_NULL),
            1 => ::std::option::Option::Some(ChecksumTypeProto::CHECKSUM_CRC32),
            2 => ::std::option::Option::Some(ChecksumTypeProto::CHECKSUM_CRC32C),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ChecksumTypeProto] = &[
            ChecksumTypeProto::CHECKSUM_NULL,
            ChecksumTypeProto::CHECKSUM_CRC32,
            ChecksumTypeProto::CHECKSUM_CRC32C,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ChecksumTypeProto>("ChecksumTypeProto", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ChecksumTypeProto {
}

impl ::std::default::Default for ChecksumTypeProto {
    fn default() -> Self {
        ChecksumTypeProto::CHECKSUM_NULL
    }
}

impl ::protobuf::reflect::ProtobufValue for ChecksumTypeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BlockChecksumTypeProto {
    MD5CRC = 1,
    COMPOSITE_CRC = 2,
}

impl ::protobuf::ProtobufEnum for BlockChecksumTypeProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BlockChecksumTypeProto> {
        match value {
            1 => ::std::option::Option::Some(BlockChecksumTypeProto::MD5CRC),
            2 => ::std::option::Option::Some(BlockChecksumTypeProto::COMPOSITE_CRC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BlockChecksumTypeProto] = &[
            BlockChecksumTypeProto::MD5CRC,
            BlockChecksumTypeProto::COMPOSITE_CRC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BlockChecksumTypeProto>("BlockChecksumTypeProto", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BlockChecksumTypeProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for BlockChecksumTypeProto {
    fn default() -> Self {
        BlockChecksumTypeProto::MD5CRC
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockChecksumTypeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AccessModeProto {
    READ = 1,
    WRITE = 2,
    COPY = 3,
    REPLACE = 4,
}

impl ::protobuf::ProtobufEnum for AccessModeProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AccessModeProto> {
        match value {
            1 => ::std::option::Option::Some(AccessModeProto::READ),
            2 => ::std::option::Option::Some(AccessModeProto::WRITE),
            3 => ::std::option::Option::Some(AccessModeProto::COPY),
            4 => ::std::option::Option::Some(AccessModeProto::REPLACE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AccessModeProto] = &[
            AccessModeProto::READ,
            AccessModeProto::WRITE,
            AccessModeProto::COPY,
            AccessModeProto::REPLACE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AccessModeProto>("AccessModeProto", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AccessModeProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for AccessModeProto {
    fn default() -> Self {
        AccessModeProto::READ
    }
}

impl ::protobuf::reflect::ProtobufValue for AccessModeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\nhdfs.proto\x12\x0bhadoop.hdfs\x1a\x0eSecurity.proto\x1a\tacl.proto\"\
    \x8f\x01\n\x12ExtendedBlockProto\x12\x16\n\x06poolId\x18\x01\x20\x02(\tR\
    \x06poolId\x12\x18\n\x07blockId\x18\x02\x20\x02(\x04R\x07blockId\x12(\n\
    \x0fgenerationStamp\x18\x03\x20\x02(\x04R\x0fgenerationStamp\x12\x1d\n\
    \x08numBytes\x18\x04\x20\x01(\x04:\x010R\x08numBytes\"x\n\x1cProvidedSto\
    rageLocationProto\x12\x12\n\x04path\x18\x01\x20\x02(\tR\x04path\x12\x16\
    \n\x06offset\x18\x02\x20\x02(\x03R\x06offset\x12\x16\n\x06length\x18\x03\
    \x20\x02(\x03R\x06length\x12\x14\n\x05nonce\x18\x04\x20\x02(\x0cR\x05non\
    ce\"\xe6\x01\n\x0fDatanodeIDProto\x12\x16\n\x06ipAddr\x18\x01\x20\x02(\t\
    R\x06ipAddr\x12\x1a\n\x08hostName\x18\x02\x20\x02(\tR\x08hostName\x12\"\
    \n\x0cdatanodeUuid\x18\x03\x20\x02(\tR\x0cdatanodeUuid\x12\x1a\n\x08xfer\
    Port\x18\x04\x20\x02(\rR\x08xferPort\x12\x1a\n\x08infoPort\x18\x05\x20\
    \x02(\rR\x08infoPort\x12\x18\n\x07ipcPort\x18\x06\x20\x02(\rR\x07ipcPort\
    \x12)\n\x0einfoSecurePort\x18\x07\x20\x01(\r:\x010R\x0einfoSecurePort\"\
    \x80\x01\n\x16DatanodeLocalInfoProto\x12(\n\x0fsoftwareVersion\x18\x01\
    \x20\x02(\tR\x0fsoftwareVersion\x12$\n\rconfigVersion\x18\x02\x20\x02(\t\
    R\rconfigVersion\x12\x16\n\x06uptime\x18\x03\x20\x02(\x04R\x06uptime\"\
    \xaa\x02\n\x17DatanodeVolumeInfoProto\x12\x12\n\x04path\x18\x01\x20\x02(\
    \tR\x04path\x12?\n\x0bstorageType\x18\x02\x20\x02(\x0e2\x1d.hadoop.hdfs.\
    StorageTypeProtoR\x0bstorageType\x12\x1c\n\tusedSpace\x18\x03\x20\x02(\
    \x04R\tusedSpace\x12\x1c\n\tfreeSpace\x18\x04\x20\x02(\x04R\tfreeSpace\
    \x12$\n\rreservedSpace\x18\x05\x20\x02(\x04R\rreservedSpace\x12:\n\x18re\
    servedSpaceForReplicas\x18\x06\x20\x02(\x04R\x18reservedSpaceForReplicas\
    \x12\x1c\n\tnumBlocks\x18\x07\x20\x02(\x04R\tnumBlocks\"R\n\x12DatanodeI\
    nfosProto\x12<\n\tdatanodes\x18\x01\x20\x03(\x0b2\x1e.hadoop.hdfs.Datano\
    deInfoProtoR\tdatanodes\"\xd3\x06\n\x11DatanodeInfoProto\x12,\n\x02id\
    \x18\x01\x20\x02(\x0b2\x1c.hadoop.hdfs.DatanodeIDProtoR\x02id\x12\x1d\n\
    \x08capacity\x18\x02\x20\x01(\x04:\x010R\x08capacity\x12\x1b\n\x07dfsUse\
    d\x18\x03\x20\x01(\x04:\x010R\x07dfsUsed\x12\x1f\n\tremaining\x18\x04\
    \x20\x01(\x04:\x010R\tremaining\x12'\n\rblockPoolUsed\x18\x05\x20\x01(\
    \x04:\x010R\rblockPoolUsed\x12!\n\nlastUpdate\x18\x06\x20\x01(\x04:\x010\
    R\nlastUpdate\x12%\n\x0cxceiverCount\x18\x07\x20\x01(\r:\x010R\x0cxceive\
    rCount\x12\x1a\n\x08location\x18\x08\x20\x01(\tR\x08location\x12\x1e\n\n\
    nonDfsUsed\x18\t\x20\x01(\x04R\nnonDfsUsed\x12Q\n\nadminState\x18\n\x20\
    \x01(\x0e2).hadoop.hdfs.DatanodeInfoProto.AdminState:\x06NORMALR\nadminS\
    tate\x12'\n\rcacheCapacity\x18\x0b\x20\x01(\x04:\x010R\rcacheCapacity\
    \x12\x1f\n\tcacheUsed\x18\x0c\x20\x01(\x04:\x010R\tcacheUsed\x123\n\x13l\
    astUpdateMonotonic\x18\r\x20\x01(\x04:\x010R\x13lastUpdateMonotonic\x12$\
    \n\rupgradeDomain\x18\x0e\x20\x01(\tR\rupgradeDomain\x123\n\x13lastBlock\
    ReportTime\x18\x0f\x20\x01(\x04:\x010R\x13lastBlockReportTime\x12=\n\x18\
    lastBlockReportMonotonic\x18\x10\x20\x01(\x04:\x010R\x18lastBlockReportM\
    onotonic\x12\x1f\n\tnumBlocks\x18\x11\x20\x01(\r:\x010R\tnumBlocks\"w\n\
    \nAdminState\x12\n\n\x06NORMAL\x10\0\x12\x1b\n\x17DECOMMISSION_INPROGRES\
    S\x10\x01\x12\x12\n\x0eDECOMMISSIONED\x10\x02\x12\x18\n\x14ENTERING_MAIN\
    TENANCE\x10\x03\x12\x12\n\x0eIN_MAINTENANCE\x10\x04\"\xff\x01\n\x14Datan\
    odeStorageProto\x12\x20\n\x0bstorageUuid\x18\x01\x20\x02(\tR\x0bstorageU\
    uid\x12L\n\x05state\x18\x02\x20\x01(\x0e2..hadoop.hdfs.DatanodeStoragePr\
    oto.StorageState:\x06NORMALR\x05state\x12E\n\x0bstorageType\x18\x03\x20\
    \x01(\x0e2\x1d.hadoop.hdfs.StorageTypeProto:\x04DISKR\x0bstorageType\"0\
    \n\x0cStorageState\x12\n\n\x06NORMAL\x10\0\x12\x14\n\x10READ_ONLY_SHARED\
    \x10\x01\"\xd2\x02\n\x12StorageReportProto\x12$\n\x0bstorageUuid\x18\x01\
    \x20\x02(\tR\x0bstorageUuidB\x02\x18\x01\x12\x1d\n\x06failed\x18\x02\x20\
    \x01(\x08:\x05falseR\x06failed\x12\x1d\n\x08capacity\x18\x03\x20\x01(\
    \x04:\x010R\x08capacity\x12\x1b\n\x07dfsUsed\x18\x04\x20\x01(\x04:\x010R\
    \x07dfsUsed\x12\x1f\n\tremaining\x18\x05\x20\x01(\x04:\x010R\tremaining\
    \x12'\n\rblockPoolUsed\x18\x06\x20\x01(\x04:\x010R\rblockPoolUsed\x12;\n\
    \x07storage\x18\x07\x20\x01(\x0b2!.hadoop.hdfs.DatanodeStorageProtoR\x07\
    storage\x12\x1e\n\nnonDfsUsed\x18\x08\x20\x01(\x04R\nnonDfsUsed\x12\x14\
    \n\x05mount\x18\t\x20\x01(\tR\x05mount\"\x96\x04\n\x13ContentSummaryProt\
    o\x12\x16\n\x06length\x18\x01\x20\x02(\x04R\x06length\x12\x1c\n\tfileCou\
    nt\x18\x02\x20\x02(\x04R\tfileCount\x12&\n\x0edirectoryCount\x18\x03\x20\
    \x02(\x04R\x0edirectoryCount\x12\x14\n\x05quota\x18\x04\x20\x02(\x04R\
    \x05quota\x12$\n\rspaceConsumed\x18\x05\x20\x02(\x04R\rspaceConsumed\x12\
    \x1e\n\nspaceQuota\x18\x06\x20\x02(\x04R\nspaceQuota\x12O\n\x0etypeQuota\
    Infos\x18\x07\x20\x01(\x0b2'.hadoop.hdfs.StorageTypeQuotaInfosProtoR\x0e\
    typeQuotaInfos\x12&\n\x0esnapshotLength\x18\x08\x20\x01(\x04R\x0esnapsho\
    tLength\x12,\n\x11snapshotFileCount\x18\t\x20\x01(\x04R\x11snapshotFileC\
    ount\x126\n\x16snapshotDirectoryCount\x18\n\x20\x01(\x04R\x16snapshotDir\
    ectoryCount\x124\n\x15snapshotSpaceConsumed\x18\x0b\x20\x01(\x04R\x15sna\
    pshotSpaceConsumed\x120\n\x13erasureCodingPolicy\x18\x0c\x20\x01(\tR\x13\
    erasureCodingPolicy\"\xf4\x01\n\x0fQuotaUsageProto\x124\n\x15fileAndDire\
    ctoryCount\x18\x01\x20\x02(\x04R\x15fileAndDirectoryCount\x12\x14\n\x05q\
    uota\x18\x02\x20\x02(\x04R\x05quota\x12$\n\rspaceConsumed\x18\x03\x20\
    \x02(\x04R\rspaceConsumed\x12\x1e\n\nspaceQuota\x18\x04\x20\x02(\x04R\ns\
    paceQuota\x12O\n\x0etypeQuotaInfos\x18\x05\x20\x01(\x0b2'.hadoop.hdfs.St\
    orageTypeQuotaInfosProtoR\x0etypeQuotaInfos\"j\n\x1aStorageTypeQuotaInfo\
    sProto\x12L\n\rtypeQuotaInfo\x18\x01\x20\x03(\x0b2&.hadoop.hdfs.StorageT\
    ypeQuotaInfoProtoR\rtypeQuotaInfo\"\x86\x01\n\x19StorageTypeQuotaInfoPro\
    to\x127\n\x04type\x18\x01\x20\x01(\x0e2\x1d.hadoop.hdfs.StorageTypeProto\
    :\x04DISKR\x04type\x12\x14\n\x05quota\x18\x02\x20\x02(\x04R\x05quota\x12\
    \x1a\n\x08consumed\x18\x03\x20\x02(\x04R\x08consumed\"F\n\x16CorruptFile\
    BlocksProto\x12\x14\n\x05files\x18\x01\x20\x03(\tR\x05files\x12\x16\n\
    \x06cookie\x18\x02\x20\x02(\tR\x06cookie\"V\n\x11StorageTypesProto\x12A\
    \n\x0cstorageTypes\x18\x01\x20\x03(\x0e2\x1d.hadoop.hdfs.StorageTypeProt\
    oR\x0cstorageTypes\"\xc7\x02\n\x17BlockStoragePolicyProto\x12\x1a\n\x08p\
    olicyId\x18\x01\x20\x02(\rR\x08policyId\x12\x12\n\x04name\x18\x02\x20\
    \x02(\tR\x04name\x12F\n\x0ecreationPolicy\x18\x03\x20\x02(\x0b2\x1e.hado\
    op.hdfs.StorageTypesProtoR\x0ecreationPolicy\x12V\n\x16creationFallbackP\
    olicy\x18\x04\x20\x01(\x0b2\x1e.hadoop.hdfs.StorageTypesProtoR\x16creati\
    onFallbackPolicy\x12\\\n\x19replicationFallbackPolicy\x18\x05\x20\x01(\
    \x0b2\x1e.hadoop.hdfs.StorageTypesProtoR\x19replicationFallbackPolicy\"\
    \xc7\x03\n\x11LocatedBlockProto\x12-\n\x01b\x18\x01\x20\x02(\x0b2\x1f.ha\
    doop.hdfs.ExtendedBlockProtoR\x01b\x12\x16\n\x06offset\x18\x02\x20\x02(\
    \x04R\x06offset\x122\n\x04locs\x18\x03\x20\x03(\x0b2\x1e.hadoop.hdfs.Dat\
    anodeInfoProtoR\x04locs\x12\x18\n\x07corrupt\x18\x04\x20\x02(\x08R\x07co\
    rrupt\x129\n\nblockToken\x18\x05\x20\x02(\x0b2\x19.hadoop.common.TokenPr\
    otoR\nblockToken\x12\x1e\n\x08isCached\x18\x06\x20\x03(\x08R\x08isCached\
    B\x02\x10\x01\x12A\n\x0cstorageTypes\x18\x07\x20\x03(\x0e2\x1d.hadoop.hd\
    fs.StorageTypeProtoR\x0cstorageTypes\x12\x1e\n\nstorageIDs\x18\x08\x20\
    \x03(\tR\nstorageIDs\x12\"\n\x0cblockIndices\x18\t\x20\x01(\x0cR\x0cbloc\
    kIndices\x12;\n\x0bblockTokens\x18\n\x20\x03(\x0b2\x19.hadoop.common.Tok\
    enProtoR\x0bblockTokens\"r\n\x16BatchedListingKeyProto\x12\x1a\n\x08chec\
    ksum\x18\x01\x20\x02(\x0cR\x08checksum\x12\x1c\n\tpathIndex\x18\x02\x20\
    \x02(\rR\tpathIndex\x12\x1e\n\nstartAfter\x18\x03\x20\x02(\x0cR\nstartAf\
    ter\"\xde\x01\n\x16DataEncryptionKeyProto\x12\x14\n\x05keyId\x18\x01\x20\
    \x02(\rR\x05keyId\x12\x20\n\x0bblockPoolId\x18\x02\x20\x02(\tR\x0bblockP\
    oolId\x12\x14\n\x05nonce\x18\x03\x20\x02(\x0cR\x05nonce\x12$\n\rencrypti\
    onKey\x18\x04\x20\x02(\x0cR\rencryptionKey\x12\x1e\n\nexpiryDate\x18\x05\
    \x20\x02(\x04R\nexpiryDate\x120\n\x13encryptionAlgorithm\x18\x06\x20\x01\
    (\tR\x13encryptionAlgorithm\"\x95\x02\n\x17FileEncryptionInfoProto\x123\
    \n\x05suite\x18\x01\x20\x02(\x0e2\x1d.hadoop.hdfs.CipherSuiteProtoR\x05s\
    uite\x12]\n\x15cryptoProtocolVersion\x18\x02\x20\x02(\x0e2'.hadoop.hdfs.\
    CryptoProtocolVersionProtoR\x15cryptoProtocolVersion\x12\x10\n\x03key\
    \x18\x03\x20\x02(\x0cR\x03key\x12\x0e\n\x02iv\x18\x04\x20\x02(\x0cR\x02i\
    v\x12\x18\n\x07keyName\x18\x05\x20\x02(\tR\x07keyName\x12*\n\x10ezKeyVer\
    sionName\x18\x06\x20\x02(\tR\x10ezKeyVersionName\"j\n\x1aPerFileEncrypti\
    onInfoProto\x12\x10\n\x03key\x18\x01\x20\x02(\x0cR\x03key\x12\x0e\n\x02i\
    v\x18\x02\x20\x02(\x0cR\x02iv\x12*\n\x10ezKeyVersionName\x18\x03\x20\x02\
    (\tR\x10ezKeyVersionName\"\x99\x02\n\x17ZoneEncryptionInfoProto\x123\n\
    \x05suite\x18\x01\x20\x02(\x0e2\x1d.hadoop.hdfs.CipherSuiteProtoR\x05sui\
    te\x12]\n\x15cryptoProtocolVersion\x18\x02\x20\x02(\x0e2'.hadoop.hdfs.Cr\
    yptoProtocolVersionProtoR\x15cryptoProtocolVersion\x12\x18\n\x07keyName\
    \x18\x03\x20\x02(\tR\x07keyName\x12P\n\x11reencryptionProto\x18\x04\x20\
    \x01(\x0b2\".hadoop.hdfs.ReencryptionInfoProtoR\x11reencryptionProto\"\
    \x95\x02\n\x15ReencryptionInfoProto\x12*\n\x10ezKeyVersionName\x18\x01\
    \x20\x02(\tR\x10ezKeyVersionName\x12&\n\x0esubmissionTime\x18\x02\x20\
    \x02(\x04R\x0esubmissionTime\x12\x1a\n\x08canceled\x18\x03\x20\x02(\x08R\
    \x08canceled\x12&\n\x0enumReencrypted\x18\x04\x20\x02(\x03R\x0enumReencr\
    ypted\x12\x20\n\x0bnumFailures\x18\x05\x20\x02(\x03R\x0bnumFailures\x12&\
    \n\x0ecompletionTime\x18\x06\x20\x01(\x04R\x0ecompletionTime\x12\x1a\n\
    \x08lastFile\x18\x07\x20\x01(\tR\x08lastFile\"\xa0\x01\n\x11CipherOption\
    Proto\x123\n\x05suite\x18\x01\x20\x02(\x0e2\x1d.hadoop.hdfs.CipherSuiteP\
    rotoR\x05suite\x12\x14\n\x05inKey\x18\x02\x20\x01(\x0cR\x05inKey\x12\x12\
    \n\x04inIv\x18\x03\x20\x01(\x0cR\x04inIv\x12\x16\n\x06outKey\x18\x04\x20\
    \x01(\x0cR\x06outKey\x12\x14\n\x05outIv\x18\x05\x20\x01(\x0cR\x05outIv\"\
    \xa3\x03\n\x12LocatedBlocksProto\x12\x1e\n\nfileLength\x18\x01\x20\x02(\
    \x04R\nfileLength\x126\n\x06blocks\x18\x02\x20\x03(\x0b2\x1e.hadoop.hdfs\
    .LocatedBlockProtoR\x06blocks\x12,\n\x11underConstruction\x18\x03\x20\
    \x02(\x08R\x11underConstruction\x12<\n\tlastBlock\x18\x04\x20\x01(\x0b2\
    \x1e.hadoop.hdfs.LocatedBlockProtoR\tlastBlock\x120\n\x13isLastBlockComp\
    lete\x18\x05\x20\x02(\x08R\x13isLastBlockComplete\x12T\n\x12fileEncrypti\
    onInfo\x18\x06\x20\x01(\x0b2$.hadoop.hdfs.FileEncryptionInfoProtoR\x12fi\
    leEncryptionInfo\x12A\n\x08ecPolicy\x18\x07\x20\x01(\x0b2%.hadoop.hdfs.E\
    rasureCodingPolicyProtoR\x08ecPolicy\"B\n\x18ECSchemaOptionEntryProto\
    \x12\x10\n\x03key\x18\x01\x20\x02(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x02(\tR\x05value\"\xae\x01\n\rECSchemaProto\x12\x1c\n\tcodecName\
    \x18\x01\x20\x02(\tR\tcodecName\x12\x1c\n\tdataUnits\x18\x02\x20\x02(\rR\
    \tdataUnits\x12\x20\n\x0bparityUnits\x18\x03\x20\x02(\rR\x0bparityUnits\
    \x12?\n\x07options\x18\x04\x20\x03(\x0b2%.hadoop.hdfs.ECSchemaOptionEntr\
    yProtoR\x07options\"\xd4\x01\n\x18ErasureCodingPolicyProto\x12\x12\n\x04\
    name\x18\x01\x20\x01(\tR\x04name\x122\n\x06schema\x18\x02\x20\x01(\x0b2\
    \x1a.hadoop.hdfs.ECSchemaProtoR\x06schema\x12\x1a\n\x08cellSize\x18\x03\
    \x20\x01(\rR\x08cellSize\x12\x0e\n\x02id\x18\x04\x20\x02(\rR\x02id\x12D\
    \n\x05state\x18\x05\x20\x01(\x0e2%.hadoop.hdfs.ErasureCodingPolicyState:\
    \x07ENABLEDR\x05state\"\x9a\x01\n#AddErasureCodingPolicyResponseProto\
    \x12=\n\x06policy\x18\x01\x20\x02(\x0b2%.hadoop.hdfs.ErasureCodingPolicy\
    ProtoR\x06policy\x12\x18\n\x07succeed\x18\x02\x20\x02(\x08R\x07succeed\
    \x12\x1a\n\x08errorMsg\x18\x03\x20\x01(\tR\x08errorMsg\"g\n\x1dECTopolog\
    yVerifierResultProto\x12$\n\rresultMessage\x18\x01\x20\x02(\tR\rresultMe\
    ssage\x12\x20\n\x0bisSupported\x18\x02\x20\x02(\x08R\x0bisSupported\"Y\n\
    \x13HdfsPathHandleProto\x12\x18\n\x07inodeId\x18\x01\x20\x01(\x04R\x07in\
    odeId\x12\x14\n\x05mtime\x18\x02\x20\x01(\x04R\x05mtime\x12\x12\n\x04pat\
    h\x18\x03\x20\x01(\tR\x04path\"\x84\x07\n\x13HdfsFileStatusProto\x12E\n\
    \x08fileType\x18\x01\x20\x02(\x0e2).hadoop.hdfs.HdfsFileStatusProto.File\
    TypeR\x08fileType\x12\x12\n\x04path\x18\x02\x20\x02(\x0cR\x04path\x12\
    \x16\n\x06length\x18\x03\x20\x02(\x04R\x06length\x12>\n\npermission\x18\
    \x04\x20\x02(\x0b2\x1e.hadoop.hdfs.FsPermissionProtoR\npermission\x12\
    \x14\n\x05owner\x18\x05\x20\x02(\tR\x05owner\x12\x14\n\x05group\x18\x06\
    \x20\x02(\tR\x05group\x12+\n\x11modification_time\x18\x07\x20\x02(\x04R\
    \x10modificationTime\x12\x1f\n\x0baccess_time\x18\x08\x20\x02(\x04R\nacc\
    essTime\x12\x18\n\x07symlink\x18\t\x20\x01(\x0cR\x07symlink\x12.\n\x11bl\
    ock_replication\x18\n\x20\x01(\r:\x010R\x10blockReplication\x12\x1f\n\tb\
    locksize\x18\x0b\x20\x01(\x04:\x010R\tblocksize\x12=\n\tlocations\x18\
    \x0c\x20\x01(\x0b2\x1f.hadoop.hdfs.LocatedBlocksProtoR\tlocations\x12\
    \x19\n\x06fileId\x18\r\x20\x01(\x04:\x010R\x06fileId\x12$\n\x0bchildrenN\
    um\x18\x0e\x20\x01(\x05:\x02-1R\x0bchildrenNum\x12T\n\x12fileEncryptionI\
    nfo\x18\x0f\x20\x01(\x0b2$.hadoop.hdfs.FileEncryptionInfoProtoR\x12fileE\
    ncryptionInfo\x12'\n\rstoragePolicy\x18\x10\x20\x01(\r:\x010R\rstoragePo\
    licy\x12A\n\x08ecPolicy\x18\x11\x20\x01(\x0b2%.hadoop.hdfs.ErasureCoding\
    PolicyProtoR\x08ecPolicy\x12\x17\n\x05flags\x18\x12\x20\x01(\r:\x010R\
    \x05flags\"3\n\x08FileType\x12\n\n\x06IS_DIR\x10\x01\x12\x0b\n\x07IS_FIL\
    E\x10\x02\x12\x0e\n\nIS_SYMLINK\x10\x03\"E\n\x05Flags\x12\x0b\n\x07HAS_A\
    CL\x10\x01\x12\r\n\tHAS_CRYPT\x10\x02\x12\n\n\x06HAS_EC\x10\x04\x12\x14\
    \n\x10SNAPSHOT_ENABLED\x10\x08\"\x9a\x01\n\x19BlockChecksumOptionsProto\
    \x12Y\n\x11blockChecksumType\x18\x01\x20\x01(\x0e2#.hadoop.hdfs.BlockChe\
    cksumTypeProto:\x06MD5CRCR\x11blockChecksumType\x12\"\n\x0cstripeLength\
    \x18\x02\x20\x01(\x04R\x0cstripeLength\"\x95\x04\n\x15FsServerDefaultsPr\
    oto\x12\x1c\n\tblockSize\x18\x01\x20\x02(\x04R\tblockSize\x12*\n\x10byte\
    sPerChecksum\x18\x02\x20\x02(\rR\x10bytesPerChecksum\x12(\n\x0fwritePack\
    etSize\x18\x03\x20\x02(\rR\x0fwritePacketSize\x12\x20\n\x0breplication\
    \x18\x04\x20\x02(\rR\x0breplication\x12&\n\x0efileBufferSize\x18\x05\x20\
    \x02(\rR\x0efileBufferSize\x127\n\x13encryptDataTransfer\x18\x06\x20\x01\
    (\x08:\x05falseR\x13encryptDataTransfer\x12'\n\rtrashInterval\x18\x07\
    \x20\x01(\x04:\x010R\rtrashInterval\x12R\n\x0cchecksumType\x18\x08\x20\
    \x01(\x0e2\x1e.hadoop.hdfs.ChecksumTypeProto:\x0eCHECKSUM_CRC32R\x0cchec\
    ksumType\x12&\n\x0ekeyProviderUri\x18\t\x20\x01(\tR\x0ekeyProviderUri\
    \x12\x1d\n\x08policyId\x18\n\x20\x01(\r:\x010R\x08policyId\x12A\n\x18sna\
    pshotTrashRootEnabled\x18\x0b\x20\x01(\x08:\x05falseR\x18snapshotTrashRo\
    otEnabled\"\x8d\x01\n\x15DirectoryListingProto\x12H\n\x0epartialListing\
    \x18\x01\x20\x03(\x0b2\x20.hadoop.hdfs.HdfsFileStatusProtoR\x0epartialLi\
    sting\x12*\n\x10remainingEntries\x18\x02\x20\x02(\rR\x10remainingEntries\
    \"N\n\x14RemoteExceptionProto\x12\x1c\n\tclassName\x18\x01\x20\x02(\tR\t\
    className\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\"\xc7\x01\
    \n\x1cBatchedDirectoryListingProto\x12H\n\x0epartialListing\x18\x01\x20\
    \x03(\x0b2\x20.hadoop.hdfs.HdfsFileStatusProtoR\x0epartialListing\x12\
    \x1c\n\tparentIdx\x18\x02\x20\x02(\rR\tparentIdx\x12?\n\texception\x18\
    \x03\x20\x01(\x0b2!.hadoop.hdfs.RemoteExceptionProtoR\texception\"\xdc\
    \x01\n!SnapshottableDirectoryStatusProto\x12>\n\tdirStatus\x18\x01\x20\
    \x02(\x0b2\x20.hadoop.hdfs.HdfsFileStatusProtoR\tdirStatus\x12%\n\x0esna\
    pshot_quota\x18\x02\x20\x02(\rR\rsnapshotQuota\x12'\n\x0fsnapshot_number\
    \x18\x03\x20\x02(\rR\x0esnapshotNumber\x12'\n\x0fparent_fullpath\x18\x04\
    \x20\x02(\x0cR\x0eparentFullpath\"\xbc\x01\n\x13SnapshotStatusProto\x12>\
    \n\tdirStatus\x18\x01\x20\x02(\x0b2\x20.hadoop.hdfs.HdfsFileStatusProtoR\
    \tdirStatus\x12\x1e\n\nsnapshotID\x18\x02\x20\x02(\rR\nsnapshotID\x12'\n\
    \x0fparent_fullpath\x18\x03\x20\x02(\x0cR\x0eparentFullpath\x12\x1c\n\ti\
    sDeleted\x18\x04\x20\x02(\x08R\tisDeleted\"\x8e\x01\n\"SnapshottableDire\
    ctoryListingProto\x12h\n\x17snapshottableDirListing\x18\x01\x20\x03(\x0b\
    2..hadoop.hdfs.SnapshottableDirectoryStatusProtoR\x17snapshottableDirLis\
    ting\"b\n\x14SnapshotListingProto\x12J\n\x0fsnapshotListing\x18\x01\x20\
    \x03(\x0b2\x20.hadoop.hdfs.SnapshotStatusProtoR\x0fsnapshotListing\"\x88\
    \x01\n\x1cSnapshotDiffReportEntryProto\x12\x1a\n\x08fullpath\x18\x01\x20\
    \x02(\x0cR\x08fullpath\x12,\n\x11modificationLabel\x18\x02\x20\x02(\tR\
    \x11modificationLabel\x12\x1e\n\ntargetPath\x18\x03\x20\x01(\x0cR\ntarge\
    tPath\"\xda\x01\n\x17SnapshotDiffReportProto\x12\"\n\x0csnapshotRoot\x18\
    \x01\x20\x02(\tR\x0csnapshotRoot\x12\"\n\x0cfromSnapshot\x18\x02\x20\x02\
    (\tR\x0cfromSnapshot\x12\x1e\n\ntoSnapshot\x18\x03\x20\x02(\tR\ntoSnapsh\
    ot\x12W\n\x11diffReportEntries\x18\x04\x20\x03(\x0b2).hadoop.hdfs.Snapsh\
    otDiffReportEntryProtoR\x11diffReportEntries\"\xb1\x01\n#SnapshotDiffRep\
    ortListingEntryProto\x12\x1a\n\x08fullpath\x18\x01\x20\x02(\x0cR\x08full\
    path\x12\x14\n\x05dirId\x18\x02\x20\x02(\x04R\x05dirId\x12\x20\n\x0bisRe\
    ference\x18\x03\x20\x02(\x08R\x0bisReference\x12\x1e\n\ntargetPath\x18\
    \x04\x20\x01(\x0cR\ntargetPath\x12\x16\n\x06fileId\x18\x05\x20\x01(\x04R\
    \x06fileId\"W\n\x1dSnapshotDiffReportCursorProto\x12\x1c\n\tstartPath\
    \x18\x01\x20\x02(\x0cR\tstartPath\x12\x18\n\x05index\x18\x02\x20\x02(\
    \x05:\x02-1R\x05index\"\x9a\x03\n\x1eSnapshotDiffReportListingProto\x12Z\
    \n\x0fmodifiedEntries\x18\x01\x20\x03(\x0b20.hadoop.hdfs.SnapshotDiffRep\
    ortListingEntryProtoR\x0fmodifiedEntries\x12X\n\x0ecreatedEntries\x18\
    \x02\x20\x03(\x0b20.hadoop.hdfs.SnapshotDiffReportListingEntryProtoR\x0e\
    createdEntries\x12X\n\x0edeletedEntries\x18\x03\x20\x03(\x0b20.hadoop.hd\
    fs.SnapshotDiffReportListingEntryProtoR\x0edeletedEntries\x12$\n\risFrom\
    Earlier\x18\x04\x20\x02(\x08R\risFromEarlier\x12B\n\x06cursor\x18\x05\
    \x20\x01(\x0b2*.hadoop.hdfs.SnapshotDiffReportCursorProtoR\x06cursor\"a\
    \n\nBlockProto\x12\x18\n\x07blockId\x18\x01\x20\x02(\x04R\x07blockId\x12\
    \x1a\n\x08genStamp\x18\x02\x20\x02(\x04R\x08genStamp\x12\x1d\n\x08numByt\
    es\x18\x03\x20\x01(\x04:\x010R\x08numBytes\"\xe7\x01\n\x11SnapshotInfoPr\
    oto\x12\"\n\x0csnapshotName\x18\x01\x20\x02(\tR\x0csnapshotName\x12\"\n\
    \x0csnapshotRoot\x18\x02\x20\x02(\tR\x0csnapshotRoot\x12>\n\npermission\
    \x18\x03\x20\x02(\x0b2\x1e.hadoop.hdfs.FsPermissionProtoR\npermission\
    \x12\x14\n\x05owner\x18\x04\x20\x02(\tR\x05owner\x12\x14\n\x05group\x18\
    \x05\x20\x02(\tR\x05group\x12\x1e\n\ncreateTime\x18\x06\x20\x02(\tR\ncre\
    ateTime\"b\n\x19RollingUpgradeStatusProto\x12\x20\n\x0bblockPoolId\x18\
    \x01\x20\x02(\tR\x0bblockPoolId\x12#\n\tfinalized\x18\x02\x20\x01(\x08:\
    \x05falseR\tfinalized\"7\n\x11StorageUuidsProto\x12\"\n\x0cstorageUuids\
    \x18\x01\x20\x03(\tR\x0cstorageUuids\"\xe2\x02\n\x15BlockTokenSecretProt\
    o\x12\x1e\n\nexpiryDate\x18\x01\x20\x01(\x04R\nexpiryDate\x12\x14\n\x05k\
    eyId\x18\x02\x20\x01(\rR\x05keyId\x12\x16\n\x06userId\x18\x03\x20\x01(\t\
    R\x06userId\x12\x20\n\x0bblockPoolId\x18\x04\x20\x01(\tR\x0bblockPoolId\
    \x12\x18\n\x07blockId\x18\x05\x20\x01(\x04R\x07blockId\x122\n\x05modes\
    \x18\x06\x20\x03(\x0e2\x1c.hadoop.hdfs.AccessModeProtoR\x05modes\x12A\n\
    \x0cstorageTypes\x18\x07\x20\x03(\x0e2\x1d.hadoop.hdfs.StorageTypeProtoR\
    \x0cstorageTypes\x12\x1e\n\nstorageIds\x18\x08\x20\x03(\tR\nstorageIds\
    \x12(\n\x0fhandshakeSecret\x18\t\x20\x01(\x0cR\x0fhandshakeSecret*Z\n\
    \x10StorageTypeProto\x12\x08\n\x04DISK\x10\x01\x12\x07\n\x03SSD\x10\x02\
    \x12\x0b\n\x07ARCHIVE\x10\x03\x12\x0c\n\x08RAM_DISK\x10\x04\x12\x0c\n\
    \x08PROVIDED\x10\x05\x12\n\n\x06NVDIMM\x10\x06*-\n\x0eBlockTypeProto\x12\
    \x0e\n\nCONTIGUOUS\x10\0\x12\x0b\n\x07STRIPED\x10\x01*M\n\x10CipherSuite\
    Proto\x12\x0b\n\x07UNKNOWN\x10\x01\x12\x15\n\x11AES_CTR_NOPADDING\x10\
    \x02\x12\x15\n\x11SM4_CTR_NOPADDING\x10\x03*P\n\x1aCryptoProtocolVersion\
    Proto\x12\x1c\n\x18UNKNOWN_PROTOCOL_VERSION\x10\x01\x12\x14\n\x10ENCRYPT\
    ION_ZONES\x10\x02*B\n\x18ErasureCodingPolicyState\x12\x0c\n\x08DISABLED\
    \x10\x01\x12\x0b\n\x07ENABLED\x10\x02\x12\x0b\n\x07REMOVED\x10\x03*O\n\
    \x11ChecksumTypeProto\x12\x11\n\rCHECKSUM_NULL\x10\0\x12\x12\n\x0eCHECKS\
    UM_CRC32\x10\x01\x12\x13\n\x0fCHECKSUM_CRC32C\x10\x02*7\n\x16BlockChecks\
    umTypeProto\x12\n\n\x06MD5CRC\x10\x01\x12\x11\n\rCOMPOSITE_CRC\x10\x02*=\
    \n\x0fAccessModeProto\x12\x08\n\x04READ\x10\x01\x12\t\n\x05WRITE\x10\x02\
    \x12\x08\n\x04COPY\x10\x03\x12\x0b\n\x07REPLACE\x10\x04B6\n%org.apache.h\
    adoop.hdfs.protocol.protoB\nHdfsProtos\xa0\x01\x01\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
