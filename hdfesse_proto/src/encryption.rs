// This file is generated by rust-protobuf 2.23.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `encryption.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_23_0;

#[derive(PartialEq,Clone,Default)]
pub struct CreateEncryptionZoneRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    keyName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateEncryptionZoneRequestProto {
    fn default() -> &'a CreateEncryptionZoneRequestProto {
        <CreateEncryptionZoneRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl CreateEncryptionZoneRequestProto {
    pub fn new() -> CreateEncryptionZoneRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string keyName = 2;


    pub fn get_keyName(&self) -> &str {
        match self.keyName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_keyName(&mut self) {
        self.keyName.clear();
    }

    pub fn has_keyName(&self) -> bool {
        self.keyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyName(&mut self, v: ::std::string::String) {
        self.keyName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyName(&mut self) -> &mut ::std::string::String {
        if self.keyName.is_none() {
            self.keyName.set_default();
        }
        self.keyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyName(&mut self) -> ::std::string::String {
        self.keyName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateEncryptionZoneRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.keyName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.keyName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.keyName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateEncryptionZoneRequestProto {
        CreateEncryptionZoneRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &CreateEncryptionZoneRequestProto| { &m.src },
                |m: &mut CreateEncryptionZoneRequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "keyName",
                |m: &CreateEncryptionZoneRequestProto| { &m.keyName },
                |m: &mut CreateEncryptionZoneRequestProto| { &mut m.keyName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateEncryptionZoneRequestProto>(
                "CreateEncryptionZoneRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateEncryptionZoneRequestProto {
        static instance: ::protobuf::rt::LazyV2<CreateEncryptionZoneRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateEncryptionZoneRequestProto::new)
    }
}

impl ::protobuf::Clear for CreateEncryptionZoneRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.keyName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateEncryptionZoneRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateEncryptionZoneRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateEncryptionZoneResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateEncryptionZoneResponseProto {
    fn default() -> &'a CreateEncryptionZoneResponseProto {
        <CreateEncryptionZoneResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl CreateEncryptionZoneResponseProto {
    pub fn new() -> CreateEncryptionZoneResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CreateEncryptionZoneResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateEncryptionZoneResponseProto {
        CreateEncryptionZoneResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateEncryptionZoneResponseProto>(
                "CreateEncryptionZoneResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateEncryptionZoneResponseProto {
        static instance: ::protobuf::rt::LazyV2<CreateEncryptionZoneResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateEncryptionZoneResponseProto::new)
    }
}

impl ::protobuf::Clear for CreateEncryptionZoneResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateEncryptionZoneResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateEncryptionZoneResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEncryptionZonesRequestProto {
    // message fields
    id: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEncryptionZonesRequestProto {
    fn default() -> &'a ListEncryptionZonesRequestProto {
        <ListEncryptionZonesRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ListEncryptionZonesRequestProto {
    pub fn new() -> ListEncryptionZonesRequestProto {
        ::std::default::Default::default()
    }

    // required int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ListEncryptionZonesRequestProto {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEncryptionZonesRequestProto {
        ListEncryptionZonesRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &ListEncryptionZonesRequestProto| { &m.id },
                |m: &mut ListEncryptionZonesRequestProto| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEncryptionZonesRequestProto>(
                "ListEncryptionZonesRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEncryptionZonesRequestProto {
        static instance: ::protobuf::rt::LazyV2<ListEncryptionZonesRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEncryptionZonesRequestProto::new)
    }
}

impl ::protobuf::Clear for ListEncryptionZonesRequestProto {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEncryptionZonesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEncryptionZonesRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncryptionZoneProto {
    // message fields
    id: ::std::option::Option<i64>,
    path: ::protobuf::SingularField<::std::string::String>,
    suite: ::std::option::Option<super::hdfs::CipherSuiteProto>,
    cryptoProtocolVersion: ::std::option::Option<super::hdfs::CryptoProtocolVersionProto>,
    keyName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptionZoneProto {
    fn default() -> &'a EncryptionZoneProto {
        <EncryptionZoneProto as ::protobuf::Message>::default_instance()
    }
}

impl EncryptionZoneProto {
    pub fn new() -> EncryptionZoneProto {
        ::std::default::Default::default()
    }

    // required int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    // required string path = 2;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.CipherSuiteProto suite = 3;


    pub fn get_suite(&self) -> super::hdfs::CipherSuiteProto {
        self.suite.unwrap_or(super::hdfs::CipherSuiteProto::UNKNOWN)
    }
    pub fn clear_suite(&mut self) {
        self.suite = ::std::option::Option::None;
    }

    pub fn has_suite(&self) -> bool {
        self.suite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suite(&mut self, v: super::hdfs::CipherSuiteProto) {
        self.suite = ::std::option::Option::Some(v);
    }

    // required .hadoop.hdfs.CryptoProtocolVersionProto cryptoProtocolVersion = 4;


    pub fn get_cryptoProtocolVersion(&self) -> super::hdfs::CryptoProtocolVersionProto {
        self.cryptoProtocolVersion.unwrap_or(super::hdfs::CryptoProtocolVersionProto::UNKNOWN_PROTOCOL_VERSION)
    }
    pub fn clear_cryptoProtocolVersion(&mut self) {
        self.cryptoProtocolVersion = ::std::option::Option::None;
    }

    pub fn has_cryptoProtocolVersion(&self) -> bool {
        self.cryptoProtocolVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cryptoProtocolVersion(&mut self, v: super::hdfs::CryptoProtocolVersionProto) {
        self.cryptoProtocolVersion = ::std::option::Option::Some(v);
    }

    // required string keyName = 5;


    pub fn get_keyName(&self) -> &str {
        match self.keyName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_keyName(&mut self) {
        self.keyName.clear();
    }

    pub fn has_keyName(&self) -> bool {
        self.keyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyName(&mut self, v: ::std::string::String) {
        self.keyName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyName(&mut self) -> &mut ::std::string::String {
        if self.keyName.is_none() {
            self.keyName.set_default();
        }
        self.keyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyName(&mut self) -> ::std::string::String {
        self.keyName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for EncryptionZoneProto {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.path.is_none() {
            return false;
        }
        if self.suite.is_none() {
            return false;
        }
        if self.cryptoProtocolVersion.is_none() {
            return false;
        }
        if self.keyName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.suite, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.cryptoProtocolVersion, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.keyName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.suite {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.cryptoProtocolVersion {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.keyName.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.suite {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.cryptoProtocolVersion {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.keyName.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptionZoneProto {
        EncryptionZoneProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &EncryptionZoneProto| { &m.id },
                |m: &mut EncryptionZoneProto| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &EncryptionZoneProto| { &m.path },
                |m: &mut EncryptionZoneProto| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::CipherSuiteProto>>(
                "suite",
                |m: &EncryptionZoneProto| { &m.suite },
                |m: &mut EncryptionZoneProto| { &mut m.suite },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::CryptoProtocolVersionProto>>(
                "cryptoProtocolVersion",
                |m: &EncryptionZoneProto| { &m.cryptoProtocolVersion },
                |m: &mut EncryptionZoneProto| { &mut m.cryptoProtocolVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "keyName",
                |m: &EncryptionZoneProto| { &m.keyName },
                |m: &mut EncryptionZoneProto| { &mut m.keyName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EncryptionZoneProto>(
                "EncryptionZoneProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EncryptionZoneProto {
        static instance: ::protobuf::rt::LazyV2<EncryptionZoneProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EncryptionZoneProto::new)
    }
}

impl ::protobuf::Clear for EncryptionZoneProto {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.path.clear();
        self.suite = ::std::option::Option::None;
        self.cryptoProtocolVersion = ::std::option::Option::None;
        self.keyName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptionZoneProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptionZoneProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEncryptionZonesResponseProto {
    // message fields
    pub zones: ::protobuf::RepeatedField<EncryptionZoneProto>,
    hasMore: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEncryptionZonesResponseProto {
    fn default() -> &'a ListEncryptionZonesResponseProto {
        <ListEncryptionZonesResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ListEncryptionZonesResponseProto {
    pub fn new() -> ListEncryptionZonesResponseProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.EncryptionZoneProto zones = 1;


    pub fn get_zones(&self) -> &[EncryptionZoneProto] {
        &self.zones
    }
    pub fn clear_zones(&mut self) {
        self.zones.clear();
    }

    // Param is passed by value, moved
    pub fn set_zones(&mut self, v: ::protobuf::RepeatedField<EncryptionZoneProto>) {
        self.zones = v;
    }

    // Mutable pointer to the field.
    pub fn mut_zones(&mut self) -> &mut ::protobuf::RepeatedField<EncryptionZoneProto> {
        &mut self.zones
    }

    // Take field
    pub fn take_zones(&mut self) -> ::protobuf::RepeatedField<EncryptionZoneProto> {
        ::std::mem::replace(&mut self.zones, ::protobuf::RepeatedField::new())
    }

    // required bool hasMore = 2;


    pub fn get_hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }
    pub fn clear_hasMore(&mut self) {
        self.hasMore = ::std::option::Option::None;
    }

    pub fn has_hasMore(&self) -> bool {
        self.hasMore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMore(&mut self, v: bool) {
        self.hasMore = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ListEncryptionZonesResponseProto {
    fn is_initialized(&self) -> bool {
        if self.hasMore.is_none() {
            return false;
        }
        for v in &self.zones {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.zones)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasMore = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.zones {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.hasMore {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.zones {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.hasMore {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEncryptionZonesResponseProto {
        ListEncryptionZonesResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptionZoneProto>>(
                "zones",
                |m: &ListEncryptionZonesResponseProto| { &m.zones },
                |m: &mut ListEncryptionZonesResponseProto| { &mut m.zones },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasMore",
                |m: &ListEncryptionZonesResponseProto| { &m.hasMore },
                |m: &mut ListEncryptionZonesResponseProto| { &mut m.hasMore },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEncryptionZonesResponseProto>(
                "ListEncryptionZonesResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEncryptionZonesResponseProto {
        static instance: ::protobuf::rt::LazyV2<ListEncryptionZonesResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEncryptionZonesResponseProto::new)
    }
}

impl ::protobuf::Clear for ListEncryptionZonesResponseProto {
    fn clear(&mut self) {
        self.zones.clear();
        self.hasMore = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEncryptionZonesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEncryptionZonesResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReencryptEncryptionZoneRequestProto {
    // message fields
    action: ::std::option::Option<ReencryptActionProto>,
    zone: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReencryptEncryptionZoneRequestProto {
    fn default() -> &'a ReencryptEncryptionZoneRequestProto {
        <ReencryptEncryptionZoneRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ReencryptEncryptionZoneRequestProto {
    pub fn new() -> ReencryptEncryptionZoneRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ReencryptActionProto action = 1;


    pub fn get_action(&self) -> ReencryptActionProto {
        self.action.unwrap_or(ReencryptActionProto::CANCEL_REENCRYPT)
    }
    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ReencryptActionProto) {
        self.action = ::std::option::Option::Some(v);
    }

    // required string zone = 2;


    pub fn get_zone(&self) -> &str {
        match self.zone.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    pub fn has_zone(&self) -> bool {
        self.zone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        if self.zone.is_none() {
            self.zone.set_default();
        }
        self.zone.as_mut().unwrap()
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        self.zone.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ReencryptEncryptionZoneRequestProto {
    fn is_initialized(&self) -> bool {
        if self.action.is_none() {
            return false;
        }
        if self.zone.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.zone)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.zone.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.zone.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReencryptEncryptionZoneRequestProto {
        ReencryptEncryptionZoneRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ReencryptActionProto>>(
                "action",
                |m: &ReencryptEncryptionZoneRequestProto| { &m.action },
                |m: &mut ReencryptEncryptionZoneRequestProto| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &ReencryptEncryptionZoneRequestProto| { &m.zone },
                |m: &mut ReencryptEncryptionZoneRequestProto| { &mut m.zone },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReencryptEncryptionZoneRequestProto>(
                "ReencryptEncryptionZoneRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReencryptEncryptionZoneRequestProto {
        static instance: ::protobuf::rt::LazyV2<ReencryptEncryptionZoneRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReencryptEncryptionZoneRequestProto::new)
    }
}

impl ::protobuf::Clear for ReencryptEncryptionZoneRequestProto {
    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.zone.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReencryptEncryptionZoneRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReencryptEncryptionZoneRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReencryptEncryptionZoneResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReencryptEncryptionZoneResponseProto {
    fn default() -> &'a ReencryptEncryptionZoneResponseProto {
        <ReencryptEncryptionZoneResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ReencryptEncryptionZoneResponseProto {
    pub fn new() -> ReencryptEncryptionZoneResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ReencryptEncryptionZoneResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReencryptEncryptionZoneResponseProto {
        ReencryptEncryptionZoneResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReencryptEncryptionZoneResponseProto>(
                "ReencryptEncryptionZoneResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReencryptEncryptionZoneResponseProto {
        static instance: ::protobuf::rt::LazyV2<ReencryptEncryptionZoneResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReencryptEncryptionZoneResponseProto::new)
    }
}

impl ::protobuf::Clear for ReencryptEncryptionZoneResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReencryptEncryptionZoneResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReencryptEncryptionZoneResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListReencryptionStatusRequestProto {
    // message fields
    id: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListReencryptionStatusRequestProto {
    fn default() -> &'a ListReencryptionStatusRequestProto {
        <ListReencryptionStatusRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ListReencryptionStatusRequestProto {
    pub fn new() -> ListReencryptionStatusRequestProto {
        ::std::default::Default::default()
    }

    // required int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ListReencryptionStatusRequestProto {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListReencryptionStatusRequestProto {
        ListReencryptionStatusRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &ListReencryptionStatusRequestProto| { &m.id },
                |m: &mut ListReencryptionStatusRequestProto| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListReencryptionStatusRequestProto>(
                "ListReencryptionStatusRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListReencryptionStatusRequestProto {
        static instance: ::protobuf::rt::LazyV2<ListReencryptionStatusRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListReencryptionStatusRequestProto::new)
    }
}

impl ::protobuf::Clear for ListReencryptionStatusRequestProto {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListReencryptionStatusRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListReencryptionStatusRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZoneReencryptionStatusProto {
    // message fields
    id: ::std::option::Option<i64>,
    path: ::protobuf::SingularField<::std::string::String>,
    state: ::std::option::Option<ReencryptionStateProto>,
    ezKeyVersionName: ::protobuf::SingularField<::std::string::String>,
    submissionTime: ::std::option::Option<i64>,
    canceled: ::std::option::Option<bool>,
    numReencrypted: ::std::option::Option<i64>,
    numFailures: ::std::option::Option<i64>,
    completionTime: ::std::option::Option<i64>,
    lastFile: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZoneReencryptionStatusProto {
    fn default() -> &'a ZoneReencryptionStatusProto {
        <ZoneReencryptionStatusProto as ::protobuf::Message>::default_instance()
    }
}

impl ZoneReencryptionStatusProto {
    pub fn new() -> ZoneReencryptionStatusProto {
        ::std::default::Default::default()
    }

    // required int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    // required string path = 2;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.ReencryptionStateProto state = 3;


    pub fn get_state(&self) -> ReencryptionStateProto {
        self.state.unwrap_or(ReencryptionStateProto::SUBMITTED)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ReencryptionStateProto) {
        self.state = ::std::option::Option::Some(v);
    }

    // required string ezKeyVersionName = 4;


    pub fn get_ezKeyVersionName(&self) -> &str {
        match self.ezKeyVersionName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ezKeyVersionName(&mut self) {
        self.ezKeyVersionName.clear();
    }

    pub fn has_ezKeyVersionName(&self) -> bool {
        self.ezKeyVersionName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ezKeyVersionName(&mut self, v: ::std::string::String) {
        self.ezKeyVersionName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ezKeyVersionName(&mut self) -> &mut ::std::string::String {
        if self.ezKeyVersionName.is_none() {
            self.ezKeyVersionName.set_default();
        }
        self.ezKeyVersionName.as_mut().unwrap()
    }

    // Take field
    pub fn take_ezKeyVersionName(&mut self) -> ::std::string::String {
        self.ezKeyVersionName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int64 submissionTime = 5;


    pub fn get_submissionTime(&self) -> i64 {
        self.submissionTime.unwrap_or(0)
    }
    pub fn clear_submissionTime(&mut self) {
        self.submissionTime = ::std::option::Option::None;
    }

    pub fn has_submissionTime(&self) -> bool {
        self.submissionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_submissionTime(&mut self, v: i64) {
        self.submissionTime = ::std::option::Option::Some(v);
    }

    // required bool canceled = 6;


    pub fn get_canceled(&self) -> bool {
        self.canceled.unwrap_or(false)
    }
    pub fn clear_canceled(&mut self) {
        self.canceled = ::std::option::Option::None;
    }

    pub fn has_canceled(&self) -> bool {
        self.canceled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_canceled(&mut self, v: bool) {
        self.canceled = ::std::option::Option::Some(v);
    }

    // required int64 numReencrypted = 7;


    pub fn get_numReencrypted(&self) -> i64 {
        self.numReencrypted.unwrap_or(0)
    }
    pub fn clear_numReencrypted(&mut self) {
        self.numReencrypted = ::std::option::Option::None;
    }

    pub fn has_numReencrypted(&self) -> bool {
        self.numReencrypted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numReencrypted(&mut self, v: i64) {
        self.numReencrypted = ::std::option::Option::Some(v);
    }

    // required int64 numFailures = 8;


    pub fn get_numFailures(&self) -> i64 {
        self.numFailures.unwrap_or(0)
    }
    pub fn clear_numFailures(&mut self) {
        self.numFailures = ::std::option::Option::None;
    }

    pub fn has_numFailures(&self) -> bool {
        self.numFailures.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numFailures(&mut self, v: i64) {
        self.numFailures = ::std::option::Option::Some(v);
    }

    // optional int64 completionTime = 9;


    pub fn get_completionTime(&self) -> i64 {
        self.completionTime.unwrap_or(0)
    }
    pub fn clear_completionTime(&mut self) {
        self.completionTime = ::std::option::Option::None;
    }

    pub fn has_completionTime(&self) -> bool {
        self.completionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completionTime(&mut self, v: i64) {
        self.completionTime = ::std::option::Option::Some(v);
    }

    // optional string lastFile = 10;


    pub fn get_lastFile(&self) -> &str {
        match self.lastFile.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_lastFile(&mut self) {
        self.lastFile.clear();
    }

    pub fn has_lastFile(&self) -> bool {
        self.lastFile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastFile(&mut self, v: ::std::string::String) {
        self.lastFile = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastFile(&mut self) -> &mut ::std::string::String {
        if self.lastFile.is_none() {
            self.lastFile.set_default();
        }
        self.lastFile.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastFile(&mut self) -> ::std::string::String {
        self.lastFile.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ZoneReencryptionStatusProto {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.path.is_none() {
            return false;
        }
        if self.state.is_none() {
            return false;
        }
        if self.ezKeyVersionName.is_none() {
            return false;
        }
        if self.submissionTime.is_none() {
            return false;
        }
        if self.canceled.is_none() {
            return false;
        }
        if self.numReencrypted.is_none() {
            return false;
        }
        if self.numFailures.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ezKeyVersionName)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.submissionTime = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.canceled = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.numReencrypted = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.numFailures = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.completionTime = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.lastFile)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(ref v) = self.ezKeyVersionName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.submissionTime {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.canceled {
            my_size += 2;
        }
        if let Some(v) = self.numReencrypted {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numFailures {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.completionTime {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.lastFile.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.state {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.ezKeyVersionName.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.submissionTime {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.canceled {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.numReencrypted {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.numFailures {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.completionTime {
            os.write_int64(9, v)?;
        }
        if let Some(ref v) = self.lastFile.as_ref() {
            os.write_string(10, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZoneReencryptionStatusProto {
        ZoneReencryptionStatusProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &ZoneReencryptionStatusProto| { &m.id },
                |m: &mut ZoneReencryptionStatusProto| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &ZoneReencryptionStatusProto| { &m.path },
                |m: &mut ZoneReencryptionStatusProto| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ReencryptionStateProto>>(
                "state",
                |m: &ZoneReencryptionStatusProto| { &m.state },
                |m: &mut ZoneReencryptionStatusProto| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ezKeyVersionName",
                |m: &ZoneReencryptionStatusProto| { &m.ezKeyVersionName },
                |m: &mut ZoneReencryptionStatusProto| { &mut m.ezKeyVersionName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "submissionTime",
                |m: &ZoneReencryptionStatusProto| { &m.submissionTime },
                |m: &mut ZoneReencryptionStatusProto| { &mut m.submissionTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "canceled",
                |m: &ZoneReencryptionStatusProto| { &m.canceled },
                |m: &mut ZoneReencryptionStatusProto| { &mut m.canceled },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "numReencrypted",
                |m: &ZoneReencryptionStatusProto| { &m.numReencrypted },
                |m: &mut ZoneReencryptionStatusProto| { &mut m.numReencrypted },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "numFailures",
                |m: &ZoneReencryptionStatusProto| { &m.numFailures },
                |m: &mut ZoneReencryptionStatusProto| { &mut m.numFailures },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "completionTime",
                |m: &ZoneReencryptionStatusProto| { &m.completionTime },
                |m: &mut ZoneReencryptionStatusProto| { &mut m.completionTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "lastFile",
                |m: &ZoneReencryptionStatusProto| { &m.lastFile },
                |m: &mut ZoneReencryptionStatusProto| { &mut m.lastFile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ZoneReencryptionStatusProto>(
                "ZoneReencryptionStatusProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ZoneReencryptionStatusProto {
        static instance: ::protobuf::rt::LazyV2<ZoneReencryptionStatusProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ZoneReencryptionStatusProto::new)
    }
}

impl ::protobuf::Clear for ZoneReencryptionStatusProto {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.path.clear();
        self.state = ::std::option::Option::None;
        self.ezKeyVersionName.clear();
        self.submissionTime = ::std::option::Option::None;
        self.canceled = ::std::option::Option::None;
        self.numReencrypted = ::std::option::Option::None;
        self.numFailures = ::std::option::Option::None;
        self.completionTime = ::std::option::Option::None;
        self.lastFile.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZoneReencryptionStatusProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZoneReencryptionStatusProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListReencryptionStatusResponseProto {
    // message fields
    pub statuses: ::protobuf::RepeatedField<ZoneReencryptionStatusProto>,
    hasMore: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListReencryptionStatusResponseProto {
    fn default() -> &'a ListReencryptionStatusResponseProto {
        <ListReencryptionStatusResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ListReencryptionStatusResponseProto {
    pub fn new() -> ListReencryptionStatusResponseProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.ZoneReencryptionStatusProto statuses = 1;


    pub fn get_statuses(&self) -> &[ZoneReencryptionStatusProto] {
        &self.statuses
    }
    pub fn clear_statuses(&mut self) {
        self.statuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_statuses(&mut self, v: ::protobuf::RepeatedField<ZoneReencryptionStatusProto>) {
        self.statuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statuses(&mut self) -> &mut ::protobuf::RepeatedField<ZoneReencryptionStatusProto> {
        &mut self.statuses
    }

    // Take field
    pub fn take_statuses(&mut self) -> ::protobuf::RepeatedField<ZoneReencryptionStatusProto> {
        ::std::mem::replace(&mut self.statuses, ::protobuf::RepeatedField::new())
    }

    // required bool hasMore = 2;


    pub fn get_hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }
    pub fn clear_hasMore(&mut self) {
        self.hasMore = ::std::option::Option::None;
    }

    pub fn has_hasMore(&self) -> bool {
        self.hasMore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMore(&mut self, v: bool) {
        self.hasMore = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ListReencryptionStatusResponseProto {
    fn is_initialized(&self) -> bool {
        if self.hasMore.is_none() {
            return false;
        }
        for v in &self.statuses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statuses)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasMore = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.statuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.hasMore {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.statuses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.hasMore {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListReencryptionStatusResponseProto {
        ListReencryptionStatusResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ZoneReencryptionStatusProto>>(
                "statuses",
                |m: &ListReencryptionStatusResponseProto| { &m.statuses },
                |m: &mut ListReencryptionStatusResponseProto| { &mut m.statuses },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasMore",
                |m: &ListReencryptionStatusResponseProto| { &m.hasMore },
                |m: &mut ListReencryptionStatusResponseProto| { &mut m.hasMore },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListReencryptionStatusResponseProto>(
                "ListReencryptionStatusResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListReencryptionStatusResponseProto {
        static instance: ::protobuf::rt::LazyV2<ListReencryptionStatusResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListReencryptionStatusResponseProto::new)
    }
}

impl ::protobuf::Clear for ListReencryptionStatusResponseProto {
    fn clear(&mut self) {
        self.statuses.clear();
        self.hasMore = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListReencryptionStatusResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListReencryptionStatusResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEZForPathRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetEZForPathRequestProto {
    fn default() -> &'a GetEZForPathRequestProto {
        <GetEZForPathRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetEZForPathRequestProto {
    pub fn new() -> GetEZForPathRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetEZForPathRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEZForPathRequestProto {
        GetEZForPathRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &GetEZForPathRequestProto| { &m.src },
                |m: &mut GetEZForPathRequestProto| { &mut m.src },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetEZForPathRequestProto>(
                "GetEZForPathRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetEZForPathRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetEZForPathRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetEZForPathRequestProto::new)
    }
}

impl ::protobuf::Clear for GetEZForPathRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEZForPathRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEZForPathRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEZForPathResponseProto {
    // message fields
    pub zone: ::protobuf::SingularPtrField<EncryptionZoneProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetEZForPathResponseProto {
    fn default() -> &'a GetEZForPathResponseProto {
        <GetEZForPathResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetEZForPathResponseProto {
    pub fn new() -> GetEZForPathResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.EncryptionZoneProto zone = 1;


    pub fn get_zone(&self) -> &EncryptionZoneProto {
        self.zone.as_ref().unwrap_or_else(|| <EncryptionZoneProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    pub fn has_zone(&self) -> bool {
        self.zone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: EncryptionZoneProto) {
        self.zone = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut EncryptionZoneProto {
        if self.zone.is_none() {
            self.zone.set_default();
        }
        self.zone.as_mut().unwrap()
    }

    // Take field
    pub fn take_zone(&mut self) -> EncryptionZoneProto {
        self.zone.take().unwrap_or_else(|| EncryptionZoneProto::new())
    }
}

impl ::protobuf::Message for GetEZForPathResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.zone {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.zone)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.zone.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.zone.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEZForPathResponseProto {
        GetEZForPathResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptionZoneProto>>(
                "zone",
                |m: &GetEZForPathResponseProto| { &m.zone },
                |m: &mut GetEZForPathResponseProto| { &mut m.zone },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetEZForPathResponseProto>(
                "GetEZForPathResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetEZForPathResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetEZForPathResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetEZForPathResponseProto::new)
    }
}

impl ::protobuf::Clear for GetEZForPathResponseProto {
    fn clear(&mut self) {
        self.zone.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEZForPathResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEZForPathResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ReencryptActionProto {
    CANCEL_REENCRYPT = 1,
    START_REENCRYPT = 2,
}

impl ::protobuf::ProtobufEnum for ReencryptActionProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReencryptActionProto> {
        match value {
            1 => ::std::option::Option::Some(ReencryptActionProto::CANCEL_REENCRYPT),
            2 => ::std::option::Option::Some(ReencryptActionProto::START_REENCRYPT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ReencryptActionProto] = &[
            ReencryptActionProto::CANCEL_REENCRYPT,
            ReencryptActionProto::START_REENCRYPT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ReencryptActionProto>("ReencryptActionProto", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ReencryptActionProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ReencryptActionProto {
    fn default() -> Self {
        ReencryptActionProto::CANCEL_REENCRYPT
    }
}

impl ::protobuf::reflect::ProtobufValue for ReencryptActionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ReencryptionStateProto {
    SUBMITTED = 1,
    PROCESSING = 2,
    COMPLETED = 3,
}

impl ::protobuf::ProtobufEnum for ReencryptionStateProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReencryptionStateProto> {
        match value {
            1 => ::std::option::Option::Some(ReencryptionStateProto::SUBMITTED),
            2 => ::std::option::Option::Some(ReencryptionStateProto::PROCESSING),
            3 => ::std::option::Option::Some(ReencryptionStateProto::COMPLETED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ReencryptionStateProto] = &[
            ReencryptionStateProto::SUBMITTED,
            ReencryptionStateProto::PROCESSING,
            ReencryptionStateProto::COMPLETED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ReencryptionStateProto>("ReencryptionStateProto", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ReencryptionStateProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ReencryptionStateProto {
    fn default() -> Self {
        ReencryptionStateProto::SUBMITTED
    }
}

impl ::protobuf::reflect::ProtobufValue for ReencryptionStateProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10encryption.proto\x12\x0bhadoop.hdfs\x1a\nhdfs.proto\"N\n\x20Create\
    EncryptionZoneRequestProto\x12\x10\n\x03src\x18\x01\x20\x02(\tR\x03src\
    \x12\x18\n\x07keyName\x18\x02\x20\x01(\tR\x07keyName\"#\n!CreateEncrypti\
    onZoneResponseProto\"1\n\x1fListEncryptionZonesRequestProto\x12\x0e\n\
    \x02id\x18\x01\x20\x02(\x03R\x02id\"\xe7\x01\n\x13EncryptionZoneProto\
    \x12\x0e\n\x02id\x18\x01\x20\x02(\x03R\x02id\x12\x12\n\x04path\x18\x02\
    \x20\x02(\tR\x04path\x123\n\x05suite\x18\x03\x20\x02(\x0e2\x1d.hadoop.hd\
    fs.CipherSuiteProtoR\x05suite\x12]\n\x15cryptoProtocolVersion\x18\x04\
    \x20\x02(\x0e2'.hadoop.hdfs.CryptoProtocolVersionProtoR\x15cryptoProtoco\
    lVersion\x12\x18\n\x07keyName\x18\x05\x20\x02(\tR\x07keyName\"t\n\x20Lis\
    tEncryptionZonesResponseProto\x126\n\x05zones\x18\x01\x20\x03(\x0b2\x20.\
    hadoop.hdfs.EncryptionZoneProtoR\x05zones\x12\x18\n\x07hasMore\x18\x02\
    \x20\x02(\x08R\x07hasMore\"t\n#ReencryptEncryptionZoneRequestProto\x129\
    \n\x06action\x18\x01\x20\x02(\x0e2!.hadoop.hdfs.ReencryptActionProtoR\
    \x06action\x12\x12\n\x04zone\x18\x02\x20\x02(\tR\x04zone\"&\n$ReencryptE\
    ncryptionZoneResponseProto\"4\n\"ListReencryptionStatusRequestProto\x12\
    \x0e\n\x02id\x18\x01\x20\x02(\x03R\x02id\"\xfa\x02\n\x1bZoneReencryption\
    StatusProto\x12\x0e\n\x02id\x18\x01\x20\x02(\x03R\x02id\x12\x12\n\x04pat\
    h\x18\x02\x20\x02(\tR\x04path\x129\n\x05state\x18\x03\x20\x02(\x0e2#.had\
    oop.hdfs.ReencryptionStateProtoR\x05state\x12*\n\x10ezKeyVersionName\x18\
    \x04\x20\x02(\tR\x10ezKeyVersionName\x12&\n\x0esubmissionTime\x18\x05\
    \x20\x02(\x03R\x0esubmissionTime\x12\x1a\n\x08canceled\x18\x06\x20\x02(\
    \x08R\x08canceled\x12&\n\x0enumReencrypted\x18\x07\x20\x02(\x03R\x0enumR\
    eencrypted\x12\x20\n\x0bnumFailures\x18\x08\x20\x02(\x03R\x0bnumFailures\
    \x12&\n\x0ecompletionTime\x18\t\x20\x01(\x03R\x0ecompletionTime\x12\x1a\
    \n\x08lastFile\x18\n\x20\x01(\tR\x08lastFile\"\x85\x01\n#ListReencryptio\
    nStatusResponseProto\x12D\n\x08statuses\x18\x01\x20\x03(\x0b2(.hadoop.hd\
    fs.ZoneReencryptionStatusProtoR\x08statuses\x12\x18\n\x07hasMore\x18\x02\
    \x20\x02(\x08R\x07hasMore\",\n\x18GetEZForPathRequestProto\x12\x10\n\x03\
    src\x18\x01\x20\x02(\tR\x03src\"Q\n\x19GetEZForPathResponseProto\x124\n\
    \x04zone\x18\x01\x20\x01(\x0b2\x20.hadoop.hdfs.EncryptionZoneProtoR\x04z\
    one*A\n\x14ReencryptActionProto\x12\x14\n\x10CANCEL_REENCRYPT\x10\x01\
    \x12\x13\n\x0fSTART_REENCRYPT\x10\x02*F\n\x16ReencryptionStateProto\x12\
    \r\n\tSUBMITTED\x10\x01\x12\x0e\n\nPROCESSING\x10\x02\x12\r\n\tCOMPLETED\
    \x10\x03BA\n%org.apache.hadoop.hdfs.protocol.protoB\x15EncryptionZonesPr\
    otos\xa0\x01\x01\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
