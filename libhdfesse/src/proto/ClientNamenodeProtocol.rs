// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `ClientNamenodeProtocol.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct GetBlockLocationsRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    offset: ::std::option::Option<u64>,
    length: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBlockLocationsRequestProto {
    fn default() -> &'a GetBlockLocationsRequestProto {
        <GetBlockLocationsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetBlockLocationsRequestProto {
    pub fn new() -> GetBlockLocationsRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 offset = 2;


    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }
    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    // required uint64 length = 3;


    pub fn get_length(&self) -> u64 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetBlockLocationsRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        if self.length.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.length {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlockLocationsRequestProto {
        GetBlockLocationsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &GetBlockLocationsRequestProto| { &m.src },
                |m: &mut GetBlockLocationsRequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "offset",
                |m: &GetBlockLocationsRequestProto| { &m.offset },
                |m: &mut GetBlockLocationsRequestProto| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "length",
                |m: &GetBlockLocationsRequestProto| { &m.length },
                |m: &mut GetBlockLocationsRequestProto| { &mut m.length },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetBlockLocationsRequestProto>(
                "GetBlockLocationsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetBlockLocationsRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetBlockLocationsRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetBlockLocationsRequestProto::new)
    }
}

impl ::protobuf::Clear for GetBlockLocationsRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.offset = ::std::option::Option::None;
        self.length = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlockLocationsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockLocationsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBlockLocationsResponseProto {
    // message fields
    pub locations: ::protobuf::SingularPtrField<super::hdfs::LocatedBlocksProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBlockLocationsResponseProto {
    fn default() -> &'a GetBlockLocationsResponseProto {
        <GetBlockLocationsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetBlockLocationsResponseProto {
    pub fn new() -> GetBlockLocationsResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.LocatedBlocksProto locations = 1;


    pub fn get_locations(&self) -> &super::hdfs::LocatedBlocksProto {
        self.locations.as_ref().unwrap_or_else(|| <super::hdfs::LocatedBlocksProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_locations(&mut self) {
        self.locations.clear();
    }

    pub fn has_locations(&self) -> bool {
        self.locations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locations(&mut self, v: super::hdfs::LocatedBlocksProto) {
        self.locations = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locations(&mut self) -> &mut super::hdfs::LocatedBlocksProto {
        if self.locations.is_none() {
            self.locations.set_default();
        }
        self.locations.as_mut().unwrap()
    }

    // Take field
    pub fn take_locations(&mut self) -> super::hdfs::LocatedBlocksProto {
        self.locations.take().unwrap_or_else(|| super::hdfs::LocatedBlocksProto::new())
    }
}

impl ::protobuf::Message for GetBlockLocationsResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.locations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.locations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.locations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.locations.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlockLocationsResponseProto {
        GetBlockLocationsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlocksProto>>(
                "locations",
                |m: &GetBlockLocationsResponseProto| { &m.locations },
                |m: &mut GetBlockLocationsResponseProto| { &mut m.locations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetBlockLocationsResponseProto>(
                "GetBlockLocationsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetBlockLocationsResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetBlockLocationsResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetBlockLocationsResponseProto::new)
    }
}

impl ::protobuf::Clear for GetBlockLocationsResponseProto {
    fn clear(&mut self) {
        self.locations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlockLocationsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockLocationsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetServerDefaultsRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetServerDefaultsRequestProto {
    fn default() -> &'a GetServerDefaultsRequestProto {
        <GetServerDefaultsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetServerDefaultsRequestProto {
    pub fn new() -> GetServerDefaultsRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetServerDefaultsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetServerDefaultsRequestProto {
        GetServerDefaultsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetServerDefaultsRequestProto>(
                "GetServerDefaultsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetServerDefaultsRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetServerDefaultsRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetServerDefaultsRequestProto::new)
    }
}

impl ::protobuf::Clear for GetServerDefaultsRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetServerDefaultsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServerDefaultsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetServerDefaultsResponseProto {
    // message fields
    pub serverDefaults: ::protobuf::SingularPtrField<super::hdfs::FsServerDefaultsProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetServerDefaultsResponseProto {
    fn default() -> &'a GetServerDefaultsResponseProto {
        <GetServerDefaultsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetServerDefaultsResponseProto {
    pub fn new() -> GetServerDefaultsResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.FsServerDefaultsProto serverDefaults = 1;


    pub fn get_serverDefaults(&self) -> &super::hdfs::FsServerDefaultsProto {
        self.serverDefaults.as_ref().unwrap_or_else(|| <super::hdfs::FsServerDefaultsProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_serverDefaults(&mut self) {
        self.serverDefaults.clear();
    }

    pub fn has_serverDefaults(&self) -> bool {
        self.serverDefaults.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverDefaults(&mut self, v: super::hdfs::FsServerDefaultsProto) {
        self.serverDefaults = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverDefaults(&mut self) -> &mut super::hdfs::FsServerDefaultsProto {
        if self.serverDefaults.is_none() {
            self.serverDefaults.set_default();
        }
        self.serverDefaults.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverDefaults(&mut self) -> super::hdfs::FsServerDefaultsProto {
        self.serverDefaults.take().unwrap_or_else(|| super::hdfs::FsServerDefaultsProto::new())
    }
}

impl ::protobuf::Message for GetServerDefaultsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.serverDefaults.is_none() {
            return false;
        }
        for v in &self.serverDefaults {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.serverDefaults)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.serverDefaults.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.serverDefaults.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetServerDefaultsResponseProto {
        GetServerDefaultsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::FsServerDefaultsProto>>(
                "serverDefaults",
                |m: &GetServerDefaultsResponseProto| { &m.serverDefaults },
                |m: &mut GetServerDefaultsResponseProto| { &mut m.serverDefaults },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetServerDefaultsResponseProto>(
                "GetServerDefaultsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetServerDefaultsResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetServerDefaultsResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetServerDefaultsResponseProto::new)
    }
}

impl ::protobuf::Clear for GetServerDefaultsResponseProto {
    fn clear(&mut self) {
        self.serverDefaults.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetServerDefaultsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServerDefaultsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    pub masked: ::protobuf::SingularPtrField<super::acl::FsPermissionProto>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    createFlag: ::std::option::Option<u32>,
    createParent: ::std::option::Option<bool>,
    replication: ::std::option::Option<u32>,
    blockSize: ::std::option::Option<u64>,
    pub cryptoProtocolVersion: ::std::vec::Vec<super::hdfs::CryptoProtocolVersionProto>,
    pub unmasked: ::protobuf::SingularPtrField<super::acl::FsPermissionProto>,
    ecPolicyName: ::protobuf::SingularField<::std::string::String>,
    storagePolicy: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateRequestProto {
    fn default() -> &'a CreateRequestProto {
        <CreateRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl CreateRequestProto {
    pub fn new() -> CreateRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.FsPermissionProto masked = 2;


    pub fn get_masked(&self) -> &super::acl::FsPermissionProto {
        self.masked.as_ref().unwrap_or_else(|| <super::acl::FsPermissionProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_masked(&mut self) {
        self.masked.clear();
    }

    pub fn has_masked(&self) -> bool {
        self.masked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_masked(&mut self, v: super::acl::FsPermissionProto) {
        self.masked = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_masked(&mut self) -> &mut super::acl::FsPermissionProto {
        if self.masked.is_none() {
            self.masked.set_default();
        }
        self.masked.as_mut().unwrap()
    }

    // Take field
    pub fn take_masked(&mut self) -> super::acl::FsPermissionProto {
        self.masked.take().unwrap_or_else(|| super::acl::FsPermissionProto::new())
    }

    // required string clientName = 3;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint32 createFlag = 4;


    pub fn get_createFlag(&self) -> u32 {
        self.createFlag.unwrap_or(0)
    }
    pub fn clear_createFlag(&mut self) {
        self.createFlag = ::std::option::Option::None;
    }

    pub fn has_createFlag(&self) -> bool {
        self.createFlag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createFlag(&mut self, v: u32) {
        self.createFlag = ::std::option::Option::Some(v);
    }

    // required bool createParent = 5;


    pub fn get_createParent(&self) -> bool {
        self.createParent.unwrap_or(false)
    }
    pub fn clear_createParent(&mut self) {
        self.createParent = ::std::option::Option::None;
    }

    pub fn has_createParent(&self) -> bool {
        self.createParent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createParent(&mut self, v: bool) {
        self.createParent = ::std::option::Option::Some(v);
    }

    // required uint32 replication = 6;


    pub fn get_replication(&self) -> u32 {
        self.replication.unwrap_or(0)
    }
    pub fn clear_replication(&mut self) {
        self.replication = ::std::option::Option::None;
    }

    pub fn has_replication(&self) -> bool {
        self.replication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replication(&mut self, v: u32) {
        self.replication = ::std::option::Option::Some(v);
    }

    // required uint64 blockSize = 7;


    pub fn get_blockSize(&self) -> u64 {
        self.blockSize.unwrap_or(0)
    }
    pub fn clear_blockSize(&mut self) {
        self.blockSize = ::std::option::Option::None;
    }

    pub fn has_blockSize(&self) -> bool {
        self.blockSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockSize(&mut self, v: u64) {
        self.blockSize = ::std::option::Option::Some(v);
    }

    // repeated .hadoop.hdfs.CryptoProtocolVersionProto cryptoProtocolVersion = 8;


    pub fn get_cryptoProtocolVersion(&self) -> &[super::hdfs::CryptoProtocolVersionProto] {
        &self.cryptoProtocolVersion
    }
    pub fn clear_cryptoProtocolVersion(&mut self) {
        self.cryptoProtocolVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_cryptoProtocolVersion(&mut self, v: ::std::vec::Vec<super::hdfs::CryptoProtocolVersionProto>) {
        self.cryptoProtocolVersion = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cryptoProtocolVersion(&mut self) -> &mut ::std::vec::Vec<super::hdfs::CryptoProtocolVersionProto> {
        &mut self.cryptoProtocolVersion
    }

    // Take field
    pub fn take_cryptoProtocolVersion(&mut self) -> ::std::vec::Vec<super::hdfs::CryptoProtocolVersionProto> {
        ::std::mem::replace(&mut self.cryptoProtocolVersion, ::std::vec::Vec::new())
    }

    // optional .hadoop.hdfs.FsPermissionProto unmasked = 9;


    pub fn get_unmasked(&self) -> &super::acl::FsPermissionProto {
        self.unmasked.as_ref().unwrap_or_else(|| <super::acl::FsPermissionProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unmasked(&mut self) {
        self.unmasked.clear();
    }

    pub fn has_unmasked(&self) -> bool {
        self.unmasked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unmasked(&mut self, v: super::acl::FsPermissionProto) {
        self.unmasked = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unmasked(&mut self) -> &mut super::acl::FsPermissionProto {
        if self.unmasked.is_none() {
            self.unmasked.set_default();
        }
        self.unmasked.as_mut().unwrap()
    }

    // Take field
    pub fn take_unmasked(&mut self) -> super::acl::FsPermissionProto {
        self.unmasked.take().unwrap_or_else(|| super::acl::FsPermissionProto::new())
    }

    // optional string ecPolicyName = 10;


    pub fn get_ecPolicyName(&self) -> &str {
        match self.ecPolicyName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ecPolicyName(&mut self) {
        self.ecPolicyName.clear();
    }

    pub fn has_ecPolicyName(&self) -> bool {
        self.ecPolicyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ecPolicyName(&mut self, v: ::std::string::String) {
        self.ecPolicyName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ecPolicyName(&mut self) -> &mut ::std::string::String {
        if self.ecPolicyName.is_none() {
            self.ecPolicyName.set_default();
        }
        self.ecPolicyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_ecPolicyName(&mut self) -> ::std::string::String {
        self.ecPolicyName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string storagePolicy = 11;


    pub fn get_storagePolicy(&self) -> &str {
        match self.storagePolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_storagePolicy(&mut self) {
        self.storagePolicy.clear();
    }

    pub fn has_storagePolicy(&self) -> bool {
        self.storagePolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagePolicy(&mut self, v: ::std::string::String) {
        self.storagePolicy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storagePolicy(&mut self) -> &mut ::std::string::String {
        if self.storagePolicy.is_none() {
            self.storagePolicy.set_default();
        }
        self.storagePolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_storagePolicy(&mut self) -> ::std::string::String {
        self.storagePolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.masked.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        if self.createFlag.is_none() {
            return false;
        }
        if self.createParent.is_none() {
            return false;
        }
        if self.replication.is_none() {
            return false;
        }
        if self.blockSize.is_none() {
            return false;
        }
        for v in &self.masked {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unmasked {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.masked)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.createFlag = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.createParent = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.replication = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockSize = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.cryptoProtocolVersion, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unmasked)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ecPolicyName)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storagePolicy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.masked.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.createFlag {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.createParent {
            my_size += 2;
        }
        if let Some(v) = self.replication {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blockSize {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.cryptoProtocolVersion {
            my_size += ::protobuf::rt::enum_size(8, *value);
        };
        if let Some(ref v) = self.unmasked.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ecPolicyName.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.storagePolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.masked.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.createFlag {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.createParent {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.replication {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.blockSize {
            os.write_uint64(7, v)?;
        }
        for v in &self.cryptoProtocolVersion {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(v))?;
        };
        if let Some(ref v) = self.unmasked.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ecPolicyName.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.storagePolicy.as_ref() {
            os.write_string(11, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateRequestProto {
        CreateRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &CreateRequestProto| { &m.src },
                |m: &mut CreateRequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::acl::FsPermissionProto>>(
                "masked",
                |m: &CreateRequestProto| { &m.masked },
                |m: &mut CreateRequestProto| { &mut m.masked },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientName",
                |m: &CreateRequestProto| { &m.clientName },
                |m: &mut CreateRequestProto| { &mut m.clientName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "createFlag",
                |m: &CreateRequestProto| { &m.createFlag },
                |m: &mut CreateRequestProto| { &mut m.createFlag },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "createParent",
                |m: &CreateRequestProto| { &m.createParent },
                |m: &mut CreateRequestProto| { &mut m.createParent },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "replication",
                |m: &CreateRequestProto| { &m.replication },
                |m: &mut CreateRequestProto| { &mut m.replication },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "blockSize",
                |m: &CreateRequestProto| { &m.blockSize },
                |m: &mut CreateRequestProto| { &mut m.blockSize },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::CryptoProtocolVersionProto>>(
                "cryptoProtocolVersion",
                |m: &CreateRequestProto| { &m.cryptoProtocolVersion },
                |m: &mut CreateRequestProto| { &mut m.cryptoProtocolVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::acl::FsPermissionProto>>(
                "unmasked",
                |m: &CreateRequestProto| { &m.unmasked },
                |m: &mut CreateRequestProto| { &mut m.unmasked },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ecPolicyName",
                |m: &CreateRequestProto| { &m.ecPolicyName },
                |m: &mut CreateRequestProto| { &mut m.ecPolicyName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storagePolicy",
                |m: &CreateRequestProto| { &m.storagePolicy },
                |m: &mut CreateRequestProto| { &mut m.storagePolicy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateRequestProto>(
                "CreateRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateRequestProto {
        static instance: ::protobuf::rt::LazyV2<CreateRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateRequestProto::new)
    }
}

impl ::protobuf::Clear for CreateRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.masked.clear();
        self.clientName.clear();
        self.createFlag = ::std::option::Option::None;
        self.createParent = ::std::option::Option::None;
        self.replication = ::std::option::Option::None;
        self.blockSize = ::std::option::Option::None;
        self.cryptoProtocolVersion.clear();
        self.unmasked.clear();
        self.ecPolicyName.clear();
        self.storagePolicy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateResponseProto {
    // message fields
    pub fs: ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateResponseProto {
    fn default() -> &'a CreateResponseProto {
        <CreateResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl CreateResponseProto {
    pub fn new() -> CreateResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.HdfsFileStatusProto fs = 1;


    pub fn get_fs(&self) -> &super::hdfs::HdfsFileStatusProto {
        self.fs.as_ref().unwrap_or_else(|| <super::hdfs::HdfsFileStatusProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fs(&mut self) {
        self.fs.clear();
    }

    pub fn has_fs(&self) -> bool {
        self.fs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fs(&mut self, v: super::hdfs::HdfsFileStatusProto) {
        self.fs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fs(&mut self) -> &mut super::hdfs::HdfsFileStatusProto {
        if self.fs.is_none() {
            self.fs.set_default();
        }
        self.fs.as_mut().unwrap()
    }

    // Take field
    pub fn take_fs(&mut self) -> super::hdfs::HdfsFileStatusProto {
        self.fs.take().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::new())
    }
}

impl ::protobuf::Message for CreateResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.fs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fs.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateResponseProto {
        CreateResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::HdfsFileStatusProto>>(
                "fs",
                |m: &CreateResponseProto| { &m.fs },
                |m: &mut CreateResponseProto| { &mut m.fs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateResponseProto>(
                "CreateResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateResponseProto {
        static instance: ::protobuf::rt::LazyV2<CreateResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateResponseProto::new)
    }
}

impl ::protobuf::Clear for CreateResponseProto {
    fn clear(&mut self) {
        self.fs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppendRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    flag: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppendRequestProto {
    fn default() -> &'a AppendRequestProto {
        <AppendRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl AppendRequestProto {
    pub fn new() -> AppendRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string clientName = 2;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 flag = 3;


    pub fn get_flag(&self) -> u32 {
        self.flag.unwrap_or(0)
    }
    pub fn clear_flag(&mut self) {
        self.flag = ::std::option::Option::None;
    }

    pub fn has_flag(&self) -> bool {
        self.flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flag(&mut self, v: u32) {
        self.flag = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for AppendRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flag = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.flag {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.flag {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppendRequestProto {
        AppendRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &AppendRequestProto| { &m.src },
                |m: &mut AppendRequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientName",
                |m: &AppendRequestProto| { &m.clientName },
                |m: &mut AppendRequestProto| { &mut m.clientName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flag",
                |m: &AppendRequestProto| { &m.flag },
                |m: &mut AppendRequestProto| { &mut m.flag },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppendRequestProto>(
                "AppendRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppendRequestProto {
        static instance: ::protobuf::rt::LazyV2<AppendRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppendRequestProto::new)
    }
}

impl ::protobuf::Clear for AppendRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.clientName.clear();
        self.flag = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppendRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppendRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppendResponseProto {
    // message fields
    pub block: ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto>,
    pub stat: ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppendResponseProto {
    fn default() -> &'a AppendResponseProto {
        <AppendResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl AppendResponseProto {
    pub fn new() -> AppendResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.LocatedBlockProto block = 1;


    pub fn get_block(&self) -> &super::hdfs::LocatedBlockProto {
        self.block.as_ref().unwrap_or_else(|| <super::hdfs::LocatedBlockProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::LocatedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::LocatedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::LocatedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::LocatedBlockProto::new())
    }

    // optional .hadoop.hdfs.HdfsFileStatusProto stat = 2;


    pub fn get_stat(&self) -> &super::hdfs::HdfsFileStatusProto {
        self.stat.as_ref().unwrap_or_else(|| <super::hdfs::HdfsFileStatusProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stat(&mut self) {
        self.stat.clear();
    }

    pub fn has_stat(&self) -> bool {
        self.stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat(&mut self, v: super::hdfs::HdfsFileStatusProto) {
        self.stat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stat(&mut self) -> &mut super::hdfs::HdfsFileStatusProto {
        if self.stat.is_none() {
            self.stat.set_default();
        }
        self.stat.as_mut().unwrap()
    }

    // Take field
    pub fn take_stat(&mut self) -> super::hdfs::HdfsFileStatusProto {
        self.stat.take().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::new())
    }
}

impl ::protobuf::Message for AppendResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stat)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stat.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppendResponseProto {
        AppendResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlockProto>>(
                "block",
                |m: &AppendResponseProto| { &m.block },
                |m: &mut AppendResponseProto| { &mut m.block },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::HdfsFileStatusProto>>(
                "stat",
                |m: &AppendResponseProto| { &m.stat },
                |m: &mut AppendResponseProto| { &mut m.stat },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AppendResponseProto>(
                "AppendResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AppendResponseProto {
        static instance: ::protobuf::rt::LazyV2<AppendResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AppendResponseProto::new)
    }
}

impl ::protobuf::Clear for AppendResponseProto {
    fn clear(&mut self) {
        self.block.clear();
        self.stat.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppendResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppendResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetReplicationRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    replication: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetReplicationRequestProto {
    fn default() -> &'a SetReplicationRequestProto {
        <SetReplicationRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl SetReplicationRequestProto {
    pub fn new() -> SetReplicationRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint32 replication = 2;


    pub fn get_replication(&self) -> u32 {
        self.replication.unwrap_or(0)
    }
    pub fn clear_replication(&mut self) {
        self.replication = ::std::option::Option::None;
    }

    pub fn has_replication(&self) -> bool {
        self.replication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replication(&mut self, v: u32) {
        self.replication = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SetReplicationRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.replication.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.replication = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.replication {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.replication {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetReplicationRequestProto {
        SetReplicationRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &SetReplicationRequestProto| { &m.src },
                |m: &mut SetReplicationRequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "replication",
                |m: &SetReplicationRequestProto| { &m.replication },
                |m: &mut SetReplicationRequestProto| { &mut m.replication },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetReplicationRequestProto>(
                "SetReplicationRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetReplicationRequestProto {
        static instance: ::protobuf::rt::LazyV2<SetReplicationRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetReplicationRequestProto::new)
    }
}

impl ::protobuf::Clear for SetReplicationRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.replication = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetReplicationRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetReplicationRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetReplicationResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetReplicationResponseProto {
    fn default() -> &'a SetReplicationResponseProto {
        <SetReplicationResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl SetReplicationResponseProto {
    pub fn new() -> SetReplicationResponseProto {
        ::std::default::Default::default()
    }

    // required bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SetReplicationResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetReplicationResponseProto {
        SetReplicationResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "result",
                |m: &SetReplicationResponseProto| { &m.result },
                |m: &mut SetReplicationResponseProto| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetReplicationResponseProto>(
                "SetReplicationResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetReplicationResponseProto {
        static instance: ::protobuf::rt::LazyV2<SetReplicationResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetReplicationResponseProto::new)
    }
}

impl ::protobuf::Clear for SetReplicationResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetReplicationResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetReplicationResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetStoragePolicyRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    policyName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetStoragePolicyRequestProto {
    fn default() -> &'a SetStoragePolicyRequestProto {
        <SetStoragePolicyRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl SetStoragePolicyRequestProto {
    pub fn new() -> SetStoragePolicyRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string policyName = 2;


    pub fn get_policyName(&self) -> &str {
        match self.policyName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_policyName(&mut self) {
        self.policyName.clear();
    }

    pub fn has_policyName(&self) -> bool {
        self.policyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_policyName(&mut self, v: ::std::string::String) {
        self.policyName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_policyName(&mut self) -> &mut ::std::string::String {
        if self.policyName.is_none() {
            self.policyName.set_default();
        }
        self.policyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_policyName(&mut self) -> ::std::string::String {
        self.policyName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for SetStoragePolicyRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.policyName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.policyName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.policyName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.policyName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetStoragePolicyRequestProto {
        SetStoragePolicyRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &SetStoragePolicyRequestProto| { &m.src },
                |m: &mut SetStoragePolicyRequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "policyName",
                |m: &SetStoragePolicyRequestProto| { &m.policyName },
                |m: &mut SetStoragePolicyRequestProto| { &mut m.policyName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetStoragePolicyRequestProto>(
                "SetStoragePolicyRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetStoragePolicyRequestProto {
        static instance: ::protobuf::rt::LazyV2<SetStoragePolicyRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetStoragePolicyRequestProto::new)
    }
}

impl ::protobuf::Clear for SetStoragePolicyRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.policyName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetStoragePolicyRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetStoragePolicyRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetStoragePolicyResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetStoragePolicyResponseProto {
    fn default() -> &'a SetStoragePolicyResponseProto {
        <SetStoragePolicyResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl SetStoragePolicyResponseProto {
    pub fn new() -> SetStoragePolicyResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetStoragePolicyResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetStoragePolicyResponseProto {
        SetStoragePolicyResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetStoragePolicyResponseProto>(
                "SetStoragePolicyResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetStoragePolicyResponseProto {
        static instance: ::protobuf::rt::LazyV2<SetStoragePolicyResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetStoragePolicyResponseProto::new)
    }
}

impl ::protobuf::Clear for SetStoragePolicyResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetStoragePolicyResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetStoragePolicyResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnsetStoragePolicyRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnsetStoragePolicyRequestProto {
    fn default() -> &'a UnsetStoragePolicyRequestProto {
        <UnsetStoragePolicyRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl UnsetStoragePolicyRequestProto {
    pub fn new() -> UnsetStoragePolicyRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for UnsetStoragePolicyRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnsetStoragePolicyRequestProto {
        UnsetStoragePolicyRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &UnsetStoragePolicyRequestProto| { &m.src },
                |m: &mut UnsetStoragePolicyRequestProto| { &mut m.src },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnsetStoragePolicyRequestProto>(
                "UnsetStoragePolicyRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnsetStoragePolicyRequestProto {
        static instance: ::protobuf::rt::LazyV2<UnsetStoragePolicyRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnsetStoragePolicyRequestProto::new)
    }
}

impl ::protobuf::Clear for UnsetStoragePolicyRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnsetStoragePolicyRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnsetStoragePolicyRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnsetStoragePolicyResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnsetStoragePolicyResponseProto {
    fn default() -> &'a UnsetStoragePolicyResponseProto {
        <UnsetStoragePolicyResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl UnsetStoragePolicyResponseProto {
    pub fn new() -> UnsetStoragePolicyResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UnsetStoragePolicyResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnsetStoragePolicyResponseProto {
        UnsetStoragePolicyResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnsetStoragePolicyResponseProto>(
                "UnsetStoragePolicyResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnsetStoragePolicyResponseProto {
        static instance: ::protobuf::rt::LazyV2<UnsetStoragePolicyResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnsetStoragePolicyResponseProto::new)
    }
}

impl ::protobuf::Clear for UnsetStoragePolicyResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnsetStoragePolicyResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnsetStoragePolicyResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStoragePolicyRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetStoragePolicyRequestProto {
    fn default() -> &'a GetStoragePolicyRequestProto {
        <GetStoragePolicyRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetStoragePolicyRequestProto {
    pub fn new() -> GetStoragePolicyRequestProto {
        ::std::default::Default::default()
    }

    // required string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetStoragePolicyRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetStoragePolicyRequestProto {
        GetStoragePolicyRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &GetStoragePolicyRequestProto| { &m.path },
                |m: &mut GetStoragePolicyRequestProto| { &mut m.path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetStoragePolicyRequestProto>(
                "GetStoragePolicyRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetStoragePolicyRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetStoragePolicyRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetStoragePolicyRequestProto::new)
    }
}

impl ::protobuf::Clear for GetStoragePolicyRequestProto {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStoragePolicyRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStoragePolicyRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStoragePolicyResponseProto {
    // message fields
    pub storagePolicy: ::protobuf::SingularPtrField<super::hdfs::BlockStoragePolicyProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetStoragePolicyResponseProto {
    fn default() -> &'a GetStoragePolicyResponseProto {
        <GetStoragePolicyResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetStoragePolicyResponseProto {
    pub fn new() -> GetStoragePolicyResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.BlockStoragePolicyProto storagePolicy = 1;


    pub fn get_storagePolicy(&self) -> &super::hdfs::BlockStoragePolicyProto {
        self.storagePolicy.as_ref().unwrap_or_else(|| <super::hdfs::BlockStoragePolicyProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_storagePolicy(&mut self) {
        self.storagePolicy.clear();
    }

    pub fn has_storagePolicy(&self) -> bool {
        self.storagePolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagePolicy(&mut self, v: super::hdfs::BlockStoragePolicyProto) {
        self.storagePolicy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storagePolicy(&mut self) -> &mut super::hdfs::BlockStoragePolicyProto {
        if self.storagePolicy.is_none() {
            self.storagePolicy.set_default();
        }
        self.storagePolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_storagePolicy(&mut self) -> super::hdfs::BlockStoragePolicyProto {
        self.storagePolicy.take().unwrap_or_else(|| super::hdfs::BlockStoragePolicyProto::new())
    }
}

impl ::protobuf::Message for GetStoragePolicyResponseProto {
    fn is_initialized(&self) -> bool {
        if self.storagePolicy.is_none() {
            return false;
        }
        for v in &self.storagePolicy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.storagePolicy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.storagePolicy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.storagePolicy.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetStoragePolicyResponseProto {
        GetStoragePolicyResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::BlockStoragePolicyProto>>(
                "storagePolicy",
                |m: &GetStoragePolicyResponseProto| { &m.storagePolicy },
                |m: &mut GetStoragePolicyResponseProto| { &mut m.storagePolicy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetStoragePolicyResponseProto>(
                "GetStoragePolicyResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetStoragePolicyResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetStoragePolicyResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetStoragePolicyResponseProto::new)
    }
}

impl ::protobuf::Clear for GetStoragePolicyResponseProto {
    fn clear(&mut self) {
        self.storagePolicy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStoragePolicyResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStoragePolicyResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStoragePoliciesRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetStoragePoliciesRequestProto {
    fn default() -> &'a GetStoragePoliciesRequestProto {
        <GetStoragePoliciesRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetStoragePoliciesRequestProto {
    pub fn new() -> GetStoragePoliciesRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetStoragePoliciesRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetStoragePoliciesRequestProto {
        GetStoragePoliciesRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetStoragePoliciesRequestProto>(
                "GetStoragePoliciesRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetStoragePoliciesRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetStoragePoliciesRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetStoragePoliciesRequestProto::new)
    }
}

impl ::protobuf::Clear for GetStoragePoliciesRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStoragePoliciesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStoragePoliciesRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStoragePoliciesResponseProto {
    // message fields
    pub policies: ::protobuf::RepeatedField<super::hdfs::BlockStoragePolicyProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetStoragePoliciesResponseProto {
    fn default() -> &'a GetStoragePoliciesResponseProto {
        <GetStoragePoliciesResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetStoragePoliciesResponseProto {
    pub fn new() -> GetStoragePoliciesResponseProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.BlockStoragePolicyProto policies = 1;


    pub fn get_policies(&self) -> &[super::hdfs::BlockStoragePolicyProto] {
        &self.policies
    }
    pub fn clear_policies(&mut self) {
        self.policies.clear();
    }

    // Param is passed by value, moved
    pub fn set_policies(&mut self, v: ::protobuf::RepeatedField<super::hdfs::BlockStoragePolicyProto>) {
        self.policies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_policies(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::BlockStoragePolicyProto> {
        &mut self.policies
    }

    // Take field
    pub fn take_policies(&mut self) -> ::protobuf::RepeatedField<super::hdfs::BlockStoragePolicyProto> {
        ::std::mem::replace(&mut self.policies, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetStoragePoliciesResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.policies {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.policies)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.policies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.policies {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetStoragePoliciesResponseProto {
        GetStoragePoliciesResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::BlockStoragePolicyProto>>(
                "policies",
                |m: &GetStoragePoliciesResponseProto| { &m.policies },
                |m: &mut GetStoragePoliciesResponseProto| { &mut m.policies },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetStoragePoliciesResponseProto>(
                "GetStoragePoliciesResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetStoragePoliciesResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetStoragePoliciesResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetStoragePoliciesResponseProto::new)
    }
}

impl ::protobuf::Clear for GetStoragePoliciesResponseProto {
    fn clear(&mut self) {
        self.policies.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStoragePoliciesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStoragePoliciesResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetPermissionRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    pub permission: ::protobuf::SingularPtrField<super::acl::FsPermissionProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetPermissionRequestProto {
    fn default() -> &'a SetPermissionRequestProto {
        <SetPermissionRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl SetPermissionRequestProto {
    pub fn new() -> SetPermissionRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.FsPermissionProto permission = 2;


    pub fn get_permission(&self) -> &super::acl::FsPermissionProto {
        self.permission.as_ref().unwrap_or_else(|| <super::acl::FsPermissionProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_permission(&mut self) {
        self.permission.clear();
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: super::acl::FsPermissionProto) {
        self.permission = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permission(&mut self) -> &mut super::acl::FsPermissionProto {
        if self.permission.is_none() {
            self.permission.set_default();
        }
        self.permission.as_mut().unwrap()
    }

    // Take field
    pub fn take_permission(&mut self) -> super::acl::FsPermissionProto {
        self.permission.take().unwrap_or_else(|| super::acl::FsPermissionProto::new())
    }
}

impl ::protobuf::Message for SetPermissionRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.permission.is_none() {
            return false;
        }
        for v in &self.permission {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.permission)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.permission.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.permission.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetPermissionRequestProto {
        SetPermissionRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &SetPermissionRequestProto| { &m.src },
                |m: &mut SetPermissionRequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::acl::FsPermissionProto>>(
                "permission",
                |m: &SetPermissionRequestProto| { &m.permission },
                |m: &mut SetPermissionRequestProto| { &mut m.permission },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetPermissionRequestProto>(
                "SetPermissionRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetPermissionRequestProto {
        static instance: ::protobuf::rt::LazyV2<SetPermissionRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetPermissionRequestProto::new)
    }
}

impl ::protobuf::Clear for SetPermissionRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.permission.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetPermissionRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPermissionRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetPermissionResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetPermissionResponseProto {
    fn default() -> &'a SetPermissionResponseProto {
        <SetPermissionResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl SetPermissionResponseProto {
    pub fn new() -> SetPermissionResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetPermissionResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetPermissionResponseProto {
        SetPermissionResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetPermissionResponseProto>(
                "SetPermissionResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetPermissionResponseProto {
        static instance: ::protobuf::rt::LazyV2<SetPermissionResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetPermissionResponseProto::new)
    }
}

impl ::protobuf::Clear for SetPermissionResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetPermissionResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPermissionResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetOwnerRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    username: ::protobuf::SingularField<::std::string::String>,
    groupname: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetOwnerRequestProto {
    fn default() -> &'a SetOwnerRequestProto {
        <SetOwnerRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl SetOwnerRequestProto {
    pub fn new() -> SetOwnerRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string username = 2;


    pub fn get_username(&self) -> &str {
        match self.username.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        if self.username.is_none() {
            self.username.set_default();
        }
        self.username.as_mut().unwrap()
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        self.username.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string groupname = 3;


    pub fn get_groupname(&self) -> &str {
        match self.groupname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_groupname(&mut self) {
        self.groupname.clear();
    }

    pub fn has_groupname(&self) -> bool {
        self.groupname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupname(&mut self, v: ::std::string::String) {
        self.groupname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupname(&mut self) -> &mut ::std::string::String {
        if self.groupname.is_none() {
            self.groupname.set_default();
        }
        self.groupname.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupname(&mut self) -> ::std::string::String {
        self.groupname.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for SetOwnerRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.username)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.groupname)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.username.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.groupname.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.username.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.groupname.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetOwnerRequestProto {
        SetOwnerRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &SetOwnerRequestProto| { &m.src },
                |m: &mut SetOwnerRequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "username",
                |m: &SetOwnerRequestProto| { &m.username },
                |m: &mut SetOwnerRequestProto| { &mut m.username },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "groupname",
                |m: &SetOwnerRequestProto| { &m.groupname },
                |m: &mut SetOwnerRequestProto| { &mut m.groupname },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetOwnerRequestProto>(
                "SetOwnerRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetOwnerRequestProto {
        static instance: ::protobuf::rt::LazyV2<SetOwnerRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetOwnerRequestProto::new)
    }
}

impl ::protobuf::Clear for SetOwnerRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.username.clear();
        self.groupname.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetOwnerRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetOwnerRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetOwnerResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetOwnerResponseProto {
    fn default() -> &'a SetOwnerResponseProto {
        <SetOwnerResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl SetOwnerResponseProto {
    pub fn new() -> SetOwnerResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetOwnerResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetOwnerResponseProto {
        SetOwnerResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetOwnerResponseProto>(
                "SetOwnerResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetOwnerResponseProto {
        static instance: ::protobuf::rt::LazyV2<SetOwnerResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetOwnerResponseProto::new)
    }
}

impl ::protobuf::Clear for SetOwnerResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetOwnerResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetOwnerResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AbandonBlockRequestProto {
    // message fields
    pub b: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    src: ::protobuf::SingularField<::std::string::String>,
    holder: ::protobuf::SingularField<::std::string::String>,
    fileId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AbandonBlockRequestProto {
    fn default() -> &'a AbandonBlockRequestProto {
        <AbandonBlockRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl AbandonBlockRequestProto {
    pub fn new() -> AbandonBlockRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ExtendedBlockProto b = 1;


    pub fn get_b(&self) -> &super::hdfs::ExtendedBlockProto {
        self.b.as_ref().unwrap_or_else(|| <super::hdfs::ExtendedBlockProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_b(&mut self) {
        self.b.clear();
    }

    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.b = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_b(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.b.is_none() {
            self.b.set_default();
        }
        self.b.as_mut().unwrap()
    }

    // Take field
    pub fn take_b(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.b.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    // required string src = 2;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string holder = 3;


    pub fn get_holder(&self) -> &str {
        match self.holder.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_holder(&mut self) {
        self.holder.clear();
    }

    pub fn has_holder(&self) -> bool {
        self.holder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_holder(&mut self, v: ::std::string::String) {
        self.holder = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holder(&mut self) -> &mut ::std::string::String {
        if self.holder.is_none() {
            self.holder.set_default();
        }
        self.holder.as_mut().unwrap()
    }

    // Take field
    pub fn take_holder(&mut self) -> ::std::string::String {
        self.holder.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 fileId = 4;


    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }
    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for AbandonBlockRequestProto {
    fn is_initialized(&self) -> bool {
        if self.b.is_none() {
            return false;
        }
        if self.src.is_none() {
            return false;
        }
        if self.holder.is_none() {
            return false;
        }
        for v in &self.b {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.b)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.holder)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.b.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.holder.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.b.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.holder.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.fileId {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AbandonBlockRequestProto {
        AbandonBlockRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                "b",
                |m: &AbandonBlockRequestProto| { &m.b },
                |m: &mut AbandonBlockRequestProto| { &mut m.b },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &AbandonBlockRequestProto| { &m.src },
                |m: &mut AbandonBlockRequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "holder",
                |m: &AbandonBlockRequestProto| { &m.holder },
                |m: &mut AbandonBlockRequestProto| { &mut m.holder },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fileId",
                |m: &AbandonBlockRequestProto| { &m.fileId },
                |m: &mut AbandonBlockRequestProto| { &mut m.fileId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AbandonBlockRequestProto>(
                "AbandonBlockRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AbandonBlockRequestProto {
        static instance: ::protobuf::rt::LazyV2<AbandonBlockRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AbandonBlockRequestProto::new)
    }
}

impl ::protobuf::Clear for AbandonBlockRequestProto {
    fn clear(&mut self) {
        self.b.clear();
        self.src.clear();
        self.holder.clear();
        self.fileId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AbandonBlockRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AbandonBlockRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AbandonBlockResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AbandonBlockResponseProto {
    fn default() -> &'a AbandonBlockResponseProto {
        <AbandonBlockResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl AbandonBlockResponseProto {
    pub fn new() -> AbandonBlockResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AbandonBlockResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AbandonBlockResponseProto {
        AbandonBlockResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AbandonBlockResponseProto>(
                "AbandonBlockResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AbandonBlockResponseProto {
        static instance: ::protobuf::rt::LazyV2<AbandonBlockResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AbandonBlockResponseProto::new)
    }
}

impl ::protobuf::Clear for AbandonBlockResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AbandonBlockResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AbandonBlockResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddBlockRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    pub previous: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    pub excludeNodes: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>,
    fileId: ::std::option::Option<u64>,
    pub favoredNodes: ::protobuf::RepeatedField<::std::string::String>,
    pub flags: ::std::vec::Vec<AddBlockFlagProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddBlockRequestProto {
    fn default() -> &'a AddBlockRequestProto {
        <AddBlockRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl AddBlockRequestProto {
    pub fn new() -> AddBlockRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string clientName = 2;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .hadoop.hdfs.ExtendedBlockProto previous = 3;


    pub fn get_previous(&self) -> &super::hdfs::ExtendedBlockProto {
        self.previous.as_ref().unwrap_or_else(|| <super::hdfs::ExtendedBlockProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_previous(&mut self) {
        self.previous.clear();
    }

    pub fn has_previous(&self) -> bool {
        self.previous.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previous(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.previous = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_previous(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.previous.is_none() {
            self.previous.set_default();
        }
        self.previous.as_mut().unwrap()
    }

    // Take field
    pub fn take_previous(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.previous.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto excludeNodes = 4;


    pub fn get_excludeNodes(&self) -> &[super::hdfs::DatanodeInfoProto] {
        &self.excludeNodes
    }
    pub fn clear_excludeNodes(&mut self) {
        self.excludeNodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludeNodes(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>) {
        self.excludeNodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludeNodes(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.excludeNodes
    }

    // Take field
    pub fn take_excludeNodes(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        ::std::mem::replace(&mut self.excludeNodes, ::protobuf::RepeatedField::new())
    }

    // optional uint64 fileId = 5;


    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }
    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }

    // repeated string favoredNodes = 6;


    pub fn get_favoredNodes(&self) -> &[::std::string::String] {
        &self.favoredNodes
    }
    pub fn clear_favoredNodes(&mut self) {
        self.favoredNodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_favoredNodes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.favoredNodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_favoredNodes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.favoredNodes
    }

    // Take field
    pub fn take_favoredNodes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.favoredNodes, ::protobuf::RepeatedField::new())
    }

    // repeated .hadoop.hdfs.AddBlockFlagProto flags = 7;


    pub fn get_flags(&self) -> &[AddBlockFlagProto] {
        &self.flags
    }
    pub fn clear_flags(&mut self) {
        self.flags.clear();
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: ::std::vec::Vec<AddBlockFlagProto>) {
        self.flags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_flags(&mut self) -> &mut ::std::vec::Vec<AddBlockFlagProto> {
        &mut self.flags
    }

    // Take field
    pub fn take_flags(&mut self) -> ::std::vec::Vec<AddBlockFlagProto> {
        ::std::mem::replace(&mut self.flags, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for AddBlockRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        for v in &self.previous {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.excludeNodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.previous)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.excludeNodes)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.favoredNodes)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.flags, 7, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.previous.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.excludeNodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.favoredNodes {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.flags {
            my_size += ::protobuf::rt::enum_size(7, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.previous.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.excludeNodes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.fileId {
            os.write_uint64(5, v)?;
        }
        for v in &self.favoredNodes {
            os.write_string(6, &v)?;
        };
        for v in &self.flags {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddBlockRequestProto {
        AddBlockRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &AddBlockRequestProto| { &m.src },
                |m: &mut AddBlockRequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientName",
                |m: &AddBlockRequestProto| { &m.clientName },
                |m: &mut AddBlockRequestProto| { &mut m.clientName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                "previous",
                |m: &AddBlockRequestProto| { &m.previous },
                |m: &mut AddBlockRequestProto| { &mut m.previous },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                "excludeNodes",
                |m: &AddBlockRequestProto| { &m.excludeNodes },
                |m: &mut AddBlockRequestProto| { &mut m.excludeNodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fileId",
                |m: &AddBlockRequestProto| { &m.fileId },
                |m: &mut AddBlockRequestProto| { &mut m.fileId },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "favoredNodes",
                |m: &AddBlockRequestProto| { &m.favoredNodes },
                |m: &mut AddBlockRequestProto| { &mut m.favoredNodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AddBlockFlagProto>>(
                "flags",
                |m: &AddBlockRequestProto| { &m.flags },
                |m: &mut AddBlockRequestProto| { &mut m.flags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddBlockRequestProto>(
                "AddBlockRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddBlockRequestProto {
        static instance: ::protobuf::rt::LazyV2<AddBlockRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddBlockRequestProto::new)
    }
}

impl ::protobuf::Clear for AddBlockRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.clientName.clear();
        self.previous.clear();
        self.excludeNodes.clear();
        self.fileId = ::std::option::Option::None;
        self.favoredNodes.clear();
        self.flags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddBlockRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddBlockRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddBlockResponseProto {
    // message fields
    pub block: ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddBlockResponseProto {
    fn default() -> &'a AddBlockResponseProto {
        <AddBlockResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl AddBlockResponseProto {
    pub fn new() -> AddBlockResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.LocatedBlockProto block = 1;


    pub fn get_block(&self) -> &super::hdfs::LocatedBlockProto {
        self.block.as_ref().unwrap_or_else(|| <super::hdfs::LocatedBlockProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::LocatedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::LocatedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::LocatedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::LocatedBlockProto::new())
    }
}

impl ::protobuf::Message for AddBlockResponseProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddBlockResponseProto {
        AddBlockResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlockProto>>(
                "block",
                |m: &AddBlockResponseProto| { &m.block },
                |m: &mut AddBlockResponseProto| { &mut m.block },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddBlockResponseProto>(
                "AddBlockResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddBlockResponseProto {
        static instance: ::protobuf::rt::LazyV2<AddBlockResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddBlockResponseProto::new)
    }
}

impl ::protobuf::Clear for AddBlockResponseProto {
    fn clear(&mut self) {
        self.block.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddBlockResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddBlockResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAdditionalDatanodeRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    pub blk: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    pub existings: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>,
    pub excludes: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>,
    numAdditionalNodes: ::std::option::Option<u32>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    pub existingStorageUuids: ::protobuf::RepeatedField<::std::string::String>,
    fileId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAdditionalDatanodeRequestProto {
    fn default() -> &'a GetAdditionalDatanodeRequestProto {
        <GetAdditionalDatanodeRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetAdditionalDatanodeRequestProto {
    pub fn new() -> GetAdditionalDatanodeRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.ExtendedBlockProto blk = 2;


    pub fn get_blk(&self) -> &super::hdfs::ExtendedBlockProto {
        self.blk.as_ref().unwrap_or_else(|| <super::hdfs::ExtendedBlockProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blk(&mut self) {
        self.blk.clear();
    }

    pub fn has_blk(&self) -> bool {
        self.blk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blk(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.blk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blk(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.blk.is_none() {
            self.blk.set_default();
        }
        self.blk.as_mut().unwrap()
    }

    // Take field
    pub fn take_blk(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.blk.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto existings = 3;


    pub fn get_existings(&self) -> &[super::hdfs::DatanodeInfoProto] {
        &self.existings
    }
    pub fn clear_existings(&mut self) {
        self.existings.clear();
    }

    // Param is passed by value, moved
    pub fn set_existings(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>) {
        self.existings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_existings(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.existings
    }

    // Take field
    pub fn take_existings(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        ::std::mem::replace(&mut self.existings, ::protobuf::RepeatedField::new())
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto excludes = 4;


    pub fn get_excludes(&self) -> &[super::hdfs::DatanodeInfoProto] {
        &self.excludes
    }
    pub fn clear_excludes(&mut self) {
        self.excludes.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludes(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>) {
        self.excludes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludes(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.excludes
    }

    // Take field
    pub fn take_excludes(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        ::std::mem::replace(&mut self.excludes, ::protobuf::RepeatedField::new())
    }

    // required uint32 numAdditionalNodes = 5;


    pub fn get_numAdditionalNodes(&self) -> u32 {
        self.numAdditionalNodes.unwrap_or(0)
    }
    pub fn clear_numAdditionalNodes(&mut self) {
        self.numAdditionalNodes = ::std::option::Option::None;
    }

    pub fn has_numAdditionalNodes(&self) -> bool {
        self.numAdditionalNodes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numAdditionalNodes(&mut self, v: u32) {
        self.numAdditionalNodes = ::std::option::Option::Some(v);
    }

    // required string clientName = 6;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string existingStorageUuids = 7;


    pub fn get_existingStorageUuids(&self) -> &[::std::string::String] {
        &self.existingStorageUuids
    }
    pub fn clear_existingStorageUuids(&mut self) {
        self.existingStorageUuids.clear();
    }

    // Param is passed by value, moved
    pub fn set_existingStorageUuids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.existingStorageUuids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_existingStorageUuids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.existingStorageUuids
    }

    // Take field
    pub fn take_existingStorageUuids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.existingStorageUuids, ::protobuf::RepeatedField::new())
    }

    // optional uint64 fileId = 8;


    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }
    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetAdditionalDatanodeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.blk.is_none() {
            return false;
        }
        if self.numAdditionalNodes.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        for v in &self.blk {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.existings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.excludes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blk)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.existings)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.excludes)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.numAdditionalNodes = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.existingStorageUuids)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.blk.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.existings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.excludes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.numAdditionalNodes {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.existingStorageUuids {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.blk.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.existings {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.excludes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.numAdditionalNodes {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(6, &v)?;
        }
        for v in &self.existingStorageUuids {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.fileId {
            os.write_uint64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAdditionalDatanodeRequestProto {
        GetAdditionalDatanodeRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &GetAdditionalDatanodeRequestProto| { &m.src },
                |m: &mut GetAdditionalDatanodeRequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                "blk",
                |m: &GetAdditionalDatanodeRequestProto| { &m.blk },
                |m: &mut GetAdditionalDatanodeRequestProto| { &mut m.blk },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                "existings",
                |m: &GetAdditionalDatanodeRequestProto| { &m.existings },
                |m: &mut GetAdditionalDatanodeRequestProto| { &mut m.existings },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                "excludes",
                |m: &GetAdditionalDatanodeRequestProto| { &m.excludes },
                |m: &mut GetAdditionalDatanodeRequestProto| { &mut m.excludes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "numAdditionalNodes",
                |m: &GetAdditionalDatanodeRequestProto| { &m.numAdditionalNodes },
                |m: &mut GetAdditionalDatanodeRequestProto| { &mut m.numAdditionalNodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientName",
                |m: &GetAdditionalDatanodeRequestProto| { &m.clientName },
                |m: &mut GetAdditionalDatanodeRequestProto| { &mut m.clientName },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "existingStorageUuids",
                |m: &GetAdditionalDatanodeRequestProto| { &m.existingStorageUuids },
                |m: &mut GetAdditionalDatanodeRequestProto| { &mut m.existingStorageUuids },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fileId",
                |m: &GetAdditionalDatanodeRequestProto| { &m.fileId },
                |m: &mut GetAdditionalDatanodeRequestProto| { &mut m.fileId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAdditionalDatanodeRequestProto>(
                "GetAdditionalDatanodeRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAdditionalDatanodeRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetAdditionalDatanodeRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAdditionalDatanodeRequestProto::new)
    }
}

impl ::protobuf::Clear for GetAdditionalDatanodeRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.blk.clear();
        self.existings.clear();
        self.excludes.clear();
        self.numAdditionalNodes = ::std::option::Option::None;
        self.clientName.clear();
        self.existingStorageUuids.clear();
        self.fileId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAdditionalDatanodeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAdditionalDatanodeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAdditionalDatanodeResponseProto {
    // message fields
    pub block: ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAdditionalDatanodeResponseProto {
    fn default() -> &'a GetAdditionalDatanodeResponseProto {
        <GetAdditionalDatanodeResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetAdditionalDatanodeResponseProto {
    pub fn new() -> GetAdditionalDatanodeResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.LocatedBlockProto block = 1;


    pub fn get_block(&self) -> &super::hdfs::LocatedBlockProto {
        self.block.as_ref().unwrap_or_else(|| <super::hdfs::LocatedBlockProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::LocatedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::LocatedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::LocatedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::LocatedBlockProto::new())
    }
}

impl ::protobuf::Message for GetAdditionalDatanodeResponseProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAdditionalDatanodeResponseProto {
        GetAdditionalDatanodeResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlockProto>>(
                "block",
                |m: &GetAdditionalDatanodeResponseProto| { &m.block },
                |m: &mut GetAdditionalDatanodeResponseProto| { &mut m.block },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAdditionalDatanodeResponseProto>(
                "GetAdditionalDatanodeResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAdditionalDatanodeResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetAdditionalDatanodeResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAdditionalDatanodeResponseProto::new)
    }
}

impl ::protobuf::Clear for GetAdditionalDatanodeResponseProto {
    fn clear(&mut self) {
        self.block.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAdditionalDatanodeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAdditionalDatanodeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompleteRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    pub last: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    fileId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompleteRequestProto {
    fn default() -> &'a CompleteRequestProto {
        <CompleteRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl CompleteRequestProto {
    pub fn new() -> CompleteRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string clientName = 2;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .hadoop.hdfs.ExtendedBlockProto last = 3;


    pub fn get_last(&self) -> &super::hdfs::ExtendedBlockProto {
        self.last.as_ref().unwrap_or_else(|| <super::hdfs::ExtendedBlockProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last(&mut self) {
        self.last.clear();
    }

    pub fn has_last(&self) -> bool {
        self.last.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.last = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.last.is_none() {
            self.last.set_default();
        }
        self.last.as_mut().unwrap()
    }

    // Take field
    pub fn take_last(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.last.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    // optional uint64 fileId = 4;


    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }
    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CompleteRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        for v in &self.last {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.last.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.last.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.fileId {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompleteRequestProto {
        CompleteRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &CompleteRequestProto| { &m.src },
                |m: &mut CompleteRequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientName",
                |m: &CompleteRequestProto| { &m.clientName },
                |m: &mut CompleteRequestProto| { &mut m.clientName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                "last",
                |m: &CompleteRequestProto| { &m.last },
                |m: &mut CompleteRequestProto| { &mut m.last },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fileId",
                |m: &CompleteRequestProto| { &m.fileId },
                |m: &mut CompleteRequestProto| { &mut m.fileId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompleteRequestProto>(
                "CompleteRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompleteRequestProto {
        static instance: ::protobuf::rt::LazyV2<CompleteRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompleteRequestProto::new)
    }
}

impl ::protobuf::Clear for CompleteRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.clientName.clear();
        self.last.clear();
        self.fileId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompleteRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompleteRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompleteResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompleteResponseProto {
    fn default() -> &'a CompleteResponseProto {
        <CompleteResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl CompleteResponseProto {
    pub fn new() -> CompleteResponseProto {
        ::std::default::Default::default()
    }

    // required bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CompleteResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompleteResponseProto {
        CompleteResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "result",
                |m: &CompleteResponseProto| { &m.result },
                |m: &mut CompleteResponseProto| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompleteResponseProto>(
                "CompleteResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompleteResponseProto {
        static instance: ::protobuf::rt::LazyV2<CompleteResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompleteResponseProto::new)
    }
}

impl ::protobuf::Clear for CompleteResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompleteResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompleteResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReportBadBlocksRequestProto {
    // message fields
    pub blocks: ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReportBadBlocksRequestProto {
    fn default() -> &'a ReportBadBlocksRequestProto {
        <ReportBadBlocksRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ReportBadBlocksRequestProto {
    pub fn new() -> ReportBadBlocksRequestProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.LocatedBlockProto blocks = 1;


    pub fn get_blocks(&self) -> &[super::hdfs::LocatedBlockProto] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ReportBadBlocksRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blocks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReportBadBlocksRequestProto {
        ReportBadBlocksRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlockProto>>(
                "blocks",
                |m: &ReportBadBlocksRequestProto| { &m.blocks },
                |m: &mut ReportBadBlocksRequestProto| { &mut m.blocks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReportBadBlocksRequestProto>(
                "ReportBadBlocksRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReportBadBlocksRequestProto {
        static instance: ::protobuf::rt::LazyV2<ReportBadBlocksRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReportBadBlocksRequestProto::new)
    }
}

impl ::protobuf::Clear for ReportBadBlocksRequestProto {
    fn clear(&mut self) {
        self.blocks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReportBadBlocksRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReportBadBlocksRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReportBadBlocksResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReportBadBlocksResponseProto {
    fn default() -> &'a ReportBadBlocksResponseProto {
        <ReportBadBlocksResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ReportBadBlocksResponseProto {
    pub fn new() -> ReportBadBlocksResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ReportBadBlocksResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReportBadBlocksResponseProto {
        ReportBadBlocksResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReportBadBlocksResponseProto>(
                "ReportBadBlocksResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReportBadBlocksResponseProto {
        static instance: ::protobuf::rt::LazyV2<ReportBadBlocksResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReportBadBlocksResponseProto::new)
    }
}

impl ::protobuf::Clear for ReportBadBlocksResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReportBadBlocksResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReportBadBlocksResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConcatRequestProto {
    // message fields
    trg: ::protobuf::SingularField<::std::string::String>,
    pub srcs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConcatRequestProto {
    fn default() -> &'a ConcatRequestProto {
        <ConcatRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ConcatRequestProto {
    pub fn new() -> ConcatRequestProto {
        ::std::default::Default::default()
    }

    // required string trg = 1;


    pub fn get_trg(&self) -> &str {
        match self.trg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_trg(&mut self) {
        self.trg.clear();
    }

    pub fn has_trg(&self) -> bool {
        self.trg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trg(&mut self, v: ::std::string::String) {
        self.trg = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trg(&mut self) -> &mut ::std::string::String {
        if self.trg.is_none() {
            self.trg.set_default();
        }
        self.trg.as_mut().unwrap()
    }

    // Take field
    pub fn take_trg(&mut self) -> ::std::string::String {
        self.trg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string srcs = 2;


    pub fn get_srcs(&self) -> &[::std::string::String] {
        &self.srcs
    }
    pub fn clear_srcs(&mut self) {
        self.srcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_srcs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.srcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_srcs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.srcs
    }

    // Take field
    pub fn take_srcs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.srcs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ConcatRequestProto {
    fn is_initialized(&self) -> bool {
        if self.trg.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.trg)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.srcs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.trg.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.srcs {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.trg.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.srcs {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConcatRequestProto {
        ConcatRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "trg",
                |m: &ConcatRequestProto| { &m.trg },
                |m: &mut ConcatRequestProto| { &mut m.trg },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "srcs",
                |m: &ConcatRequestProto| { &m.srcs },
                |m: &mut ConcatRequestProto| { &mut m.srcs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConcatRequestProto>(
                "ConcatRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConcatRequestProto {
        static instance: ::protobuf::rt::LazyV2<ConcatRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConcatRequestProto::new)
    }
}

impl ::protobuf::Clear for ConcatRequestProto {
    fn clear(&mut self) {
        self.trg.clear();
        self.srcs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConcatRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConcatRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConcatResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConcatResponseProto {
    fn default() -> &'a ConcatResponseProto {
        <ConcatResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ConcatResponseProto {
    pub fn new() -> ConcatResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ConcatResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConcatResponseProto {
        ConcatResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConcatResponseProto>(
                "ConcatResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConcatResponseProto {
        static instance: ::protobuf::rt::LazyV2<ConcatResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConcatResponseProto::new)
    }
}

impl ::protobuf::Clear for ConcatResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConcatResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConcatResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TruncateRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    newLength: ::std::option::Option<u64>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TruncateRequestProto {
    fn default() -> &'a TruncateRequestProto {
        <TruncateRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl TruncateRequestProto {
    pub fn new() -> TruncateRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 newLength = 2;


    pub fn get_newLength(&self) -> u64 {
        self.newLength.unwrap_or(0)
    }
    pub fn clear_newLength(&mut self) {
        self.newLength = ::std::option::Option::None;
    }

    pub fn has_newLength(&self) -> bool {
        self.newLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newLength(&mut self, v: u64) {
        self.newLength = ::std::option::Option::Some(v);
    }

    // required string clientName = 3;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TruncateRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.newLength.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.newLength = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.newLength {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.newLength {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TruncateRequestProto {
        TruncateRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &TruncateRequestProto| { &m.src },
                |m: &mut TruncateRequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "newLength",
                |m: &TruncateRequestProto| { &m.newLength },
                |m: &mut TruncateRequestProto| { &mut m.newLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientName",
                |m: &TruncateRequestProto| { &m.clientName },
                |m: &mut TruncateRequestProto| { &mut m.clientName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TruncateRequestProto>(
                "TruncateRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TruncateRequestProto {
        static instance: ::protobuf::rt::LazyV2<TruncateRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TruncateRequestProto::new)
    }
}

impl ::protobuf::Clear for TruncateRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.newLength = ::std::option::Option::None;
        self.clientName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TruncateRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TruncateRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TruncateResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TruncateResponseProto {
    fn default() -> &'a TruncateResponseProto {
        <TruncateResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl TruncateResponseProto {
    pub fn new() -> TruncateResponseProto {
        ::std::default::Default::default()
    }

    // required bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TruncateResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TruncateResponseProto {
        TruncateResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "result",
                |m: &TruncateResponseProto| { &m.result },
                |m: &mut TruncateResponseProto| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TruncateResponseProto>(
                "TruncateResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TruncateResponseProto {
        static instance: ::protobuf::rt::LazyV2<TruncateResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TruncateResponseProto::new)
    }
}

impl ::protobuf::Clear for TruncateResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TruncateResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TruncateResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenameRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    dst: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RenameRequestProto {
    fn default() -> &'a RenameRequestProto {
        <RenameRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RenameRequestProto {
    pub fn new() -> RenameRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string dst = 2;


    pub fn get_dst(&self) -> &str {
        match self.dst.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_dst(&mut self) {
        self.dst.clear();
    }

    pub fn has_dst(&self) -> bool {
        self.dst.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst(&mut self, v: ::std::string::String) {
        self.dst = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst(&mut self) -> &mut ::std::string::String {
        if self.dst.is_none() {
            self.dst.set_default();
        }
        self.dst.as_mut().unwrap()
    }

    // Take field
    pub fn take_dst(&mut self) -> ::std::string::String {
        self.dst.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for RenameRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.dst.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dst)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.dst.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.dst.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RenameRequestProto {
        RenameRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &RenameRequestProto| { &m.src },
                |m: &mut RenameRequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dst",
                |m: &RenameRequestProto| { &m.dst },
                |m: &mut RenameRequestProto| { &mut m.dst },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RenameRequestProto>(
                "RenameRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RenameRequestProto {
        static instance: ::protobuf::rt::LazyV2<RenameRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RenameRequestProto::new)
    }
}

impl ::protobuf::Clear for RenameRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.dst.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenameRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenameResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RenameResponseProto {
    fn default() -> &'a RenameResponseProto {
        <RenameResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RenameResponseProto {
    pub fn new() -> RenameResponseProto {
        ::std::default::Default::default()
    }

    // required bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RenameResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RenameResponseProto {
        RenameResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "result",
                |m: &RenameResponseProto| { &m.result },
                |m: &mut RenameResponseProto| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RenameResponseProto>(
                "RenameResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RenameResponseProto {
        static instance: ::protobuf::rt::LazyV2<RenameResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RenameResponseProto::new)
    }
}

impl ::protobuf::Clear for RenameResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenameResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Rename2RequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    dst: ::protobuf::SingularField<::std::string::String>,
    overwriteDest: ::std::option::Option<bool>,
    moveToTrash: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Rename2RequestProto {
    fn default() -> &'a Rename2RequestProto {
        <Rename2RequestProto as ::protobuf::Message>::default_instance()
    }
}

impl Rename2RequestProto {
    pub fn new() -> Rename2RequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string dst = 2;


    pub fn get_dst(&self) -> &str {
        match self.dst.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_dst(&mut self) {
        self.dst.clear();
    }

    pub fn has_dst(&self) -> bool {
        self.dst.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst(&mut self, v: ::std::string::String) {
        self.dst = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst(&mut self) -> &mut ::std::string::String {
        if self.dst.is_none() {
            self.dst.set_default();
        }
        self.dst.as_mut().unwrap()
    }

    // Take field
    pub fn take_dst(&mut self) -> ::std::string::String {
        self.dst.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bool overwriteDest = 3;


    pub fn get_overwriteDest(&self) -> bool {
        self.overwriteDest.unwrap_or(false)
    }
    pub fn clear_overwriteDest(&mut self) {
        self.overwriteDest = ::std::option::Option::None;
    }

    pub fn has_overwriteDest(&self) -> bool {
        self.overwriteDest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overwriteDest(&mut self, v: bool) {
        self.overwriteDest = ::std::option::Option::Some(v);
    }

    // optional bool moveToTrash = 4;


    pub fn get_moveToTrash(&self) -> bool {
        self.moveToTrash.unwrap_or(false)
    }
    pub fn clear_moveToTrash(&mut self) {
        self.moveToTrash = ::std::option::Option::None;
    }

    pub fn has_moveToTrash(&self) -> bool {
        self.moveToTrash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_moveToTrash(&mut self, v: bool) {
        self.moveToTrash = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Rename2RequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.dst.is_none() {
            return false;
        }
        if self.overwriteDest.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dst)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.overwriteDest = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.moveToTrash = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.dst.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.overwriteDest {
            my_size += 2;
        }
        if let Some(v) = self.moveToTrash {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.dst.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.overwriteDest {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.moveToTrash {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Rename2RequestProto {
        Rename2RequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &Rename2RequestProto| { &m.src },
                |m: &mut Rename2RequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dst",
                |m: &Rename2RequestProto| { &m.dst },
                |m: &mut Rename2RequestProto| { &mut m.dst },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "overwriteDest",
                |m: &Rename2RequestProto| { &m.overwriteDest },
                |m: &mut Rename2RequestProto| { &mut m.overwriteDest },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "moveToTrash",
                |m: &Rename2RequestProto| { &m.moveToTrash },
                |m: &mut Rename2RequestProto| { &mut m.moveToTrash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Rename2RequestProto>(
                "Rename2RequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Rename2RequestProto {
        static instance: ::protobuf::rt::LazyV2<Rename2RequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Rename2RequestProto::new)
    }
}

impl ::protobuf::Clear for Rename2RequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.dst.clear();
        self.overwriteDest = ::std::option::Option::None;
        self.moveToTrash = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rename2RequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rename2RequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Rename2ResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Rename2ResponseProto {
    fn default() -> &'a Rename2ResponseProto {
        <Rename2ResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl Rename2ResponseProto {
    pub fn new() -> Rename2ResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Rename2ResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Rename2ResponseProto {
        Rename2ResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Rename2ResponseProto>(
                "Rename2ResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Rename2ResponseProto {
        static instance: ::protobuf::rt::LazyV2<Rename2ResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Rename2ResponseProto::new)
    }
}

impl ::protobuf::Clear for Rename2ResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rename2ResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rename2ResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    recursive: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteRequestProto {
    fn default() -> &'a DeleteRequestProto {
        <DeleteRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl DeleteRequestProto {
    pub fn new() -> DeleteRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bool recursive = 2;


    pub fn get_recursive(&self) -> bool {
        self.recursive.unwrap_or(false)
    }
    pub fn clear_recursive(&mut self) {
        self.recursive = ::std::option::Option::None;
    }

    pub fn has_recursive(&self) -> bool {
        self.recursive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recursive(&mut self, v: bool) {
        self.recursive = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DeleteRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.recursive.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.recursive = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.recursive {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.recursive {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteRequestProto {
        DeleteRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &DeleteRequestProto| { &m.src },
                |m: &mut DeleteRequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "recursive",
                |m: &DeleteRequestProto| { &m.recursive },
                |m: &mut DeleteRequestProto| { &mut m.recursive },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteRequestProto>(
                "DeleteRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteRequestProto {
        static instance: ::protobuf::rt::LazyV2<DeleteRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteRequestProto::new)
    }
}

impl ::protobuf::Clear for DeleteRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.recursive = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteResponseProto {
    fn default() -> &'a DeleteResponseProto {
        <DeleteResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl DeleteResponseProto {
    pub fn new() -> DeleteResponseProto {
        ::std::default::Default::default()
    }

    // required bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DeleteResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteResponseProto {
        DeleteResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "result",
                |m: &DeleteResponseProto| { &m.result },
                |m: &mut DeleteResponseProto| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteResponseProto>(
                "DeleteResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteResponseProto {
        static instance: ::protobuf::rt::LazyV2<DeleteResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteResponseProto::new)
    }
}

impl ::protobuf::Clear for DeleteResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MkdirsRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    pub masked: ::protobuf::SingularPtrField<super::acl::FsPermissionProto>,
    createParent: ::std::option::Option<bool>,
    pub unmasked: ::protobuf::SingularPtrField<super::acl::FsPermissionProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MkdirsRequestProto {
    fn default() -> &'a MkdirsRequestProto {
        <MkdirsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl MkdirsRequestProto {
    pub fn new() -> MkdirsRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.FsPermissionProto masked = 2;


    pub fn get_masked(&self) -> &super::acl::FsPermissionProto {
        self.masked.as_ref().unwrap_or_else(|| <super::acl::FsPermissionProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_masked(&mut self) {
        self.masked.clear();
    }

    pub fn has_masked(&self) -> bool {
        self.masked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_masked(&mut self, v: super::acl::FsPermissionProto) {
        self.masked = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_masked(&mut self) -> &mut super::acl::FsPermissionProto {
        if self.masked.is_none() {
            self.masked.set_default();
        }
        self.masked.as_mut().unwrap()
    }

    // Take field
    pub fn take_masked(&mut self) -> super::acl::FsPermissionProto {
        self.masked.take().unwrap_or_else(|| super::acl::FsPermissionProto::new())
    }

    // required bool createParent = 3;


    pub fn get_createParent(&self) -> bool {
        self.createParent.unwrap_or(false)
    }
    pub fn clear_createParent(&mut self) {
        self.createParent = ::std::option::Option::None;
    }

    pub fn has_createParent(&self) -> bool {
        self.createParent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createParent(&mut self, v: bool) {
        self.createParent = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.FsPermissionProto unmasked = 4;


    pub fn get_unmasked(&self) -> &super::acl::FsPermissionProto {
        self.unmasked.as_ref().unwrap_or_else(|| <super::acl::FsPermissionProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unmasked(&mut self) {
        self.unmasked.clear();
    }

    pub fn has_unmasked(&self) -> bool {
        self.unmasked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unmasked(&mut self, v: super::acl::FsPermissionProto) {
        self.unmasked = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unmasked(&mut self) -> &mut super::acl::FsPermissionProto {
        if self.unmasked.is_none() {
            self.unmasked.set_default();
        }
        self.unmasked.as_mut().unwrap()
    }

    // Take field
    pub fn take_unmasked(&mut self) -> super::acl::FsPermissionProto {
        self.unmasked.take().unwrap_or_else(|| super::acl::FsPermissionProto::new())
    }
}

impl ::protobuf::Message for MkdirsRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.masked.is_none() {
            return false;
        }
        if self.createParent.is_none() {
            return false;
        }
        for v in &self.masked {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unmasked {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.masked)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.createParent = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unmasked)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.masked.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.createParent {
            my_size += 2;
        }
        if let Some(ref v) = self.unmasked.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.masked.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.createParent {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.unmasked.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MkdirsRequestProto {
        MkdirsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &MkdirsRequestProto| { &m.src },
                |m: &mut MkdirsRequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::acl::FsPermissionProto>>(
                "masked",
                |m: &MkdirsRequestProto| { &m.masked },
                |m: &mut MkdirsRequestProto| { &mut m.masked },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "createParent",
                |m: &MkdirsRequestProto| { &m.createParent },
                |m: &mut MkdirsRequestProto| { &mut m.createParent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::acl::FsPermissionProto>>(
                "unmasked",
                |m: &MkdirsRequestProto| { &m.unmasked },
                |m: &mut MkdirsRequestProto| { &mut m.unmasked },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MkdirsRequestProto>(
                "MkdirsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MkdirsRequestProto {
        static instance: ::protobuf::rt::LazyV2<MkdirsRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MkdirsRequestProto::new)
    }
}

impl ::protobuf::Clear for MkdirsRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.masked.clear();
        self.createParent = ::std::option::Option::None;
        self.unmasked.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MkdirsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MkdirsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MkdirsResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MkdirsResponseProto {
    fn default() -> &'a MkdirsResponseProto {
        <MkdirsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl MkdirsResponseProto {
    pub fn new() -> MkdirsResponseProto {
        ::std::default::Default::default()
    }

    // required bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MkdirsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MkdirsResponseProto {
        MkdirsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "result",
                |m: &MkdirsResponseProto| { &m.result },
                |m: &mut MkdirsResponseProto| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MkdirsResponseProto>(
                "MkdirsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MkdirsResponseProto {
        static instance: ::protobuf::rt::LazyV2<MkdirsResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MkdirsResponseProto::new)
    }
}

impl ::protobuf::Clear for MkdirsResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MkdirsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MkdirsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetListingRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    startAfter: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    needLocation: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetListingRequestProto {
    fn default() -> &'a GetListingRequestProto {
        <GetListingRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetListingRequestProto {
    pub fn new() -> GetListingRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes startAfter = 2;


    pub fn get_startAfter(&self) -> &[u8] {
        match self.startAfter.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_startAfter(&mut self) {
        self.startAfter.clear();
    }

    pub fn has_startAfter(&self) -> bool {
        self.startAfter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startAfter(&mut self, v: ::std::vec::Vec<u8>) {
        self.startAfter = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startAfter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.startAfter.is_none() {
            self.startAfter.set_default();
        }
        self.startAfter.as_mut().unwrap()
    }

    // Take field
    pub fn take_startAfter(&mut self) -> ::std::vec::Vec<u8> {
        self.startAfter.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bool needLocation = 3;


    pub fn get_needLocation(&self) -> bool {
        self.needLocation.unwrap_or(false)
    }
    pub fn clear_needLocation(&mut self) {
        self.needLocation = ::std::option::Option::None;
    }

    pub fn has_needLocation(&self) -> bool {
        self.needLocation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needLocation(&mut self, v: bool) {
        self.needLocation = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetListingRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.startAfter.is_none() {
            return false;
        }
        if self.needLocation.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.startAfter)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needLocation = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.startAfter.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.needLocation {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.startAfter.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.needLocation {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetListingRequestProto {
        GetListingRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &GetListingRequestProto| { &m.src },
                |m: &mut GetListingRequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "startAfter",
                |m: &GetListingRequestProto| { &m.startAfter },
                |m: &mut GetListingRequestProto| { &mut m.startAfter },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "needLocation",
                |m: &GetListingRequestProto| { &m.needLocation },
                |m: &mut GetListingRequestProto| { &mut m.needLocation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetListingRequestProto>(
                "GetListingRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetListingRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetListingRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetListingRequestProto::new)
    }
}

impl ::protobuf::Clear for GetListingRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.startAfter.clear();
        self.needLocation = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetListingRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetListingRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetListingResponseProto {
    // message fields
    pub dirList: ::protobuf::SingularPtrField<super::hdfs::DirectoryListingProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetListingResponseProto {
    fn default() -> &'a GetListingResponseProto {
        <GetListingResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetListingResponseProto {
    pub fn new() -> GetListingResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.DirectoryListingProto dirList = 1;


    pub fn get_dirList(&self) -> &super::hdfs::DirectoryListingProto {
        self.dirList.as_ref().unwrap_or_else(|| <super::hdfs::DirectoryListingProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dirList(&mut self) {
        self.dirList.clear();
    }

    pub fn has_dirList(&self) -> bool {
        self.dirList.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dirList(&mut self, v: super::hdfs::DirectoryListingProto) {
        self.dirList = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dirList(&mut self) -> &mut super::hdfs::DirectoryListingProto {
        if self.dirList.is_none() {
            self.dirList.set_default();
        }
        self.dirList.as_mut().unwrap()
    }

    // Take field
    pub fn take_dirList(&mut self) -> super::hdfs::DirectoryListingProto {
        self.dirList.take().unwrap_or_else(|| super::hdfs::DirectoryListingProto::new())
    }
}

impl ::protobuf::Message for GetListingResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.dirList {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dirList)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dirList.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dirList.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetListingResponseProto {
        GetListingResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DirectoryListingProto>>(
                "dirList",
                |m: &GetListingResponseProto| { &m.dirList },
                |m: &mut GetListingResponseProto| { &mut m.dirList },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetListingResponseProto>(
                "GetListingResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetListingResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetListingResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetListingResponseProto::new)
    }
}

impl ::protobuf::Clear for GetListingResponseProto {
    fn clear(&mut self) {
        self.dirList.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetListingResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetListingResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBatchedListingRequestProto {
    // message fields
    pub paths: ::protobuf::RepeatedField<::std::string::String>,
    startAfter: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    needLocation: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBatchedListingRequestProto {
    fn default() -> &'a GetBatchedListingRequestProto {
        <GetBatchedListingRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetBatchedListingRequestProto {
    pub fn new() -> GetBatchedListingRequestProto {
        ::std::default::Default::default()
    }

    // repeated string paths = 1;


    pub fn get_paths(&self) -> &[::std::string::String] {
        &self.paths
    }
    pub fn clear_paths(&mut self) {
        self.paths.clear();
    }

    // Param is passed by value, moved
    pub fn set_paths(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.paths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_paths(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.paths
    }

    // Take field
    pub fn take_paths(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.paths, ::protobuf::RepeatedField::new())
    }

    // required bytes startAfter = 2;


    pub fn get_startAfter(&self) -> &[u8] {
        match self.startAfter.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_startAfter(&mut self) {
        self.startAfter.clear();
    }

    pub fn has_startAfter(&self) -> bool {
        self.startAfter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startAfter(&mut self, v: ::std::vec::Vec<u8>) {
        self.startAfter = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startAfter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.startAfter.is_none() {
            self.startAfter.set_default();
        }
        self.startAfter.as_mut().unwrap()
    }

    // Take field
    pub fn take_startAfter(&mut self) -> ::std::vec::Vec<u8> {
        self.startAfter.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bool needLocation = 3;


    pub fn get_needLocation(&self) -> bool {
        self.needLocation.unwrap_or(false)
    }
    pub fn clear_needLocation(&mut self) {
        self.needLocation = ::std::option::Option::None;
    }

    pub fn has_needLocation(&self) -> bool {
        self.needLocation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needLocation(&mut self, v: bool) {
        self.needLocation = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetBatchedListingRequestProto {
    fn is_initialized(&self) -> bool {
        if self.startAfter.is_none() {
            return false;
        }
        if self.needLocation.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.paths)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.startAfter)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needLocation = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.paths {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.startAfter.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.needLocation {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.paths {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.startAfter.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.needLocation {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBatchedListingRequestProto {
        GetBatchedListingRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "paths",
                |m: &GetBatchedListingRequestProto| { &m.paths },
                |m: &mut GetBatchedListingRequestProto| { &mut m.paths },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "startAfter",
                |m: &GetBatchedListingRequestProto| { &m.startAfter },
                |m: &mut GetBatchedListingRequestProto| { &mut m.startAfter },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "needLocation",
                |m: &GetBatchedListingRequestProto| { &m.needLocation },
                |m: &mut GetBatchedListingRequestProto| { &mut m.needLocation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetBatchedListingRequestProto>(
                "GetBatchedListingRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetBatchedListingRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetBatchedListingRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetBatchedListingRequestProto::new)
    }
}

impl ::protobuf::Clear for GetBatchedListingRequestProto {
    fn clear(&mut self) {
        self.paths.clear();
        self.startAfter.clear();
        self.needLocation = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBatchedListingRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBatchedListingRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBatchedListingResponseProto {
    // message fields
    pub listings: ::protobuf::RepeatedField<super::hdfs::BatchedDirectoryListingProto>,
    hasMore: ::std::option::Option<bool>,
    startAfter: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBatchedListingResponseProto {
    fn default() -> &'a GetBatchedListingResponseProto {
        <GetBatchedListingResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetBatchedListingResponseProto {
    pub fn new() -> GetBatchedListingResponseProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.BatchedDirectoryListingProto listings = 1;


    pub fn get_listings(&self) -> &[super::hdfs::BatchedDirectoryListingProto] {
        &self.listings
    }
    pub fn clear_listings(&mut self) {
        self.listings.clear();
    }

    // Param is passed by value, moved
    pub fn set_listings(&mut self, v: ::protobuf::RepeatedField<super::hdfs::BatchedDirectoryListingProto>) {
        self.listings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_listings(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::BatchedDirectoryListingProto> {
        &mut self.listings
    }

    // Take field
    pub fn take_listings(&mut self) -> ::protobuf::RepeatedField<super::hdfs::BatchedDirectoryListingProto> {
        ::std::mem::replace(&mut self.listings, ::protobuf::RepeatedField::new())
    }

    // required bool hasMore = 2;


    pub fn get_hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }
    pub fn clear_hasMore(&mut self) {
        self.hasMore = ::std::option::Option::None;
    }

    pub fn has_hasMore(&self) -> bool {
        self.hasMore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMore(&mut self, v: bool) {
        self.hasMore = ::std::option::Option::Some(v);
    }

    // required bytes startAfter = 3;


    pub fn get_startAfter(&self) -> &[u8] {
        match self.startAfter.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_startAfter(&mut self) {
        self.startAfter.clear();
    }

    pub fn has_startAfter(&self) -> bool {
        self.startAfter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startAfter(&mut self, v: ::std::vec::Vec<u8>) {
        self.startAfter = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startAfter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.startAfter.is_none() {
            self.startAfter.set_default();
        }
        self.startAfter.as_mut().unwrap()
    }

    // Take field
    pub fn take_startAfter(&mut self) -> ::std::vec::Vec<u8> {
        self.startAfter.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetBatchedListingResponseProto {
    fn is_initialized(&self) -> bool {
        if self.hasMore.is_none() {
            return false;
        }
        if self.startAfter.is_none() {
            return false;
        }
        for v in &self.listings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.listings)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasMore = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.startAfter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.listings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.hasMore {
            my_size += 2;
        }
        if let Some(ref v) = self.startAfter.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.listings {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.hasMore {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.startAfter.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBatchedListingResponseProto {
        GetBatchedListingResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::BatchedDirectoryListingProto>>(
                "listings",
                |m: &GetBatchedListingResponseProto| { &m.listings },
                |m: &mut GetBatchedListingResponseProto| { &mut m.listings },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasMore",
                |m: &GetBatchedListingResponseProto| { &m.hasMore },
                |m: &mut GetBatchedListingResponseProto| { &mut m.hasMore },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "startAfter",
                |m: &GetBatchedListingResponseProto| { &m.startAfter },
                |m: &mut GetBatchedListingResponseProto| { &mut m.startAfter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetBatchedListingResponseProto>(
                "GetBatchedListingResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetBatchedListingResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetBatchedListingResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetBatchedListingResponseProto::new)
    }
}

impl ::protobuf::Clear for GetBatchedListingResponseProto {
    fn clear(&mut self) {
        self.listings.clear();
        self.hasMore = ::std::option::Option::None;
        self.startAfter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBatchedListingResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBatchedListingResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshottableDirListingRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSnapshottableDirListingRequestProto {
    fn default() -> &'a GetSnapshottableDirListingRequestProto {
        <GetSnapshottableDirListingRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetSnapshottableDirListingRequestProto {
    pub fn new() -> GetSnapshottableDirListingRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetSnapshottableDirListingRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSnapshottableDirListingRequestProto {
        GetSnapshottableDirListingRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSnapshottableDirListingRequestProto>(
                "GetSnapshottableDirListingRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSnapshottableDirListingRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetSnapshottableDirListingRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSnapshottableDirListingRequestProto::new)
    }
}

impl ::protobuf::Clear for GetSnapshottableDirListingRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshottableDirListingRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshottableDirListingRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshottableDirListingResponseProto {
    // message fields
    pub snapshottableDirList: ::protobuf::SingularPtrField<super::hdfs::SnapshottableDirectoryListingProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSnapshottableDirListingResponseProto {
    fn default() -> &'a GetSnapshottableDirListingResponseProto {
        <GetSnapshottableDirListingResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetSnapshottableDirListingResponseProto {
    pub fn new() -> GetSnapshottableDirListingResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.SnapshottableDirectoryListingProto snapshottableDirList = 1;


    pub fn get_snapshottableDirList(&self) -> &super::hdfs::SnapshottableDirectoryListingProto {
        self.snapshottableDirList.as_ref().unwrap_or_else(|| <super::hdfs::SnapshottableDirectoryListingProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_snapshottableDirList(&mut self) {
        self.snapshottableDirList.clear();
    }

    pub fn has_snapshottableDirList(&self) -> bool {
        self.snapshottableDirList.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshottableDirList(&mut self, v: super::hdfs::SnapshottableDirectoryListingProto) {
        self.snapshottableDirList = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshottableDirList(&mut self) -> &mut super::hdfs::SnapshottableDirectoryListingProto {
        if self.snapshottableDirList.is_none() {
            self.snapshottableDirList.set_default();
        }
        self.snapshottableDirList.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshottableDirList(&mut self) -> super::hdfs::SnapshottableDirectoryListingProto {
        self.snapshottableDirList.take().unwrap_or_else(|| super::hdfs::SnapshottableDirectoryListingProto::new())
    }
}

impl ::protobuf::Message for GetSnapshottableDirListingResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.snapshottableDirList {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.snapshottableDirList)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshottableDirList.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshottableDirList.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSnapshottableDirListingResponseProto {
        GetSnapshottableDirListingResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::SnapshottableDirectoryListingProto>>(
                "snapshottableDirList",
                |m: &GetSnapshottableDirListingResponseProto| { &m.snapshottableDirList },
                |m: &mut GetSnapshottableDirListingResponseProto| { &mut m.snapshottableDirList },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSnapshottableDirListingResponseProto>(
                "GetSnapshottableDirListingResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSnapshottableDirListingResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetSnapshottableDirListingResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSnapshottableDirListingResponseProto::new)
    }
}

impl ::protobuf::Clear for GetSnapshottableDirListingResponseProto {
    fn clear(&mut self) {
        self.snapshottableDirList.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshottableDirListingResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshottableDirListingResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshotListingRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSnapshotListingRequestProto {
    fn default() -> &'a GetSnapshotListingRequestProto {
        <GetSnapshotListingRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetSnapshotListingRequestProto {
    pub fn new() -> GetSnapshotListingRequestProto {
        ::std::default::Default::default()
    }

    // required string snapshotRoot = 1;


    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetSnapshotListingRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSnapshotListingRequestProto {
        GetSnapshotListingRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snapshotRoot",
                |m: &GetSnapshotListingRequestProto| { &m.snapshotRoot },
                |m: &mut GetSnapshotListingRequestProto| { &mut m.snapshotRoot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSnapshotListingRequestProto>(
                "GetSnapshotListingRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSnapshotListingRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetSnapshotListingRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSnapshotListingRequestProto::new)
    }
}

impl ::protobuf::Clear for GetSnapshotListingRequestProto {
    fn clear(&mut self) {
        self.snapshotRoot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshotListingRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshotListingRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshotListingResponseProto {
    // message fields
    pub snapshotList: ::protobuf::SingularPtrField<super::hdfs::SnapshotListingProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSnapshotListingResponseProto {
    fn default() -> &'a GetSnapshotListingResponseProto {
        <GetSnapshotListingResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetSnapshotListingResponseProto {
    pub fn new() -> GetSnapshotListingResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.SnapshotListingProto snapshotList = 1;


    pub fn get_snapshotList(&self) -> &super::hdfs::SnapshotListingProto {
        self.snapshotList.as_ref().unwrap_or_else(|| <super::hdfs::SnapshotListingProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_snapshotList(&mut self) {
        self.snapshotList.clear();
    }

    pub fn has_snapshotList(&self) -> bool {
        self.snapshotList.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotList(&mut self, v: super::hdfs::SnapshotListingProto) {
        self.snapshotList = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotList(&mut self) -> &mut super::hdfs::SnapshotListingProto {
        if self.snapshotList.is_none() {
            self.snapshotList.set_default();
        }
        self.snapshotList.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotList(&mut self) -> super::hdfs::SnapshotListingProto {
        self.snapshotList.take().unwrap_or_else(|| super::hdfs::SnapshotListingProto::new())
    }
}

impl ::protobuf::Message for GetSnapshotListingResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.snapshotList {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.snapshotList)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotList.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotList.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSnapshotListingResponseProto {
        GetSnapshotListingResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::SnapshotListingProto>>(
                "snapshotList",
                |m: &GetSnapshotListingResponseProto| { &m.snapshotList },
                |m: &mut GetSnapshotListingResponseProto| { &mut m.snapshotList },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSnapshotListingResponseProto>(
                "GetSnapshotListingResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSnapshotListingResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetSnapshotListingResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSnapshotListingResponseProto::new)
    }
}

impl ::protobuf::Clear for GetSnapshotListingResponseProto {
    fn clear(&mut self) {
        self.snapshotList.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshotListingResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshotListingResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshotDiffReportRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    fromSnapshot: ::protobuf::SingularField<::std::string::String>,
    toSnapshot: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSnapshotDiffReportRequestProto {
    fn default() -> &'a GetSnapshotDiffReportRequestProto {
        <GetSnapshotDiffReportRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetSnapshotDiffReportRequestProto {
    pub fn new() -> GetSnapshotDiffReportRequestProto {
        ::std::default::Default::default()
    }

    // required string snapshotRoot = 1;


    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string fromSnapshot = 2;


    pub fn get_fromSnapshot(&self) -> &str {
        match self.fromSnapshot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fromSnapshot(&mut self) {
        self.fromSnapshot.clear();
    }

    pub fn has_fromSnapshot(&self) -> bool {
        self.fromSnapshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromSnapshot(&mut self, v: ::std::string::String) {
        self.fromSnapshot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fromSnapshot(&mut self) -> &mut ::std::string::String {
        if self.fromSnapshot.is_none() {
            self.fromSnapshot.set_default();
        }
        self.fromSnapshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_fromSnapshot(&mut self) -> ::std::string::String {
        self.fromSnapshot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string toSnapshot = 3;


    pub fn get_toSnapshot(&self) -> &str {
        match self.toSnapshot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_toSnapshot(&mut self) {
        self.toSnapshot.clear();
    }

    pub fn has_toSnapshot(&self) -> bool {
        self.toSnapshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toSnapshot(&mut self, v: ::std::string::String) {
        self.toSnapshot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toSnapshot(&mut self) -> &mut ::std::string::String {
        if self.toSnapshot.is_none() {
            self.toSnapshot.set_default();
        }
        self.toSnapshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_toSnapshot(&mut self) -> ::std::string::String {
        self.toSnapshot.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetSnapshotDiffReportRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        if self.fromSnapshot.is_none() {
            return false;
        }
        if self.toSnapshot.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fromSnapshot)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.toSnapshot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fromSnapshot.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.toSnapshot.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fromSnapshot.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.toSnapshot.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSnapshotDiffReportRequestProto {
        GetSnapshotDiffReportRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snapshotRoot",
                |m: &GetSnapshotDiffReportRequestProto| { &m.snapshotRoot },
                |m: &mut GetSnapshotDiffReportRequestProto| { &mut m.snapshotRoot },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fromSnapshot",
                |m: &GetSnapshotDiffReportRequestProto| { &m.fromSnapshot },
                |m: &mut GetSnapshotDiffReportRequestProto| { &mut m.fromSnapshot },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "toSnapshot",
                |m: &GetSnapshotDiffReportRequestProto| { &m.toSnapshot },
                |m: &mut GetSnapshotDiffReportRequestProto| { &mut m.toSnapshot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSnapshotDiffReportRequestProto>(
                "GetSnapshotDiffReportRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSnapshotDiffReportRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetSnapshotDiffReportRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSnapshotDiffReportRequestProto::new)
    }
}

impl ::protobuf::Clear for GetSnapshotDiffReportRequestProto {
    fn clear(&mut self) {
        self.snapshotRoot.clear();
        self.fromSnapshot.clear();
        self.toSnapshot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshotDiffReportRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshotDiffReportRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshotDiffReportResponseProto {
    // message fields
    pub diffReport: ::protobuf::SingularPtrField<super::hdfs::SnapshotDiffReportProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSnapshotDiffReportResponseProto {
    fn default() -> &'a GetSnapshotDiffReportResponseProto {
        <GetSnapshotDiffReportResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetSnapshotDiffReportResponseProto {
    pub fn new() -> GetSnapshotDiffReportResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.SnapshotDiffReportProto diffReport = 1;


    pub fn get_diffReport(&self) -> &super::hdfs::SnapshotDiffReportProto {
        self.diffReport.as_ref().unwrap_or_else(|| <super::hdfs::SnapshotDiffReportProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_diffReport(&mut self) {
        self.diffReport.clear();
    }

    pub fn has_diffReport(&self) -> bool {
        self.diffReport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diffReport(&mut self, v: super::hdfs::SnapshotDiffReportProto) {
        self.diffReport = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_diffReport(&mut self) -> &mut super::hdfs::SnapshotDiffReportProto {
        if self.diffReport.is_none() {
            self.diffReport.set_default();
        }
        self.diffReport.as_mut().unwrap()
    }

    // Take field
    pub fn take_diffReport(&mut self) -> super::hdfs::SnapshotDiffReportProto {
        self.diffReport.take().unwrap_or_else(|| super::hdfs::SnapshotDiffReportProto::new())
    }
}

impl ::protobuf::Message for GetSnapshotDiffReportResponseProto {
    fn is_initialized(&self) -> bool {
        if self.diffReport.is_none() {
            return false;
        }
        for v in &self.diffReport {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.diffReport)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.diffReport.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.diffReport.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSnapshotDiffReportResponseProto {
        GetSnapshotDiffReportResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::SnapshotDiffReportProto>>(
                "diffReport",
                |m: &GetSnapshotDiffReportResponseProto| { &m.diffReport },
                |m: &mut GetSnapshotDiffReportResponseProto| { &mut m.diffReport },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSnapshotDiffReportResponseProto>(
                "GetSnapshotDiffReportResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSnapshotDiffReportResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetSnapshotDiffReportResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSnapshotDiffReportResponseProto::new)
    }
}

impl ::protobuf::Clear for GetSnapshotDiffReportResponseProto {
    fn clear(&mut self) {
        self.diffReport.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshotDiffReportResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshotDiffReportResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshotDiffReportListingRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    fromSnapshot: ::protobuf::SingularField<::std::string::String>,
    toSnapshot: ::protobuf::SingularField<::std::string::String>,
    pub cursor: ::protobuf::SingularPtrField<super::hdfs::SnapshotDiffReportCursorProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSnapshotDiffReportListingRequestProto {
    fn default() -> &'a GetSnapshotDiffReportListingRequestProto {
        <GetSnapshotDiffReportListingRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetSnapshotDiffReportListingRequestProto {
    pub fn new() -> GetSnapshotDiffReportListingRequestProto {
        ::std::default::Default::default()
    }

    // required string snapshotRoot = 1;


    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string fromSnapshot = 2;


    pub fn get_fromSnapshot(&self) -> &str {
        match self.fromSnapshot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fromSnapshot(&mut self) {
        self.fromSnapshot.clear();
    }

    pub fn has_fromSnapshot(&self) -> bool {
        self.fromSnapshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromSnapshot(&mut self, v: ::std::string::String) {
        self.fromSnapshot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fromSnapshot(&mut self) -> &mut ::std::string::String {
        if self.fromSnapshot.is_none() {
            self.fromSnapshot.set_default();
        }
        self.fromSnapshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_fromSnapshot(&mut self) -> ::std::string::String {
        self.fromSnapshot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string toSnapshot = 3;


    pub fn get_toSnapshot(&self) -> &str {
        match self.toSnapshot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_toSnapshot(&mut self) {
        self.toSnapshot.clear();
    }

    pub fn has_toSnapshot(&self) -> bool {
        self.toSnapshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toSnapshot(&mut self, v: ::std::string::String) {
        self.toSnapshot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toSnapshot(&mut self) -> &mut ::std::string::String {
        if self.toSnapshot.is_none() {
            self.toSnapshot.set_default();
        }
        self.toSnapshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_toSnapshot(&mut self) -> ::std::string::String {
        self.toSnapshot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .hadoop.hdfs.SnapshotDiffReportCursorProto cursor = 4;


    pub fn get_cursor(&self) -> &super::hdfs::SnapshotDiffReportCursorProto {
        self.cursor.as_ref().unwrap_or_else(|| <super::hdfs::SnapshotDiffReportCursorProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cursor(&mut self) {
        self.cursor.clear();
    }

    pub fn has_cursor(&self) -> bool {
        self.cursor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor(&mut self, v: super::hdfs::SnapshotDiffReportCursorProto) {
        self.cursor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cursor(&mut self) -> &mut super::hdfs::SnapshotDiffReportCursorProto {
        if self.cursor.is_none() {
            self.cursor.set_default();
        }
        self.cursor.as_mut().unwrap()
    }

    // Take field
    pub fn take_cursor(&mut self) -> super::hdfs::SnapshotDiffReportCursorProto {
        self.cursor.take().unwrap_or_else(|| super::hdfs::SnapshotDiffReportCursorProto::new())
    }
}

impl ::protobuf::Message for GetSnapshotDiffReportListingRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        if self.fromSnapshot.is_none() {
            return false;
        }
        if self.toSnapshot.is_none() {
            return false;
        }
        for v in &self.cursor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fromSnapshot)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.toSnapshot)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cursor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fromSnapshot.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.toSnapshot.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.cursor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fromSnapshot.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.toSnapshot.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.cursor.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSnapshotDiffReportListingRequestProto {
        GetSnapshotDiffReportListingRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snapshotRoot",
                |m: &GetSnapshotDiffReportListingRequestProto| { &m.snapshotRoot },
                |m: &mut GetSnapshotDiffReportListingRequestProto| { &mut m.snapshotRoot },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fromSnapshot",
                |m: &GetSnapshotDiffReportListingRequestProto| { &m.fromSnapshot },
                |m: &mut GetSnapshotDiffReportListingRequestProto| { &mut m.fromSnapshot },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "toSnapshot",
                |m: &GetSnapshotDiffReportListingRequestProto| { &m.toSnapshot },
                |m: &mut GetSnapshotDiffReportListingRequestProto| { &mut m.toSnapshot },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::SnapshotDiffReportCursorProto>>(
                "cursor",
                |m: &GetSnapshotDiffReportListingRequestProto| { &m.cursor },
                |m: &mut GetSnapshotDiffReportListingRequestProto| { &mut m.cursor },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSnapshotDiffReportListingRequestProto>(
                "GetSnapshotDiffReportListingRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSnapshotDiffReportListingRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetSnapshotDiffReportListingRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSnapshotDiffReportListingRequestProto::new)
    }
}

impl ::protobuf::Clear for GetSnapshotDiffReportListingRequestProto {
    fn clear(&mut self) {
        self.snapshotRoot.clear();
        self.fromSnapshot.clear();
        self.toSnapshot.clear();
        self.cursor.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshotDiffReportListingRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshotDiffReportListingRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshotDiffReportListingResponseProto {
    // message fields
    pub diffReport: ::protobuf::SingularPtrField<super::hdfs::SnapshotDiffReportListingProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSnapshotDiffReportListingResponseProto {
    fn default() -> &'a GetSnapshotDiffReportListingResponseProto {
        <GetSnapshotDiffReportListingResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetSnapshotDiffReportListingResponseProto {
    pub fn new() -> GetSnapshotDiffReportListingResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.SnapshotDiffReportListingProto diffReport = 1;


    pub fn get_diffReport(&self) -> &super::hdfs::SnapshotDiffReportListingProto {
        self.diffReport.as_ref().unwrap_or_else(|| <super::hdfs::SnapshotDiffReportListingProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_diffReport(&mut self) {
        self.diffReport.clear();
    }

    pub fn has_diffReport(&self) -> bool {
        self.diffReport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diffReport(&mut self, v: super::hdfs::SnapshotDiffReportListingProto) {
        self.diffReport = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_diffReport(&mut self) -> &mut super::hdfs::SnapshotDiffReportListingProto {
        if self.diffReport.is_none() {
            self.diffReport.set_default();
        }
        self.diffReport.as_mut().unwrap()
    }

    // Take field
    pub fn take_diffReport(&mut self) -> super::hdfs::SnapshotDiffReportListingProto {
        self.diffReport.take().unwrap_or_else(|| super::hdfs::SnapshotDiffReportListingProto::new())
    }
}

impl ::protobuf::Message for GetSnapshotDiffReportListingResponseProto {
    fn is_initialized(&self) -> bool {
        if self.diffReport.is_none() {
            return false;
        }
        for v in &self.diffReport {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.diffReport)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.diffReport.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.diffReport.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSnapshotDiffReportListingResponseProto {
        GetSnapshotDiffReportListingResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::SnapshotDiffReportListingProto>>(
                "diffReport",
                |m: &GetSnapshotDiffReportListingResponseProto| { &m.diffReport },
                |m: &mut GetSnapshotDiffReportListingResponseProto| { &mut m.diffReport },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSnapshotDiffReportListingResponseProto>(
                "GetSnapshotDiffReportListingResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSnapshotDiffReportListingResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetSnapshotDiffReportListingResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSnapshotDiffReportListingResponseProto::new)
    }
}

impl ::protobuf::Clear for GetSnapshotDiffReportListingResponseProto {
    fn clear(&mut self) {
        self.diffReport.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshotDiffReportListingResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshotDiffReportListingResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenewLeaseRequestProto {
    // message fields
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RenewLeaseRequestProto {
    fn default() -> &'a RenewLeaseRequestProto {
        <RenewLeaseRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RenewLeaseRequestProto {
    pub fn new() -> RenewLeaseRequestProto {
        ::std::default::Default::default()
    }

    // required string clientName = 1;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for RenewLeaseRequestProto {
    fn is_initialized(&self) -> bool {
        if self.clientName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RenewLeaseRequestProto {
        RenewLeaseRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientName",
                |m: &RenewLeaseRequestProto| { &m.clientName },
                |m: &mut RenewLeaseRequestProto| { &mut m.clientName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RenewLeaseRequestProto>(
                "RenewLeaseRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RenewLeaseRequestProto {
        static instance: ::protobuf::rt::LazyV2<RenewLeaseRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RenewLeaseRequestProto::new)
    }
}

impl ::protobuf::Clear for RenewLeaseRequestProto {
    fn clear(&mut self) {
        self.clientName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenewLeaseRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenewLeaseRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenewLeaseResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RenewLeaseResponseProto {
    fn default() -> &'a RenewLeaseResponseProto {
        <RenewLeaseResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RenewLeaseResponseProto {
    pub fn new() -> RenewLeaseResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RenewLeaseResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RenewLeaseResponseProto {
        RenewLeaseResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RenewLeaseResponseProto>(
                "RenewLeaseResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RenewLeaseResponseProto {
        static instance: ::protobuf::rt::LazyV2<RenewLeaseResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RenewLeaseResponseProto::new)
    }
}

impl ::protobuf::Clear for RenewLeaseResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenewLeaseResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenewLeaseResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecoverLeaseRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecoverLeaseRequestProto {
    fn default() -> &'a RecoverLeaseRequestProto {
        <RecoverLeaseRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RecoverLeaseRequestProto {
    pub fn new() -> RecoverLeaseRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string clientName = 2;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for RecoverLeaseRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecoverLeaseRequestProto {
        RecoverLeaseRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &RecoverLeaseRequestProto| { &m.src },
                |m: &mut RecoverLeaseRequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientName",
                |m: &RecoverLeaseRequestProto| { &m.clientName },
                |m: &mut RecoverLeaseRequestProto| { &mut m.clientName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecoverLeaseRequestProto>(
                "RecoverLeaseRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecoverLeaseRequestProto {
        static instance: ::protobuf::rt::LazyV2<RecoverLeaseRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecoverLeaseRequestProto::new)
    }
}

impl ::protobuf::Clear for RecoverLeaseRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.clientName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecoverLeaseRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecoverLeaseRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecoverLeaseResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecoverLeaseResponseProto {
    fn default() -> &'a RecoverLeaseResponseProto {
        <RecoverLeaseResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RecoverLeaseResponseProto {
    pub fn new() -> RecoverLeaseResponseProto {
        ::std::default::Default::default()
    }

    // required bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RecoverLeaseResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecoverLeaseResponseProto {
        RecoverLeaseResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "result",
                |m: &RecoverLeaseResponseProto| { &m.result },
                |m: &mut RecoverLeaseResponseProto| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecoverLeaseResponseProto>(
                "RecoverLeaseResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecoverLeaseResponseProto {
        static instance: ::protobuf::rt::LazyV2<RecoverLeaseResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecoverLeaseResponseProto::new)
    }
}

impl ::protobuf::Clear for RecoverLeaseResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecoverLeaseResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecoverLeaseResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFsStatusRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFsStatusRequestProto {
    fn default() -> &'a GetFsStatusRequestProto {
        <GetFsStatusRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetFsStatusRequestProto {
    pub fn new() -> GetFsStatusRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetFsStatusRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFsStatusRequestProto {
        GetFsStatusRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFsStatusRequestProto>(
                "GetFsStatusRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFsStatusRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetFsStatusRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFsStatusRequestProto::new)
    }
}

impl ::protobuf::Clear for GetFsStatusRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFsStatusRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFsStatusRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFsStatsResponseProto {
    // message fields
    capacity: ::std::option::Option<u64>,
    used: ::std::option::Option<u64>,
    remaining: ::std::option::Option<u64>,
    under_replicated: ::std::option::Option<u64>,
    corrupt_blocks: ::std::option::Option<u64>,
    missing_blocks: ::std::option::Option<u64>,
    missing_repl_one_blocks: ::std::option::Option<u64>,
    blocks_in_future: ::std::option::Option<u64>,
    pending_deletion_blocks: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFsStatsResponseProto {
    fn default() -> &'a GetFsStatsResponseProto {
        <GetFsStatsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetFsStatsResponseProto {
    pub fn new() -> GetFsStatsResponseProto {
        ::std::default::Default::default()
    }

    // required uint64 capacity = 1;


    pub fn get_capacity(&self) -> u64 {
        self.capacity.unwrap_or(0)
    }
    pub fn clear_capacity(&mut self) {
        self.capacity = ::std::option::Option::None;
    }

    pub fn has_capacity(&self) -> bool {
        self.capacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: u64) {
        self.capacity = ::std::option::Option::Some(v);
    }

    // required uint64 used = 2;


    pub fn get_used(&self) -> u64 {
        self.used.unwrap_or(0)
    }
    pub fn clear_used(&mut self) {
        self.used = ::std::option::Option::None;
    }

    pub fn has_used(&self) -> bool {
        self.used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_used(&mut self, v: u64) {
        self.used = ::std::option::Option::Some(v);
    }

    // required uint64 remaining = 3;


    pub fn get_remaining(&self) -> u64 {
        self.remaining.unwrap_or(0)
    }
    pub fn clear_remaining(&mut self) {
        self.remaining = ::std::option::Option::None;
    }

    pub fn has_remaining(&self) -> bool {
        self.remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remaining(&mut self, v: u64) {
        self.remaining = ::std::option::Option::Some(v);
    }

    // required uint64 under_replicated = 4;


    pub fn get_under_replicated(&self) -> u64 {
        self.under_replicated.unwrap_or(0)
    }
    pub fn clear_under_replicated(&mut self) {
        self.under_replicated = ::std::option::Option::None;
    }

    pub fn has_under_replicated(&self) -> bool {
        self.under_replicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_under_replicated(&mut self, v: u64) {
        self.under_replicated = ::std::option::Option::Some(v);
    }

    // required uint64 corrupt_blocks = 5;


    pub fn get_corrupt_blocks(&self) -> u64 {
        self.corrupt_blocks.unwrap_or(0)
    }
    pub fn clear_corrupt_blocks(&mut self) {
        self.corrupt_blocks = ::std::option::Option::None;
    }

    pub fn has_corrupt_blocks(&self) -> bool {
        self.corrupt_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_corrupt_blocks(&mut self, v: u64) {
        self.corrupt_blocks = ::std::option::Option::Some(v);
    }

    // required uint64 missing_blocks = 6;


    pub fn get_missing_blocks(&self) -> u64 {
        self.missing_blocks.unwrap_or(0)
    }
    pub fn clear_missing_blocks(&mut self) {
        self.missing_blocks = ::std::option::Option::None;
    }

    pub fn has_missing_blocks(&self) -> bool {
        self.missing_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missing_blocks(&mut self, v: u64) {
        self.missing_blocks = ::std::option::Option::Some(v);
    }

    // optional uint64 missing_repl_one_blocks = 7;


    pub fn get_missing_repl_one_blocks(&self) -> u64 {
        self.missing_repl_one_blocks.unwrap_or(0)
    }
    pub fn clear_missing_repl_one_blocks(&mut self) {
        self.missing_repl_one_blocks = ::std::option::Option::None;
    }

    pub fn has_missing_repl_one_blocks(&self) -> bool {
        self.missing_repl_one_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missing_repl_one_blocks(&mut self, v: u64) {
        self.missing_repl_one_blocks = ::std::option::Option::Some(v);
    }

    // optional uint64 blocks_in_future = 8;


    pub fn get_blocks_in_future(&self) -> u64 {
        self.blocks_in_future.unwrap_or(0)
    }
    pub fn clear_blocks_in_future(&mut self) {
        self.blocks_in_future = ::std::option::Option::None;
    }

    pub fn has_blocks_in_future(&self) -> bool {
        self.blocks_in_future.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blocks_in_future(&mut self, v: u64) {
        self.blocks_in_future = ::std::option::Option::Some(v);
    }

    // optional uint64 pending_deletion_blocks = 9;


    pub fn get_pending_deletion_blocks(&self) -> u64 {
        self.pending_deletion_blocks.unwrap_or(0)
    }
    pub fn clear_pending_deletion_blocks(&mut self) {
        self.pending_deletion_blocks = ::std::option::Option::None;
    }

    pub fn has_pending_deletion_blocks(&self) -> bool {
        self.pending_deletion_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pending_deletion_blocks(&mut self, v: u64) {
        self.pending_deletion_blocks = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetFsStatsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.capacity.is_none() {
            return false;
        }
        if self.used.is_none() {
            return false;
        }
        if self.remaining.is_none() {
            return false;
        }
        if self.under_replicated.is_none() {
            return false;
        }
        if self.corrupt_blocks.is_none() {
            return false;
        }
        if self.missing_blocks.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.capacity = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.used = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.remaining = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.under_replicated = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.corrupt_blocks = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.missing_blocks = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.missing_repl_one_blocks = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blocks_in_future = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.pending_deletion_blocks = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.capacity {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.used {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.remaining {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.under_replicated {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.corrupt_blocks {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.missing_blocks {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.missing_repl_one_blocks {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blocks_in_future {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pending_deletion_blocks {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.capacity {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.used {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.remaining {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.under_replicated {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.corrupt_blocks {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.missing_blocks {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.missing_repl_one_blocks {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.blocks_in_future {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.pending_deletion_blocks {
            os.write_uint64(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFsStatsResponseProto {
        GetFsStatsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "capacity",
                |m: &GetFsStatsResponseProto| { &m.capacity },
                |m: &mut GetFsStatsResponseProto| { &mut m.capacity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "used",
                |m: &GetFsStatsResponseProto| { &m.used },
                |m: &mut GetFsStatsResponseProto| { &mut m.used },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "remaining",
                |m: &GetFsStatsResponseProto| { &m.remaining },
                |m: &mut GetFsStatsResponseProto| { &mut m.remaining },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "under_replicated",
                |m: &GetFsStatsResponseProto| { &m.under_replicated },
                |m: &mut GetFsStatsResponseProto| { &mut m.under_replicated },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "corrupt_blocks",
                |m: &GetFsStatsResponseProto| { &m.corrupt_blocks },
                |m: &mut GetFsStatsResponseProto| { &mut m.corrupt_blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "missing_blocks",
                |m: &GetFsStatsResponseProto| { &m.missing_blocks },
                |m: &mut GetFsStatsResponseProto| { &mut m.missing_blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "missing_repl_one_blocks",
                |m: &GetFsStatsResponseProto| { &m.missing_repl_one_blocks },
                |m: &mut GetFsStatsResponseProto| { &mut m.missing_repl_one_blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "blocks_in_future",
                |m: &GetFsStatsResponseProto| { &m.blocks_in_future },
                |m: &mut GetFsStatsResponseProto| { &mut m.blocks_in_future },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "pending_deletion_blocks",
                |m: &GetFsStatsResponseProto| { &m.pending_deletion_blocks },
                |m: &mut GetFsStatsResponseProto| { &mut m.pending_deletion_blocks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFsStatsResponseProto>(
                "GetFsStatsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFsStatsResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetFsStatsResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFsStatsResponseProto::new)
    }
}

impl ::protobuf::Clear for GetFsStatsResponseProto {
    fn clear(&mut self) {
        self.capacity = ::std::option::Option::None;
        self.used = ::std::option::Option::None;
        self.remaining = ::std::option::Option::None;
        self.under_replicated = ::std::option::Option::None;
        self.corrupt_blocks = ::std::option::Option::None;
        self.missing_blocks = ::std::option::Option::None;
        self.missing_repl_one_blocks = ::std::option::Option::None;
        self.blocks_in_future = ::std::option::Option::None;
        self.pending_deletion_blocks = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFsStatsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFsStatsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFsReplicatedBlockStatsRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFsReplicatedBlockStatsRequestProto {
    fn default() -> &'a GetFsReplicatedBlockStatsRequestProto {
        <GetFsReplicatedBlockStatsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetFsReplicatedBlockStatsRequestProto {
    pub fn new() -> GetFsReplicatedBlockStatsRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetFsReplicatedBlockStatsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFsReplicatedBlockStatsRequestProto {
        GetFsReplicatedBlockStatsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFsReplicatedBlockStatsRequestProto>(
                "GetFsReplicatedBlockStatsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFsReplicatedBlockStatsRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetFsReplicatedBlockStatsRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFsReplicatedBlockStatsRequestProto::new)
    }
}

impl ::protobuf::Clear for GetFsReplicatedBlockStatsRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFsReplicatedBlockStatsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFsReplicatedBlockStatsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFsReplicatedBlockStatsResponseProto {
    // message fields
    low_redundancy: ::std::option::Option<u64>,
    corrupt_blocks: ::std::option::Option<u64>,
    missing_blocks: ::std::option::Option<u64>,
    missing_repl_one_blocks: ::std::option::Option<u64>,
    blocks_in_future: ::std::option::Option<u64>,
    pending_deletion_blocks: ::std::option::Option<u64>,
    highest_prio_low_redundancy_blocks: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFsReplicatedBlockStatsResponseProto {
    fn default() -> &'a GetFsReplicatedBlockStatsResponseProto {
        <GetFsReplicatedBlockStatsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetFsReplicatedBlockStatsResponseProto {
    pub fn new() -> GetFsReplicatedBlockStatsResponseProto {
        ::std::default::Default::default()
    }

    // required uint64 low_redundancy = 1;


    pub fn get_low_redundancy(&self) -> u64 {
        self.low_redundancy.unwrap_or(0)
    }
    pub fn clear_low_redundancy(&mut self) {
        self.low_redundancy = ::std::option::Option::None;
    }

    pub fn has_low_redundancy(&self) -> bool {
        self.low_redundancy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_redundancy(&mut self, v: u64) {
        self.low_redundancy = ::std::option::Option::Some(v);
    }

    // required uint64 corrupt_blocks = 2;


    pub fn get_corrupt_blocks(&self) -> u64 {
        self.corrupt_blocks.unwrap_or(0)
    }
    pub fn clear_corrupt_blocks(&mut self) {
        self.corrupt_blocks = ::std::option::Option::None;
    }

    pub fn has_corrupt_blocks(&self) -> bool {
        self.corrupt_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_corrupt_blocks(&mut self, v: u64) {
        self.corrupt_blocks = ::std::option::Option::Some(v);
    }

    // required uint64 missing_blocks = 3;


    pub fn get_missing_blocks(&self) -> u64 {
        self.missing_blocks.unwrap_or(0)
    }
    pub fn clear_missing_blocks(&mut self) {
        self.missing_blocks = ::std::option::Option::None;
    }

    pub fn has_missing_blocks(&self) -> bool {
        self.missing_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missing_blocks(&mut self, v: u64) {
        self.missing_blocks = ::std::option::Option::Some(v);
    }

    // required uint64 missing_repl_one_blocks = 4;


    pub fn get_missing_repl_one_blocks(&self) -> u64 {
        self.missing_repl_one_blocks.unwrap_or(0)
    }
    pub fn clear_missing_repl_one_blocks(&mut self) {
        self.missing_repl_one_blocks = ::std::option::Option::None;
    }

    pub fn has_missing_repl_one_blocks(&self) -> bool {
        self.missing_repl_one_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missing_repl_one_blocks(&mut self, v: u64) {
        self.missing_repl_one_blocks = ::std::option::Option::Some(v);
    }

    // required uint64 blocks_in_future = 5;


    pub fn get_blocks_in_future(&self) -> u64 {
        self.blocks_in_future.unwrap_or(0)
    }
    pub fn clear_blocks_in_future(&mut self) {
        self.blocks_in_future = ::std::option::Option::None;
    }

    pub fn has_blocks_in_future(&self) -> bool {
        self.blocks_in_future.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blocks_in_future(&mut self, v: u64) {
        self.blocks_in_future = ::std::option::Option::Some(v);
    }

    // required uint64 pending_deletion_blocks = 6;


    pub fn get_pending_deletion_blocks(&self) -> u64 {
        self.pending_deletion_blocks.unwrap_or(0)
    }
    pub fn clear_pending_deletion_blocks(&mut self) {
        self.pending_deletion_blocks = ::std::option::Option::None;
    }

    pub fn has_pending_deletion_blocks(&self) -> bool {
        self.pending_deletion_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pending_deletion_blocks(&mut self, v: u64) {
        self.pending_deletion_blocks = ::std::option::Option::Some(v);
    }

    // optional uint64 highest_prio_low_redundancy_blocks = 7;


    pub fn get_highest_prio_low_redundancy_blocks(&self) -> u64 {
        self.highest_prio_low_redundancy_blocks.unwrap_or(0)
    }
    pub fn clear_highest_prio_low_redundancy_blocks(&mut self) {
        self.highest_prio_low_redundancy_blocks = ::std::option::Option::None;
    }

    pub fn has_highest_prio_low_redundancy_blocks(&self) -> bool {
        self.highest_prio_low_redundancy_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_highest_prio_low_redundancy_blocks(&mut self, v: u64) {
        self.highest_prio_low_redundancy_blocks = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetFsReplicatedBlockStatsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.low_redundancy.is_none() {
            return false;
        }
        if self.corrupt_blocks.is_none() {
            return false;
        }
        if self.missing_blocks.is_none() {
            return false;
        }
        if self.missing_repl_one_blocks.is_none() {
            return false;
        }
        if self.blocks_in_future.is_none() {
            return false;
        }
        if self.pending_deletion_blocks.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.low_redundancy = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.corrupt_blocks = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.missing_blocks = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.missing_repl_one_blocks = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blocks_in_future = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.pending_deletion_blocks = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.highest_prio_low_redundancy_blocks = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.low_redundancy {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.corrupt_blocks {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.missing_blocks {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.missing_repl_one_blocks {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blocks_in_future {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pending_deletion_blocks {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.highest_prio_low_redundancy_blocks {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.low_redundancy {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.corrupt_blocks {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.missing_blocks {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.missing_repl_one_blocks {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.blocks_in_future {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.pending_deletion_blocks {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.highest_prio_low_redundancy_blocks {
            os.write_uint64(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFsReplicatedBlockStatsResponseProto {
        GetFsReplicatedBlockStatsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "low_redundancy",
                |m: &GetFsReplicatedBlockStatsResponseProto| { &m.low_redundancy },
                |m: &mut GetFsReplicatedBlockStatsResponseProto| { &mut m.low_redundancy },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "corrupt_blocks",
                |m: &GetFsReplicatedBlockStatsResponseProto| { &m.corrupt_blocks },
                |m: &mut GetFsReplicatedBlockStatsResponseProto| { &mut m.corrupt_blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "missing_blocks",
                |m: &GetFsReplicatedBlockStatsResponseProto| { &m.missing_blocks },
                |m: &mut GetFsReplicatedBlockStatsResponseProto| { &mut m.missing_blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "missing_repl_one_blocks",
                |m: &GetFsReplicatedBlockStatsResponseProto| { &m.missing_repl_one_blocks },
                |m: &mut GetFsReplicatedBlockStatsResponseProto| { &mut m.missing_repl_one_blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "blocks_in_future",
                |m: &GetFsReplicatedBlockStatsResponseProto| { &m.blocks_in_future },
                |m: &mut GetFsReplicatedBlockStatsResponseProto| { &mut m.blocks_in_future },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "pending_deletion_blocks",
                |m: &GetFsReplicatedBlockStatsResponseProto| { &m.pending_deletion_blocks },
                |m: &mut GetFsReplicatedBlockStatsResponseProto| { &mut m.pending_deletion_blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "highest_prio_low_redundancy_blocks",
                |m: &GetFsReplicatedBlockStatsResponseProto| { &m.highest_prio_low_redundancy_blocks },
                |m: &mut GetFsReplicatedBlockStatsResponseProto| { &mut m.highest_prio_low_redundancy_blocks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFsReplicatedBlockStatsResponseProto>(
                "GetFsReplicatedBlockStatsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFsReplicatedBlockStatsResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetFsReplicatedBlockStatsResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFsReplicatedBlockStatsResponseProto::new)
    }
}

impl ::protobuf::Clear for GetFsReplicatedBlockStatsResponseProto {
    fn clear(&mut self) {
        self.low_redundancy = ::std::option::Option::None;
        self.corrupt_blocks = ::std::option::Option::None;
        self.missing_blocks = ::std::option::Option::None;
        self.missing_repl_one_blocks = ::std::option::Option::None;
        self.blocks_in_future = ::std::option::Option::None;
        self.pending_deletion_blocks = ::std::option::Option::None;
        self.highest_prio_low_redundancy_blocks = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFsReplicatedBlockStatsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFsReplicatedBlockStatsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFsECBlockGroupStatsRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFsECBlockGroupStatsRequestProto {
    fn default() -> &'a GetFsECBlockGroupStatsRequestProto {
        <GetFsECBlockGroupStatsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetFsECBlockGroupStatsRequestProto {
    pub fn new() -> GetFsECBlockGroupStatsRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetFsECBlockGroupStatsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFsECBlockGroupStatsRequestProto {
        GetFsECBlockGroupStatsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFsECBlockGroupStatsRequestProto>(
                "GetFsECBlockGroupStatsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFsECBlockGroupStatsRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetFsECBlockGroupStatsRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFsECBlockGroupStatsRequestProto::new)
    }
}

impl ::protobuf::Clear for GetFsECBlockGroupStatsRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFsECBlockGroupStatsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFsECBlockGroupStatsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFsECBlockGroupStatsResponseProto {
    // message fields
    low_redundancy: ::std::option::Option<u64>,
    corrupt_blocks: ::std::option::Option<u64>,
    missing_blocks: ::std::option::Option<u64>,
    blocks_in_future: ::std::option::Option<u64>,
    pending_deletion_blocks: ::std::option::Option<u64>,
    highest_prio_low_redundancy_blocks: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFsECBlockGroupStatsResponseProto {
    fn default() -> &'a GetFsECBlockGroupStatsResponseProto {
        <GetFsECBlockGroupStatsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetFsECBlockGroupStatsResponseProto {
    pub fn new() -> GetFsECBlockGroupStatsResponseProto {
        ::std::default::Default::default()
    }

    // required uint64 low_redundancy = 1;


    pub fn get_low_redundancy(&self) -> u64 {
        self.low_redundancy.unwrap_or(0)
    }
    pub fn clear_low_redundancy(&mut self) {
        self.low_redundancy = ::std::option::Option::None;
    }

    pub fn has_low_redundancy(&self) -> bool {
        self.low_redundancy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_redundancy(&mut self, v: u64) {
        self.low_redundancy = ::std::option::Option::Some(v);
    }

    // required uint64 corrupt_blocks = 2;


    pub fn get_corrupt_blocks(&self) -> u64 {
        self.corrupt_blocks.unwrap_or(0)
    }
    pub fn clear_corrupt_blocks(&mut self) {
        self.corrupt_blocks = ::std::option::Option::None;
    }

    pub fn has_corrupt_blocks(&self) -> bool {
        self.corrupt_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_corrupt_blocks(&mut self, v: u64) {
        self.corrupt_blocks = ::std::option::Option::Some(v);
    }

    // required uint64 missing_blocks = 3;


    pub fn get_missing_blocks(&self) -> u64 {
        self.missing_blocks.unwrap_or(0)
    }
    pub fn clear_missing_blocks(&mut self) {
        self.missing_blocks = ::std::option::Option::None;
    }

    pub fn has_missing_blocks(&self) -> bool {
        self.missing_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missing_blocks(&mut self, v: u64) {
        self.missing_blocks = ::std::option::Option::Some(v);
    }

    // required uint64 blocks_in_future = 4;


    pub fn get_blocks_in_future(&self) -> u64 {
        self.blocks_in_future.unwrap_or(0)
    }
    pub fn clear_blocks_in_future(&mut self) {
        self.blocks_in_future = ::std::option::Option::None;
    }

    pub fn has_blocks_in_future(&self) -> bool {
        self.blocks_in_future.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blocks_in_future(&mut self, v: u64) {
        self.blocks_in_future = ::std::option::Option::Some(v);
    }

    // required uint64 pending_deletion_blocks = 5;


    pub fn get_pending_deletion_blocks(&self) -> u64 {
        self.pending_deletion_blocks.unwrap_or(0)
    }
    pub fn clear_pending_deletion_blocks(&mut self) {
        self.pending_deletion_blocks = ::std::option::Option::None;
    }

    pub fn has_pending_deletion_blocks(&self) -> bool {
        self.pending_deletion_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pending_deletion_blocks(&mut self, v: u64) {
        self.pending_deletion_blocks = ::std::option::Option::Some(v);
    }

    // optional uint64 highest_prio_low_redundancy_blocks = 6;


    pub fn get_highest_prio_low_redundancy_blocks(&self) -> u64 {
        self.highest_prio_low_redundancy_blocks.unwrap_or(0)
    }
    pub fn clear_highest_prio_low_redundancy_blocks(&mut self) {
        self.highest_prio_low_redundancy_blocks = ::std::option::Option::None;
    }

    pub fn has_highest_prio_low_redundancy_blocks(&self) -> bool {
        self.highest_prio_low_redundancy_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_highest_prio_low_redundancy_blocks(&mut self, v: u64) {
        self.highest_prio_low_redundancy_blocks = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetFsECBlockGroupStatsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.low_redundancy.is_none() {
            return false;
        }
        if self.corrupt_blocks.is_none() {
            return false;
        }
        if self.missing_blocks.is_none() {
            return false;
        }
        if self.blocks_in_future.is_none() {
            return false;
        }
        if self.pending_deletion_blocks.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.low_redundancy = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.corrupt_blocks = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.missing_blocks = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blocks_in_future = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.pending_deletion_blocks = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.highest_prio_low_redundancy_blocks = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.low_redundancy {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.corrupt_blocks {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.missing_blocks {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blocks_in_future {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pending_deletion_blocks {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.highest_prio_low_redundancy_blocks {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.low_redundancy {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.corrupt_blocks {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.missing_blocks {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.blocks_in_future {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.pending_deletion_blocks {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.highest_prio_low_redundancy_blocks {
            os.write_uint64(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFsECBlockGroupStatsResponseProto {
        GetFsECBlockGroupStatsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "low_redundancy",
                |m: &GetFsECBlockGroupStatsResponseProto| { &m.low_redundancy },
                |m: &mut GetFsECBlockGroupStatsResponseProto| { &mut m.low_redundancy },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "corrupt_blocks",
                |m: &GetFsECBlockGroupStatsResponseProto| { &m.corrupt_blocks },
                |m: &mut GetFsECBlockGroupStatsResponseProto| { &mut m.corrupt_blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "missing_blocks",
                |m: &GetFsECBlockGroupStatsResponseProto| { &m.missing_blocks },
                |m: &mut GetFsECBlockGroupStatsResponseProto| { &mut m.missing_blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "blocks_in_future",
                |m: &GetFsECBlockGroupStatsResponseProto| { &m.blocks_in_future },
                |m: &mut GetFsECBlockGroupStatsResponseProto| { &mut m.blocks_in_future },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "pending_deletion_blocks",
                |m: &GetFsECBlockGroupStatsResponseProto| { &m.pending_deletion_blocks },
                |m: &mut GetFsECBlockGroupStatsResponseProto| { &mut m.pending_deletion_blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "highest_prio_low_redundancy_blocks",
                |m: &GetFsECBlockGroupStatsResponseProto| { &m.highest_prio_low_redundancy_blocks },
                |m: &mut GetFsECBlockGroupStatsResponseProto| { &mut m.highest_prio_low_redundancy_blocks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFsECBlockGroupStatsResponseProto>(
                "GetFsECBlockGroupStatsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFsECBlockGroupStatsResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetFsECBlockGroupStatsResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFsECBlockGroupStatsResponseProto::new)
    }
}

impl ::protobuf::Clear for GetFsECBlockGroupStatsResponseProto {
    fn clear(&mut self) {
        self.low_redundancy = ::std::option::Option::None;
        self.corrupt_blocks = ::std::option::Option::None;
        self.missing_blocks = ::std::option::Option::None;
        self.blocks_in_future = ::std::option::Option::None;
        self.pending_deletion_blocks = ::std::option::Option::None;
        self.highest_prio_low_redundancy_blocks = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFsECBlockGroupStatsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFsECBlockGroupStatsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatanodeReportRequestProto {
    // message fields
    field_type: ::std::option::Option<DatanodeReportTypeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDatanodeReportRequestProto {
    fn default() -> &'a GetDatanodeReportRequestProto {
        <GetDatanodeReportRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetDatanodeReportRequestProto {
    pub fn new() -> GetDatanodeReportRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.DatanodeReportTypeProto type = 1;


    pub fn get_field_type(&self) -> DatanodeReportTypeProto {
        self.field_type.unwrap_or(DatanodeReportTypeProto::ALL)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DatanodeReportTypeProto) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetDatanodeReportRequestProto {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDatanodeReportRequestProto {
        GetDatanodeReportRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DatanodeReportTypeProto>>(
                "type",
                |m: &GetDatanodeReportRequestProto| { &m.field_type },
                |m: &mut GetDatanodeReportRequestProto| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDatanodeReportRequestProto>(
                "GetDatanodeReportRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetDatanodeReportRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetDatanodeReportRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetDatanodeReportRequestProto::new)
    }
}

impl ::protobuf::Clear for GetDatanodeReportRequestProto {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatanodeReportRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatanodeReportRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatanodeReportResponseProto {
    // message fields
    pub di: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDatanodeReportResponseProto {
    fn default() -> &'a GetDatanodeReportResponseProto {
        <GetDatanodeReportResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetDatanodeReportResponseProto {
    pub fn new() -> GetDatanodeReportResponseProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto di = 1;


    pub fn get_di(&self) -> &[super::hdfs::DatanodeInfoProto] {
        &self.di
    }
    pub fn clear_di(&mut self) {
        self.di.clear();
    }

    // Param is passed by value, moved
    pub fn set_di(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>) {
        self.di = v;
    }

    // Mutable pointer to the field.
    pub fn mut_di(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.di
    }

    // Take field
    pub fn take_di(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        ::std::mem::replace(&mut self.di, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetDatanodeReportResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.di {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.di)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.di {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.di {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDatanodeReportResponseProto {
        GetDatanodeReportResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                "di",
                |m: &GetDatanodeReportResponseProto| { &m.di },
                |m: &mut GetDatanodeReportResponseProto| { &mut m.di },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDatanodeReportResponseProto>(
                "GetDatanodeReportResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetDatanodeReportResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetDatanodeReportResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetDatanodeReportResponseProto::new)
    }
}

impl ::protobuf::Clear for GetDatanodeReportResponseProto {
    fn clear(&mut self) {
        self.di.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatanodeReportResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatanodeReportResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatanodeStorageReportRequestProto {
    // message fields
    field_type: ::std::option::Option<DatanodeReportTypeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDatanodeStorageReportRequestProto {
    fn default() -> &'a GetDatanodeStorageReportRequestProto {
        <GetDatanodeStorageReportRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetDatanodeStorageReportRequestProto {
    pub fn new() -> GetDatanodeStorageReportRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.DatanodeReportTypeProto type = 1;


    pub fn get_field_type(&self) -> DatanodeReportTypeProto {
        self.field_type.unwrap_or(DatanodeReportTypeProto::ALL)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DatanodeReportTypeProto) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetDatanodeStorageReportRequestProto {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDatanodeStorageReportRequestProto {
        GetDatanodeStorageReportRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DatanodeReportTypeProto>>(
                "type",
                |m: &GetDatanodeStorageReportRequestProto| { &m.field_type },
                |m: &mut GetDatanodeStorageReportRequestProto| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDatanodeStorageReportRequestProto>(
                "GetDatanodeStorageReportRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetDatanodeStorageReportRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetDatanodeStorageReportRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetDatanodeStorageReportRequestProto::new)
    }
}

impl ::protobuf::Clear for GetDatanodeStorageReportRequestProto {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatanodeStorageReportRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatanodeStorageReportRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatanodeStorageReportProto {
    // message fields
    pub datanodeInfo: ::protobuf::SingularPtrField<super::hdfs::DatanodeInfoProto>,
    pub storageReports: ::protobuf::RepeatedField<super::hdfs::StorageReportProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatanodeStorageReportProto {
    fn default() -> &'a DatanodeStorageReportProto {
        <DatanodeStorageReportProto as ::protobuf::Message>::default_instance()
    }
}

impl DatanodeStorageReportProto {
    pub fn new() -> DatanodeStorageReportProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.DatanodeInfoProto datanodeInfo = 1;


    pub fn get_datanodeInfo(&self) -> &super::hdfs::DatanodeInfoProto {
        self.datanodeInfo.as_ref().unwrap_or_else(|| <super::hdfs::DatanodeInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_datanodeInfo(&mut self) {
        self.datanodeInfo.clear();
    }

    pub fn has_datanodeInfo(&self) -> bool {
        self.datanodeInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datanodeInfo(&mut self, v: super::hdfs::DatanodeInfoProto) {
        self.datanodeInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_datanodeInfo(&mut self) -> &mut super::hdfs::DatanodeInfoProto {
        if self.datanodeInfo.is_none() {
            self.datanodeInfo.set_default();
        }
        self.datanodeInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_datanodeInfo(&mut self) -> super::hdfs::DatanodeInfoProto {
        self.datanodeInfo.take().unwrap_or_else(|| super::hdfs::DatanodeInfoProto::new())
    }

    // repeated .hadoop.hdfs.StorageReportProto storageReports = 2;


    pub fn get_storageReports(&self) -> &[super::hdfs::StorageReportProto] {
        &self.storageReports
    }
    pub fn clear_storageReports(&mut self) {
        self.storageReports.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageReports(&mut self, v: ::protobuf::RepeatedField<super::hdfs::StorageReportProto>) {
        self.storageReports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageReports(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::StorageReportProto> {
        &mut self.storageReports
    }

    // Take field
    pub fn take_storageReports(&mut self) -> ::protobuf::RepeatedField<super::hdfs::StorageReportProto> {
        ::std::mem::replace(&mut self.storageReports, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DatanodeStorageReportProto {
    fn is_initialized(&self) -> bool {
        if self.datanodeInfo.is_none() {
            return false;
        }
        for v in &self.datanodeInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.storageReports {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.datanodeInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.storageReports)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.datanodeInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.storageReports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.datanodeInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.storageReports {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatanodeStorageReportProto {
        DatanodeStorageReportProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                "datanodeInfo",
                |m: &DatanodeStorageReportProto| { &m.datanodeInfo },
                |m: &mut DatanodeStorageReportProto| { &mut m.datanodeInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::StorageReportProto>>(
                "storageReports",
                |m: &DatanodeStorageReportProto| { &m.storageReports },
                |m: &mut DatanodeStorageReportProto| { &mut m.storageReports },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DatanodeStorageReportProto>(
                "DatanodeStorageReportProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DatanodeStorageReportProto {
        static instance: ::protobuf::rt::LazyV2<DatanodeStorageReportProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DatanodeStorageReportProto::new)
    }
}

impl ::protobuf::Clear for DatanodeStorageReportProto {
    fn clear(&mut self) {
        self.datanodeInfo.clear();
        self.storageReports.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatanodeStorageReportProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeStorageReportProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatanodeStorageReportResponseProto {
    // message fields
    pub datanodeStorageReports: ::protobuf::RepeatedField<DatanodeStorageReportProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDatanodeStorageReportResponseProto {
    fn default() -> &'a GetDatanodeStorageReportResponseProto {
        <GetDatanodeStorageReportResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetDatanodeStorageReportResponseProto {
    pub fn new() -> GetDatanodeStorageReportResponseProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.DatanodeStorageReportProto datanodeStorageReports = 1;


    pub fn get_datanodeStorageReports(&self) -> &[DatanodeStorageReportProto] {
        &self.datanodeStorageReports
    }
    pub fn clear_datanodeStorageReports(&mut self) {
        self.datanodeStorageReports.clear();
    }

    // Param is passed by value, moved
    pub fn set_datanodeStorageReports(&mut self, v: ::protobuf::RepeatedField<DatanodeStorageReportProto>) {
        self.datanodeStorageReports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_datanodeStorageReports(&mut self) -> &mut ::protobuf::RepeatedField<DatanodeStorageReportProto> {
        &mut self.datanodeStorageReports
    }

    // Take field
    pub fn take_datanodeStorageReports(&mut self) -> ::protobuf::RepeatedField<DatanodeStorageReportProto> {
        ::std::mem::replace(&mut self.datanodeStorageReports, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetDatanodeStorageReportResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.datanodeStorageReports {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.datanodeStorageReports)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.datanodeStorageReports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.datanodeStorageReports {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDatanodeStorageReportResponseProto {
        GetDatanodeStorageReportResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeStorageReportProto>>(
                "datanodeStorageReports",
                |m: &GetDatanodeStorageReportResponseProto| { &m.datanodeStorageReports },
                |m: &mut GetDatanodeStorageReportResponseProto| { &mut m.datanodeStorageReports },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDatanodeStorageReportResponseProto>(
                "GetDatanodeStorageReportResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetDatanodeStorageReportResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetDatanodeStorageReportResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetDatanodeStorageReportResponseProto::new)
    }
}

impl ::protobuf::Clear for GetDatanodeStorageReportResponseProto {
    fn clear(&mut self) {
        self.datanodeStorageReports.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatanodeStorageReportResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatanodeStorageReportResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPreferredBlockSizeRequestProto {
    // message fields
    filename: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPreferredBlockSizeRequestProto {
    fn default() -> &'a GetPreferredBlockSizeRequestProto {
        <GetPreferredBlockSizeRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetPreferredBlockSizeRequestProto {
    pub fn new() -> GetPreferredBlockSizeRequestProto {
        ::std::default::Default::default()
    }

    // required string filename = 1;


    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetPreferredBlockSizeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.filename.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPreferredBlockSizeRequestProto {
        GetPreferredBlockSizeRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filename",
                |m: &GetPreferredBlockSizeRequestProto| { &m.filename },
                |m: &mut GetPreferredBlockSizeRequestProto| { &mut m.filename },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetPreferredBlockSizeRequestProto>(
                "GetPreferredBlockSizeRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetPreferredBlockSizeRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetPreferredBlockSizeRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetPreferredBlockSizeRequestProto::new)
    }
}

impl ::protobuf::Clear for GetPreferredBlockSizeRequestProto {
    fn clear(&mut self) {
        self.filename.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPreferredBlockSizeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPreferredBlockSizeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPreferredBlockSizeResponseProto {
    // message fields
    bsize: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPreferredBlockSizeResponseProto {
    fn default() -> &'a GetPreferredBlockSizeResponseProto {
        <GetPreferredBlockSizeResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetPreferredBlockSizeResponseProto {
    pub fn new() -> GetPreferredBlockSizeResponseProto {
        ::std::default::Default::default()
    }

    // required uint64 bsize = 1;


    pub fn get_bsize(&self) -> u64 {
        self.bsize.unwrap_or(0)
    }
    pub fn clear_bsize(&mut self) {
        self.bsize = ::std::option::Option::None;
    }

    pub fn has_bsize(&self) -> bool {
        self.bsize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bsize(&mut self, v: u64) {
        self.bsize = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetPreferredBlockSizeResponseProto {
    fn is_initialized(&self) -> bool {
        if self.bsize.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bsize = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bsize {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bsize {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPreferredBlockSizeResponseProto {
        GetPreferredBlockSizeResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "bsize",
                |m: &GetPreferredBlockSizeResponseProto| { &m.bsize },
                |m: &mut GetPreferredBlockSizeResponseProto| { &mut m.bsize },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetPreferredBlockSizeResponseProto>(
                "GetPreferredBlockSizeResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetPreferredBlockSizeResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetPreferredBlockSizeResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetPreferredBlockSizeResponseProto::new)
    }
}

impl ::protobuf::Clear for GetPreferredBlockSizeResponseProto {
    fn clear(&mut self) {
        self.bsize = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPreferredBlockSizeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPreferredBlockSizeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetSafeModeRequestProto {
    // message fields
    action: ::std::option::Option<SafeModeActionProto>,
    checked: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetSafeModeRequestProto {
    fn default() -> &'a SetSafeModeRequestProto {
        <SetSafeModeRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl SetSafeModeRequestProto {
    pub fn new() -> SetSafeModeRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.SafeModeActionProto action = 1;


    pub fn get_action(&self) -> SafeModeActionProto {
        self.action.unwrap_or(SafeModeActionProto::SAFEMODE_LEAVE)
    }
    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: SafeModeActionProto) {
        self.action = ::std::option::Option::Some(v);
    }

    // optional bool checked = 2;


    pub fn get_checked(&self) -> bool {
        self.checked.unwrap_or(false)
    }
    pub fn clear_checked(&mut self) {
        self.checked = ::std::option::Option::None;
    }

    pub fn has_checked(&self) -> bool {
        self.checked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checked(&mut self, v: bool) {
        self.checked = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SetSafeModeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.action.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checked = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.checked {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.checked {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetSafeModeRequestProto {
        SetSafeModeRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SafeModeActionProto>>(
                "action",
                |m: &SetSafeModeRequestProto| { &m.action },
                |m: &mut SetSafeModeRequestProto| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "checked",
                |m: &SetSafeModeRequestProto| { &m.checked },
                |m: &mut SetSafeModeRequestProto| { &mut m.checked },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetSafeModeRequestProto>(
                "SetSafeModeRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetSafeModeRequestProto {
        static instance: ::protobuf::rt::LazyV2<SetSafeModeRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetSafeModeRequestProto::new)
    }
}

impl ::protobuf::Clear for SetSafeModeRequestProto {
    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.checked = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetSafeModeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetSafeModeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetSafeModeResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetSafeModeResponseProto {
    fn default() -> &'a SetSafeModeResponseProto {
        <SetSafeModeResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl SetSafeModeResponseProto {
    pub fn new() -> SetSafeModeResponseProto {
        ::std::default::Default::default()
    }

    // required bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SetSafeModeResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetSafeModeResponseProto {
        SetSafeModeResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "result",
                |m: &SetSafeModeResponseProto| { &m.result },
                |m: &mut SetSafeModeResponseProto| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetSafeModeResponseProto>(
                "SetSafeModeResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetSafeModeResponseProto {
        static instance: ::protobuf::rt::LazyV2<SetSafeModeResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetSafeModeResponseProto::new)
    }
}

impl ::protobuf::Clear for SetSafeModeResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetSafeModeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetSafeModeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SaveNamespaceRequestProto {
    // message fields
    timeWindow: ::std::option::Option<u64>,
    txGap: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SaveNamespaceRequestProto {
    fn default() -> &'a SaveNamespaceRequestProto {
        <SaveNamespaceRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl SaveNamespaceRequestProto {
    pub fn new() -> SaveNamespaceRequestProto {
        ::std::default::Default::default()
    }

    // optional uint64 timeWindow = 1;


    pub fn get_timeWindow(&self) -> u64 {
        self.timeWindow.unwrap_or(0u64)
    }
    pub fn clear_timeWindow(&mut self) {
        self.timeWindow = ::std::option::Option::None;
    }

    pub fn has_timeWindow(&self) -> bool {
        self.timeWindow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeWindow(&mut self, v: u64) {
        self.timeWindow = ::std::option::Option::Some(v);
    }

    // optional uint64 txGap = 2;


    pub fn get_txGap(&self) -> u64 {
        self.txGap.unwrap_or(0u64)
    }
    pub fn clear_txGap(&mut self) {
        self.txGap = ::std::option::Option::None;
    }

    pub fn has_txGap(&self) -> bool {
        self.txGap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txGap(&mut self, v: u64) {
        self.txGap = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SaveNamespaceRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timeWindow = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txGap = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timeWindow {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txGap {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timeWindow {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.txGap {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SaveNamespaceRequestProto {
        SaveNamespaceRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timeWindow",
                |m: &SaveNamespaceRequestProto| { &m.timeWindow },
                |m: &mut SaveNamespaceRequestProto| { &mut m.timeWindow },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "txGap",
                |m: &SaveNamespaceRequestProto| { &m.txGap },
                |m: &mut SaveNamespaceRequestProto| { &mut m.txGap },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SaveNamespaceRequestProto>(
                "SaveNamespaceRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SaveNamespaceRequestProto {
        static instance: ::protobuf::rt::LazyV2<SaveNamespaceRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SaveNamespaceRequestProto::new)
    }
}

impl ::protobuf::Clear for SaveNamespaceRequestProto {
    fn clear(&mut self) {
        self.timeWindow = ::std::option::Option::None;
        self.txGap = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SaveNamespaceRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SaveNamespaceRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SaveNamespaceResponseProto {
    // message fields
    saved: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SaveNamespaceResponseProto {
    fn default() -> &'a SaveNamespaceResponseProto {
        <SaveNamespaceResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl SaveNamespaceResponseProto {
    pub fn new() -> SaveNamespaceResponseProto {
        ::std::default::Default::default()
    }

    // optional bool saved = 1;


    pub fn get_saved(&self) -> bool {
        self.saved.unwrap_or(true)
    }
    pub fn clear_saved(&mut self) {
        self.saved = ::std::option::Option::None;
    }

    pub fn has_saved(&self) -> bool {
        self.saved.is_some()
    }

    // Param is passed by value, moved
    pub fn set_saved(&mut self, v: bool) {
        self.saved = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SaveNamespaceResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.saved = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.saved {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.saved {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SaveNamespaceResponseProto {
        SaveNamespaceResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "saved",
                |m: &SaveNamespaceResponseProto| { &m.saved },
                |m: &mut SaveNamespaceResponseProto| { &mut m.saved },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SaveNamespaceResponseProto>(
                "SaveNamespaceResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SaveNamespaceResponseProto {
        static instance: ::protobuf::rt::LazyV2<SaveNamespaceResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SaveNamespaceResponseProto::new)
    }
}

impl ::protobuf::Clear for SaveNamespaceResponseProto {
    fn clear(&mut self) {
        self.saved = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SaveNamespaceResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SaveNamespaceResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollEditsRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RollEditsRequestProto {
    fn default() -> &'a RollEditsRequestProto {
        <RollEditsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RollEditsRequestProto {
    pub fn new() -> RollEditsRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RollEditsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RollEditsRequestProto {
        RollEditsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RollEditsRequestProto>(
                "RollEditsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RollEditsRequestProto {
        static instance: ::protobuf::rt::LazyV2<RollEditsRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RollEditsRequestProto::new)
    }
}

impl ::protobuf::Clear for RollEditsRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollEditsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollEditsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollEditsResponseProto {
    // message fields
    newSegmentTxId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RollEditsResponseProto {
    fn default() -> &'a RollEditsResponseProto {
        <RollEditsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RollEditsResponseProto {
    pub fn new() -> RollEditsResponseProto {
        ::std::default::Default::default()
    }

    // required uint64 newSegmentTxId = 1;


    pub fn get_newSegmentTxId(&self) -> u64 {
        self.newSegmentTxId.unwrap_or(0)
    }
    pub fn clear_newSegmentTxId(&mut self) {
        self.newSegmentTxId = ::std::option::Option::None;
    }

    pub fn has_newSegmentTxId(&self) -> bool {
        self.newSegmentTxId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newSegmentTxId(&mut self, v: u64) {
        self.newSegmentTxId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RollEditsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.newSegmentTxId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.newSegmentTxId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.newSegmentTxId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.newSegmentTxId {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RollEditsResponseProto {
        RollEditsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "newSegmentTxId",
                |m: &RollEditsResponseProto| { &m.newSegmentTxId },
                |m: &mut RollEditsResponseProto| { &mut m.newSegmentTxId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RollEditsResponseProto>(
                "RollEditsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RollEditsResponseProto {
        static instance: ::protobuf::rt::LazyV2<RollEditsResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RollEditsResponseProto::new)
    }
}

impl ::protobuf::Clear for RollEditsResponseProto {
    fn clear(&mut self) {
        self.newSegmentTxId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollEditsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollEditsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RestoreFailedStorageRequestProto {
    // message fields
    arg: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RestoreFailedStorageRequestProto {
    fn default() -> &'a RestoreFailedStorageRequestProto {
        <RestoreFailedStorageRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RestoreFailedStorageRequestProto {
    pub fn new() -> RestoreFailedStorageRequestProto {
        ::std::default::Default::default()
    }

    // required string arg = 1;


    pub fn get_arg(&self) -> &str {
        match self.arg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_arg(&mut self) {
        self.arg.clear();
    }

    pub fn has_arg(&self) -> bool {
        self.arg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arg(&mut self, v: ::std::string::String) {
        self.arg = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arg(&mut self) -> &mut ::std::string::String {
        if self.arg.is_none() {
            self.arg.set_default();
        }
        self.arg.as_mut().unwrap()
    }

    // Take field
    pub fn take_arg(&mut self) -> ::std::string::String {
        self.arg.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for RestoreFailedStorageRequestProto {
    fn is_initialized(&self) -> bool {
        if self.arg.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.arg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.arg.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.arg.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestoreFailedStorageRequestProto {
        RestoreFailedStorageRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "arg",
                |m: &RestoreFailedStorageRequestProto| { &m.arg },
                |m: &mut RestoreFailedStorageRequestProto| { &mut m.arg },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RestoreFailedStorageRequestProto>(
                "RestoreFailedStorageRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RestoreFailedStorageRequestProto {
        static instance: ::protobuf::rt::LazyV2<RestoreFailedStorageRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RestoreFailedStorageRequestProto::new)
    }
}

impl ::protobuf::Clear for RestoreFailedStorageRequestProto {
    fn clear(&mut self) {
        self.arg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreFailedStorageRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreFailedStorageRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RestoreFailedStorageResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RestoreFailedStorageResponseProto {
    fn default() -> &'a RestoreFailedStorageResponseProto {
        <RestoreFailedStorageResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RestoreFailedStorageResponseProto {
    pub fn new() -> RestoreFailedStorageResponseProto {
        ::std::default::Default::default()
    }

    // required bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RestoreFailedStorageResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestoreFailedStorageResponseProto {
        RestoreFailedStorageResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "result",
                |m: &RestoreFailedStorageResponseProto| { &m.result },
                |m: &mut RestoreFailedStorageResponseProto| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RestoreFailedStorageResponseProto>(
                "RestoreFailedStorageResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RestoreFailedStorageResponseProto {
        static instance: ::protobuf::rt::LazyV2<RestoreFailedStorageResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RestoreFailedStorageResponseProto::new)
    }
}

impl ::protobuf::Clear for RestoreFailedStorageResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreFailedStorageResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreFailedStorageResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RefreshNodesRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RefreshNodesRequestProto {
    fn default() -> &'a RefreshNodesRequestProto {
        <RefreshNodesRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RefreshNodesRequestProto {
    pub fn new() -> RefreshNodesRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RefreshNodesRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RefreshNodesRequestProto {
        RefreshNodesRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RefreshNodesRequestProto>(
                "RefreshNodesRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RefreshNodesRequestProto {
        static instance: ::protobuf::rt::LazyV2<RefreshNodesRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RefreshNodesRequestProto::new)
    }
}

impl ::protobuf::Clear for RefreshNodesRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RefreshNodesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefreshNodesRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RefreshNodesResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RefreshNodesResponseProto {
    fn default() -> &'a RefreshNodesResponseProto {
        <RefreshNodesResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RefreshNodesResponseProto {
    pub fn new() -> RefreshNodesResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RefreshNodesResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RefreshNodesResponseProto {
        RefreshNodesResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RefreshNodesResponseProto>(
                "RefreshNodesResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RefreshNodesResponseProto {
        static instance: ::protobuf::rt::LazyV2<RefreshNodesResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RefreshNodesResponseProto::new)
    }
}

impl ::protobuf::Clear for RefreshNodesResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RefreshNodesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefreshNodesResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FinalizeUpgradeRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FinalizeUpgradeRequestProto {
    fn default() -> &'a FinalizeUpgradeRequestProto {
        <FinalizeUpgradeRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl FinalizeUpgradeRequestProto {
    pub fn new() -> FinalizeUpgradeRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FinalizeUpgradeRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FinalizeUpgradeRequestProto {
        FinalizeUpgradeRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FinalizeUpgradeRequestProto>(
                "FinalizeUpgradeRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FinalizeUpgradeRequestProto {
        static instance: ::protobuf::rt::LazyV2<FinalizeUpgradeRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FinalizeUpgradeRequestProto::new)
    }
}

impl ::protobuf::Clear for FinalizeUpgradeRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FinalizeUpgradeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinalizeUpgradeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FinalizeUpgradeResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FinalizeUpgradeResponseProto {
    fn default() -> &'a FinalizeUpgradeResponseProto {
        <FinalizeUpgradeResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl FinalizeUpgradeResponseProto {
    pub fn new() -> FinalizeUpgradeResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FinalizeUpgradeResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FinalizeUpgradeResponseProto {
        FinalizeUpgradeResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FinalizeUpgradeResponseProto>(
                "FinalizeUpgradeResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FinalizeUpgradeResponseProto {
        static instance: ::protobuf::rt::LazyV2<FinalizeUpgradeResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FinalizeUpgradeResponseProto::new)
    }
}

impl ::protobuf::Clear for FinalizeUpgradeResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FinalizeUpgradeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinalizeUpgradeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpgradeStatusRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpgradeStatusRequestProto {
    fn default() -> &'a UpgradeStatusRequestProto {
        <UpgradeStatusRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl UpgradeStatusRequestProto {
    pub fn new() -> UpgradeStatusRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpgradeStatusRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpgradeStatusRequestProto {
        UpgradeStatusRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpgradeStatusRequestProto>(
                "UpgradeStatusRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpgradeStatusRequestProto {
        static instance: ::protobuf::rt::LazyV2<UpgradeStatusRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpgradeStatusRequestProto::new)
    }
}

impl ::protobuf::Clear for UpgradeStatusRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpgradeStatusRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpgradeStatusRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpgradeStatusResponseProto {
    // message fields
    upgradeFinalized: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpgradeStatusResponseProto {
    fn default() -> &'a UpgradeStatusResponseProto {
        <UpgradeStatusResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl UpgradeStatusResponseProto {
    pub fn new() -> UpgradeStatusResponseProto {
        ::std::default::Default::default()
    }

    // required bool upgradeFinalized = 1;


    pub fn get_upgradeFinalized(&self) -> bool {
        self.upgradeFinalized.unwrap_or(false)
    }
    pub fn clear_upgradeFinalized(&mut self) {
        self.upgradeFinalized = ::std::option::Option::None;
    }

    pub fn has_upgradeFinalized(&self) -> bool {
        self.upgradeFinalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upgradeFinalized(&mut self, v: bool) {
        self.upgradeFinalized = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for UpgradeStatusResponseProto {
    fn is_initialized(&self) -> bool {
        if self.upgradeFinalized.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.upgradeFinalized = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.upgradeFinalized {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.upgradeFinalized {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpgradeStatusResponseProto {
        UpgradeStatusResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "upgradeFinalized",
                |m: &UpgradeStatusResponseProto| { &m.upgradeFinalized },
                |m: &mut UpgradeStatusResponseProto| { &mut m.upgradeFinalized },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpgradeStatusResponseProto>(
                "UpgradeStatusResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpgradeStatusResponseProto {
        static instance: ::protobuf::rt::LazyV2<UpgradeStatusResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpgradeStatusResponseProto::new)
    }
}

impl ::protobuf::Clear for UpgradeStatusResponseProto {
    fn clear(&mut self) {
        self.upgradeFinalized = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpgradeStatusResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpgradeStatusResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollingUpgradeRequestProto {
    // message fields
    action: ::std::option::Option<RollingUpgradeActionProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RollingUpgradeRequestProto {
    fn default() -> &'a RollingUpgradeRequestProto {
        <RollingUpgradeRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RollingUpgradeRequestProto {
    pub fn new() -> RollingUpgradeRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.RollingUpgradeActionProto action = 1;


    pub fn get_action(&self) -> RollingUpgradeActionProto {
        self.action.unwrap_or(RollingUpgradeActionProto::QUERY)
    }
    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: RollingUpgradeActionProto) {
        self.action = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RollingUpgradeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.action.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RollingUpgradeRequestProto {
        RollingUpgradeRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RollingUpgradeActionProto>>(
                "action",
                |m: &RollingUpgradeRequestProto| { &m.action },
                |m: &mut RollingUpgradeRequestProto| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RollingUpgradeRequestProto>(
                "RollingUpgradeRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RollingUpgradeRequestProto {
        static instance: ::protobuf::rt::LazyV2<RollingUpgradeRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RollingUpgradeRequestProto::new)
    }
}

impl ::protobuf::Clear for RollingUpgradeRequestProto {
    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollingUpgradeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpgradeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollingUpgradeInfoProto {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::hdfs::RollingUpgradeStatusProto>,
    startTime: ::std::option::Option<u64>,
    finalizeTime: ::std::option::Option<u64>,
    createdRollbackImages: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RollingUpgradeInfoProto {
    fn default() -> &'a RollingUpgradeInfoProto {
        <RollingUpgradeInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl RollingUpgradeInfoProto {
    pub fn new() -> RollingUpgradeInfoProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.RollingUpgradeStatusProto status = 1;


    pub fn get_status(&self) -> &super::hdfs::RollingUpgradeStatusProto {
        self.status.as_ref().unwrap_or_else(|| <super::hdfs::RollingUpgradeStatusProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::hdfs::RollingUpgradeStatusProto) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::hdfs::RollingUpgradeStatusProto {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::hdfs::RollingUpgradeStatusProto {
        self.status.take().unwrap_or_else(|| super::hdfs::RollingUpgradeStatusProto::new())
    }

    // required uint64 startTime = 2;


    pub fn get_startTime(&self) -> u64 {
        self.startTime.unwrap_or(0)
    }
    pub fn clear_startTime(&mut self) {
        self.startTime = ::std::option::Option::None;
    }

    pub fn has_startTime(&self) -> bool {
        self.startTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTime(&mut self, v: u64) {
        self.startTime = ::std::option::Option::Some(v);
    }

    // required uint64 finalizeTime = 3;


    pub fn get_finalizeTime(&self) -> u64 {
        self.finalizeTime.unwrap_or(0)
    }
    pub fn clear_finalizeTime(&mut self) {
        self.finalizeTime = ::std::option::Option::None;
    }

    pub fn has_finalizeTime(&self) -> bool {
        self.finalizeTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_finalizeTime(&mut self, v: u64) {
        self.finalizeTime = ::std::option::Option::Some(v);
    }

    // required bool createdRollbackImages = 4;


    pub fn get_createdRollbackImages(&self) -> bool {
        self.createdRollbackImages.unwrap_or(false)
    }
    pub fn clear_createdRollbackImages(&mut self) {
        self.createdRollbackImages = ::std::option::Option::None;
    }

    pub fn has_createdRollbackImages(&self) -> bool {
        self.createdRollbackImages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createdRollbackImages(&mut self, v: bool) {
        self.createdRollbackImages = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RollingUpgradeInfoProto {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        if self.startTime.is_none() {
            return false;
        }
        if self.finalizeTime.is_none() {
            return false;
        }
        if self.createdRollbackImages.is_none() {
            return false;
        }
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.startTime = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.finalizeTime = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.createdRollbackImages = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.startTime {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.finalizeTime {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.createdRollbackImages {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.startTime {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.finalizeTime {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.createdRollbackImages {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RollingUpgradeInfoProto {
        RollingUpgradeInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::RollingUpgradeStatusProto>>(
                "status",
                |m: &RollingUpgradeInfoProto| { &m.status },
                |m: &mut RollingUpgradeInfoProto| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "startTime",
                |m: &RollingUpgradeInfoProto| { &m.startTime },
                |m: &mut RollingUpgradeInfoProto| { &mut m.startTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "finalizeTime",
                |m: &RollingUpgradeInfoProto| { &m.finalizeTime },
                |m: &mut RollingUpgradeInfoProto| { &mut m.finalizeTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "createdRollbackImages",
                |m: &RollingUpgradeInfoProto| { &m.createdRollbackImages },
                |m: &mut RollingUpgradeInfoProto| { &mut m.createdRollbackImages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RollingUpgradeInfoProto>(
                "RollingUpgradeInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RollingUpgradeInfoProto {
        static instance: ::protobuf::rt::LazyV2<RollingUpgradeInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RollingUpgradeInfoProto::new)
    }
}

impl ::protobuf::Clear for RollingUpgradeInfoProto {
    fn clear(&mut self) {
        self.status.clear();
        self.startTime = ::std::option::Option::None;
        self.finalizeTime = ::std::option::Option::None;
        self.createdRollbackImages = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollingUpgradeInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpgradeInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollingUpgradeResponseProto {
    // message fields
    pub rollingUpgradeInfo: ::protobuf::SingularPtrField<RollingUpgradeInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RollingUpgradeResponseProto {
    fn default() -> &'a RollingUpgradeResponseProto {
        <RollingUpgradeResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RollingUpgradeResponseProto {
    pub fn new() -> RollingUpgradeResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.RollingUpgradeInfoProto rollingUpgradeInfo = 1;


    pub fn get_rollingUpgradeInfo(&self) -> &RollingUpgradeInfoProto {
        self.rollingUpgradeInfo.as_ref().unwrap_or_else(|| <RollingUpgradeInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rollingUpgradeInfo(&mut self) {
        self.rollingUpgradeInfo.clear();
    }

    pub fn has_rollingUpgradeInfo(&self) -> bool {
        self.rollingUpgradeInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollingUpgradeInfo(&mut self, v: RollingUpgradeInfoProto) {
        self.rollingUpgradeInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollingUpgradeInfo(&mut self) -> &mut RollingUpgradeInfoProto {
        if self.rollingUpgradeInfo.is_none() {
            self.rollingUpgradeInfo.set_default();
        }
        self.rollingUpgradeInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_rollingUpgradeInfo(&mut self) -> RollingUpgradeInfoProto {
        self.rollingUpgradeInfo.take().unwrap_or_else(|| RollingUpgradeInfoProto::new())
    }
}

impl ::protobuf::Message for RollingUpgradeResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.rollingUpgradeInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rollingUpgradeInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rollingUpgradeInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rollingUpgradeInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RollingUpgradeResponseProto {
        RollingUpgradeResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RollingUpgradeInfoProto>>(
                "rollingUpgradeInfo",
                |m: &RollingUpgradeResponseProto| { &m.rollingUpgradeInfo },
                |m: &mut RollingUpgradeResponseProto| { &mut m.rollingUpgradeInfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RollingUpgradeResponseProto>(
                "RollingUpgradeResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RollingUpgradeResponseProto {
        static instance: ::protobuf::rt::LazyV2<RollingUpgradeResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RollingUpgradeResponseProto::new)
    }
}

impl ::protobuf::Clear for RollingUpgradeResponseProto {
    fn clear(&mut self) {
        self.rollingUpgradeInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollingUpgradeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpgradeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCorruptFileBlocksRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    cookie: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListCorruptFileBlocksRequestProto {
    fn default() -> &'a ListCorruptFileBlocksRequestProto {
        <ListCorruptFileBlocksRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ListCorruptFileBlocksRequestProto {
    pub fn new() -> ListCorruptFileBlocksRequestProto {
        ::std::default::Default::default()
    }

    // required string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string cookie = 2;


    pub fn get_cookie(&self) -> &str {
        match self.cookie.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_cookie(&mut self) {
        self.cookie.clear();
    }

    pub fn has_cookie(&self) -> bool {
        self.cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: ::std::string::String) {
        self.cookie = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cookie(&mut self) -> &mut ::std::string::String {
        if self.cookie.is_none() {
            self.cookie.set_default();
        }
        self.cookie.as_mut().unwrap()
    }

    // Take field
    pub fn take_cookie(&mut self) -> ::std::string::String {
        self.cookie.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListCorruptFileBlocksRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.cookie.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.cookie.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListCorruptFileBlocksRequestProto {
        ListCorruptFileBlocksRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &ListCorruptFileBlocksRequestProto| { &m.path },
                |m: &mut ListCorruptFileBlocksRequestProto| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cookie",
                |m: &ListCorruptFileBlocksRequestProto| { &m.cookie },
                |m: &mut ListCorruptFileBlocksRequestProto| { &mut m.cookie },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListCorruptFileBlocksRequestProto>(
                "ListCorruptFileBlocksRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListCorruptFileBlocksRequestProto {
        static instance: ::protobuf::rt::LazyV2<ListCorruptFileBlocksRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListCorruptFileBlocksRequestProto::new)
    }
}

impl ::protobuf::Clear for ListCorruptFileBlocksRequestProto {
    fn clear(&mut self) {
        self.path.clear();
        self.cookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCorruptFileBlocksRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCorruptFileBlocksRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCorruptFileBlocksResponseProto {
    // message fields
    pub corrupt: ::protobuf::SingularPtrField<super::hdfs::CorruptFileBlocksProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListCorruptFileBlocksResponseProto {
    fn default() -> &'a ListCorruptFileBlocksResponseProto {
        <ListCorruptFileBlocksResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ListCorruptFileBlocksResponseProto {
    pub fn new() -> ListCorruptFileBlocksResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CorruptFileBlocksProto corrupt = 1;


    pub fn get_corrupt(&self) -> &super::hdfs::CorruptFileBlocksProto {
        self.corrupt.as_ref().unwrap_or_else(|| <super::hdfs::CorruptFileBlocksProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_corrupt(&mut self) {
        self.corrupt.clear();
    }

    pub fn has_corrupt(&self) -> bool {
        self.corrupt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_corrupt(&mut self, v: super::hdfs::CorruptFileBlocksProto) {
        self.corrupt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_corrupt(&mut self) -> &mut super::hdfs::CorruptFileBlocksProto {
        if self.corrupt.is_none() {
            self.corrupt.set_default();
        }
        self.corrupt.as_mut().unwrap()
    }

    // Take field
    pub fn take_corrupt(&mut self) -> super::hdfs::CorruptFileBlocksProto {
        self.corrupt.take().unwrap_or_else(|| super::hdfs::CorruptFileBlocksProto::new())
    }
}

impl ::protobuf::Message for ListCorruptFileBlocksResponseProto {
    fn is_initialized(&self) -> bool {
        if self.corrupt.is_none() {
            return false;
        }
        for v in &self.corrupt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.corrupt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.corrupt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.corrupt.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListCorruptFileBlocksResponseProto {
        ListCorruptFileBlocksResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::CorruptFileBlocksProto>>(
                "corrupt",
                |m: &ListCorruptFileBlocksResponseProto| { &m.corrupt },
                |m: &mut ListCorruptFileBlocksResponseProto| { &mut m.corrupt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListCorruptFileBlocksResponseProto>(
                "ListCorruptFileBlocksResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListCorruptFileBlocksResponseProto {
        static instance: ::protobuf::rt::LazyV2<ListCorruptFileBlocksResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListCorruptFileBlocksResponseProto::new)
    }
}

impl ::protobuf::Clear for ListCorruptFileBlocksResponseProto {
    fn clear(&mut self) {
        self.corrupt.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCorruptFileBlocksResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCorruptFileBlocksResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaSaveRequestProto {
    // message fields
    filename: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaSaveRequestProto {
    fn default() -> &'a MetaSaveRequestProto {
        <MetaSaveRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl MetaSaveRequestProto {
    pub fn new() -> MetaSaveRequestProto {
        ::std::default::Default::default()
    }

    // required string filename = 1;


    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for MetaSaveRequestProto {
    fn is_initialized(&self) -> bool {
        if self.filename.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaSaveRequestProto {
        MetaSaveRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filename",
                |m: &MetaSaveRequestProto| { &m.filename },
                |m: &mut MetaSaveRequestProto| { &mut m.filename },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MetaSaveRequestProto>(
                "MetaSaveRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MetaSaveRequestProto {
        static instance: ::protobuf::rt::LazyV2<MetaSaveRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MetaSaveRequestProto::new)
    }
}

impl ::protobuf::Clear for MetaSaveRequestProto {
    fn clear(&mut self) {
        self.filename.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaSaveRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaSaveRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaSaveResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaSaveResponseProto {
    fn default() -> &'a MetaSaveResponseProto {
        <MetaSaveResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl MetaSaveResponseProto {
    pub fn new() -> MetaSaveResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MetaSaveResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaSaveResponseProto {
        MetaSaveResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MetaSaveResponseProto>(
                "MetaSaveResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MetaSaveResponseProto {
        static instance: ::protobuf::rt::LazyV2<MetaSaveResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MetaSaveResponseProto::new)
    }
}

impl ::protobuf::Clear for MetaSaveResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaSaveResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaSaveResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFileInfoRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFileInfoRequestProto {
    fn default() -> &'a GetFileInfoRequestProto {
        <GetFileInfoRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetFileInfoRequestProto {
    pub fn new() -> GetFileInfoRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetFileInfoRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFileInfoRequestProto {
        GetFileInfoRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &GetFileInfoRequestProto| { &m.src },
                |m: &mut GetFileInfoRequestProto| { &mut m.src },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFileInfoRequestProto>(
                "GetFileInfoRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFileInfoRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetFileInfoRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFileInfoRequestProto::new)
    }
}

impl ::protobuf::Clear for GetFileInfoRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFileInfoRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFileInfoRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFileInfoResponseProto {
    // message fields
    pub fs: ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFileInfoResponseProto {
    fn default() -> &'a GetFileInfoResponseProto {
        <GetFileInfoResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetFileInfoResponseProto {
    pub fn new() -> GetFileInfoResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.HdfsFileStatusProto fs = 1;


    pub fn get_fs(&self) -> &super::hdfs::HdfsFileStatusProto {
        self.fs.as_ref().unwrap_or_else(|| <super::hdfs::HdfsFileStatusProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fs(&mut self) {
        self.fs.clear();
    }

    pub fn has_fs(&self) -> bool {
        self.fs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fs(&mut self, v: super::hdfs::HdfsFileStatusProto) {
        self.fs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fs(&mut self) -> &mut super::hdfs::HdfsFileStatusProto {
        if self.fs.is_none() {
            self.fs.set_default();
        }
        self.fs.as_mut().unwrap()
    }

    // Take field
    pub fn take_fs(&mut self) -> super::hdfs::HdfsFileStatusProto {
        self.fs.take().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::new())
    }
}

impl ::protobuf::Message for GetFileInfoResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.fs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fs.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFileInfoResponseProto {
        GetFileInfoResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::HdfsFileStatusProto>>(
                "fs",
                |m: &GetFileInfoResponseProto| { &m.fs },
                |m: &mut GetFileInfoResponseProto| { &mut m.fs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFileInfoResponseProto>(
                "GetFileInfoResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFileInfoResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetFileInfoResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFileInfoResponseProto::new)
    }
}

impl ::protobuf::Clear for GetFileInfoResponseProto {
    fn clear(&mut self) {
        self.fs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFileInfoResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFileInfoResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLocatedFileInfoRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    needBlockToken: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLocatedFileInfoRequestProto {
    fn default() -> &'a GetLocatedFileInfoRequestProto {
        <GetLocatedFileInfoRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetLocatedFileInfoRequestProto {
    pub fn new() -> GetLocatedFileInfoRequestProto {
        ::std::default::Default::default()
    }

    // optional string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool needBlockToken = 2;


    pub fn get_needBlockToken(&self) -> bool {
        self.needBlockToken.unwrap_or(false)
    }
    pub fn clear_needBlockToken(&mut self) {
        self.needBlockToken = ::std::option::Option::None;
    }

    pub fn has_needBlockToken(&self) -> bool {
        self.needBlockToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needBlockToken(&mut self, v: bool) {
        self.needBlockToken = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetLocatedFileInfoRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needBlockToken = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.needBlockToken {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.needBlockToken {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLocatedFileInfoRequestProto {
        GetLocatedFileInfoRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &GetLocatedFileInfoRequestProto| { &m.src },
                |m: &mut GetLocatedFileInfoRequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "needBlockToken",
                |m: &GetLocatedFileInfoRequestProto| { &m.needBlockToken },
                |m: &mut GetLocatedFileInfoRequestProto| { &mut m.needBlockToken },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetLocatedFileInfoRequestProto>(
                "GetLocatedFileInfoRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetLocatedFileInfoRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetLocatedFileInfoRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetLocatedFileInfoRequestProto::new)
    }
}

impl ::protobuf::Clear for GetLocatedFileInfoRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.needBlockToken = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLocatedFileInfoRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLocatedFileInfoRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLocatedFileInfoResponseProto {
    // message fields
    pub fs: ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLocatedFileInfoResponseProto {
    fn default() -> &'a GetLocatedFileInfoResponseProto {
        <GetLocatedFileInfoResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetLocatedFileInfoResponseProto {
    pub fn new() -> GetLocatedFileInfoResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.HdfsFileStatusProto fs = 1;


    pub fn get_fs(&self) -> &super::hdfs::HdfsFileStatusProto {
        self.fs.as_ref().unwrap_or_else(|| <super::hdfs::HdfsFileStatusProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fs(&mut self) {
        self.fs.clear();
    }

    pub fn has_fs(&self) -> bool {
        self.fs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fs(&mut self, v: super::hdfs::HdfsFileStatusProto) {
        self.fs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fs(&mut self) -> &mut super::hdfs::HdfsFileStatusProto {
        if self.fs.is_none() {
            self.fs.set_default();
        }
        self.fs.as_mut().unwrap()
    }

    // Take field
    pub fn take_fs(&mut self) -> super::hdfs::HdfsFileStatusProto {
        self.fs.take().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::new())
    }
}

impl ::protobuf::Message for GetLocatedFileInfoResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.fs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fs.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLocatedFileInfoResponseProto {
        GetLocatedFileInfoResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::HdfsFileStatusProto>>(
                "fs",
                |m: &GetLocatedFileInfoResponseProto| { &m.fs },
                |m: &mut GetLocatedFileInfoResponseProto| { &mut m.fs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetLocatedFileInfoResponseProto>(
                "GetLocatedFileInfoResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetLocatedFileInfoResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetLocatedFileInfoResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetLocatedFileInfoResponseProto::new)
    }
}

impl ::protobuf::Clear for GetLocatedFileInfoResponseProto {
    fn clear(&mut self) {
        self.fs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLocatedFileInfoResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLocatedFileInfoResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsFileClosedRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsFileClosedRequestProto {
    fn default() -> &'a IsFileClosedRequestProto {
        <IsFileClosedRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl IsFileClosedRequestProto {
    pub fn new() -> IsFileClosedRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for IsFileClosedRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IsFileClosedRequestProto {
        IsFileClosedRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &IsFileClosedRequestProto| { &m.src },
                |m: &mut IsFileClosedRequestProto| { &mut m.src },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IsFileClosedRequestProto>(
                "IsFileClosedRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IsFileClosedRequestProto {
        static instance: ::protobuf::rt::LazyV2<IsFileClosedRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IsFileClosedRequestProto::new)
    }
}

impl ::protobuf::Clear for IsFileClosedRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsFileClosedRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsFileClosedRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsFileClosedResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsFileClosedResponseProto {
    fn default() -> &'a IsFileClosedResponseProto {
        <IsFileClosedResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl IsFileClosedResponseProto {
    pub fn new() -> IsFileClosedResponseProto {
        ::std::default::Default::default()
    }

    // required bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for IsFileClosedResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IsFileClosedResponseProto {
        IsFileClosedResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "result",
                |m: &IsFileClosedResponseProto| { &m.result },
                |m: &mut IsFileClosedResponseProto| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IsFileClosedResponseProto>(
                "IsFileClosedResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IsFileClosedResponseProto {
        static instance: ::protobuf::rt::LazyV2<IsFileClosedResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IsFileClosedResponseProto::new)
    }
}

impl ::protobuf::Clear for IsFileClosedResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsFileClosedResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsFileClosedResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CacheDirectiveInfoProto {
    // message fields
    id: ::std::option::Option<i64>,
    path: ::protobuf::SingularField<::std::string::String>,
    replication: ::std::option::Option<u32>,
    pool: ::protobuf::SingularField<::std::string::String>,
    pub expiration: ::protobuf::SingularPtrField<CacheDirectiveInfoExpirationProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CacheDirectiveInfoProto {
    fn default() -> &'a CacheDirectiveInfoProto {
        <CacheDirectiveInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl CacheDirectiveInfoProto {
    pub fn new() -> CacheDirectiveInfoProto {
        ::std::default::Default::default()
    }

    // optional int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string path = 2;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 replication = 3;


    pub fn get_replication(&self) -> u32 {
        self.replication.unwrap_or(0)
    }
    pub fn clear_replication(&mut self) {
        self.replication = ::std::option::Option::None;
    }

    pub fn has_replication(&self) -> bool {
        self.replication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replication(&mut self, v: u32) {
        self.replication = ::std::option::Option::Some(v);
    }

    // optional string pool = 4;


    pub fn get_pool(&self) -> &str {
        match self.pool.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_pool(&mut self) {
        self.pool.clear();
    }

    pub fn has_pool(&self) -> bool {
        self.pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pool(&mut self, v: ::std::string::String) {
        self.pool = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pool(&mut self) -> &mut ::std::string::String {
        if self.pool.is_none() {
            self.pool.set_default();
        }
        self.pool.as_mut().unwrap()
    }

    // Take field
    pub fn take_pool(&mut self) -> ::std::string::String {
        self.pool.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .hadoop.hdfs.CacheDirectiveInfoExpirationProto expiration = 5;


    pub fn get_expiration(&self) -> &CacheDirectiveInfoExpirationProto {
        self.expiration.as_ref().unwrap_or_else(|| <CacheDirectiveInfoExpirationProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_expiration(&mut self) {
        self.expiration.clear();
    }

    pub fn has_expiration(&self) -> bool {
        self.expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration(&mut self, v: CacheDirectiveInfoExpirationProto) {
        self.expiration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expiration(&mut self) -> &mut CacheDirectiveInfoExpirationProto {
        if self.expiration.is_none() {
            self.expiration.set_default();
        }
        self.expiration.as_mut().unwrap()
    }

    // Take field
    pub fn take_expiration(&mut self) -> CacheDirectiveInfoExpirationProto {
        self.expiration.take().unwrap_or_else(|| CacheDirectiveInfoExpirationProto::new())
    }
}

impl ::protobuf::Message for CacheDirectiveInfoProto {
    fn is_initialized(&self) -> bool {
        for v in &self.expiration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.replication = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pool)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expiration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.replication {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.pool.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.expiration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.replication {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.pool.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.expiration.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CacheDirectiveInfoProto {
        CacheDirectiveInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &CacheDirectiveInfoProto| { &m.id },
                |m: &mut CacheDirectiveInfoProto| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &CacheDirectiveInfoProto| { &m.path },
                |m: &mut CacheDirectiveInfoProto| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "replication",
                |m: &CacheDirectiveInfoProto| { &m.replication },
                |m: &mut CacheDirectiveInfoProto| { &mut m.replication },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pool",
                |m: &CacheDirectiveInfoProto| { &m.pool },
                |m: &mut CacheDirectiveInfoProto| { &mut m.pool },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveInfoExpirationProto>>(
                "expiration",
                |m: &CacheDirectiveInfoProto| { &m.expiration },
                |m: &mut CacheDirectiveInfoProto| { &mut m.expiration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CacheDirectiveInfoProto>(
                "CacheDirectiveInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CacheDirectiveInfoProto {
        static instance: ::protobuf::rt::LazyV2<CacheDirectiveInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CacheDirectiveInfoProto::new)
    }
}

impl ::protobuf::Clear for CacheDirectiveInfoProto {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.path.clear();
        self.replication = ::std::option::Option::None;
        self.pool.clear();
        self.expiration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheDirectiveInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheDirectiveInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CacheDirectiveInfoExpirationProto {
    // message fields
    millis: ::std::option::Option<i64>,
    isRelative: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CacheDirectiveInfoExpirationProto {
    fn default() -> &'a CacheDirectiveInfoExpirationProto {
        <CacheDirectiveInfoExpirationProto as ::protobuf::Message>::default_instance()
    }
}

impl CacheDirectiveInfoExpirationProto {
    pub fn new() -> CacheDirectiveInfoExpirationProto {
        ::std::default::Default::default()
    }

    // required int64 millis = 1;


    pub fn get_millis(&self) -> i64 {
        self.millis.unwrap_or(0)
    }
    pub fn clear_millis(&mut self) {
        self.millis = ::std::option::Option::None;
    }

    pub fn has_millis(&self) -> bool {
        self.millis.is_some()
    }

    // Param is passed by value, moved
    pub fn set_millis(&mut self, v: i64) {
        self.millis = ::std::option::Option::Some(v);
    }

    // required bool isRelative = 2;


    pub fn get_isRelative(&self) -> bool {
        self.isRelative.unwrap_or(false)
    }
    pub fn clear_isRelative(&mut self) {
        self.isRelative = ::std::option::Option::None;
    }

    pub fn has_isRelative(&self) -> bool {
        self.isRelative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isRelative(&mut self, v: bool) {
        self.isRelative = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CacheDirectiveInfoExpirationProto {
    fn is_initialized(&self) -> bool {
        if self.millis.is_none() {
            return false;
        }
        if self.isRelative.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.millis = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isRelative = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.millis {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.isRelative {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.millis {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.isRelative {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CacheDirectiveInfoExpirationProto {
        CacheDirectiveInfoExpirationProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "millis",
                |m: &CacheDirectiveInfoExpirationProto| { &m.millis },
                |m: &mut CacheDirectiveInfoExpirationProto| { &mut m.millis },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isRelative",
                |m: &CacheDirectiveInfoExpirationProto| { &m.isRelative },
                |m: &mut CacheDirectiveInfoExpirationProto| { &mut m.isRelative },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CacheDirectiveInfoExpirationProto>(
                "CacheDirectiveInfoExpirationProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CacheDirectiveInfoExpirationProto {
        static instance: ::protobuf::rt::LazyV2<CacheDirectiveInfoExpirationProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CacheDirectiveInfoExpirationProto::new)
    }
}

impl ::protobuf::Clear for CacheDirectiveInfoExpirationProto {
    fn clear(&mut self) {
        self.millis = ::std::option::Option::None;
        self.isRelative = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheDirectiveInfoExpirationProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheDirectiveInfoExpirationProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CacheDirectiveStatsProto {
    // message fields
    bytesNeeded: ::std::option::Option<i64>,
    bytesCached: ::std::option::Option<i64>,
    filesNeeded: ::std::option::Option<i64>,
    filesCached: ::std::option::Option<i64>,
    hasExpired: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CacheDirectiveStatsProto {
    fn default() -> &'a CacheDirectiveStatsProto {
        <CacheDirectiveStatsProto as ::protobuf::Message>::default_instance()
    }
}

impl CacheDirectiveStatsProto {
    pub fn new() -> CacheDirectiveStatsProto {
        ::std::default::Default::default()
    }

    // required int64 bytesNeeded = 1;


    pub fn get_bytesNeeded(&self) -> i64 {
        self.bytesNeeded.unwrap_or(0)
    }
    pub fn clear_bytesNeeded(&mut self) {
        self.bytesNeeded = ::std::option::Option::None;
    }

    pub fn has_bytesNeeded(&self) -> bool {
        self.bytesNeeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesNeeded(&mut self, v: i64) {
        self.bytesNeeded = ::std::option::Option::Some(v);
    }

    // required int64 bytesCached = 2;


    pub fn get_bytesCached(&self) -> i64 {
        self.bytesCached.unwrap_or(0)
    }
    pub fn clear_bytesCached(&mut self) {
        self.bytesCached = ::std::option::Option::None;
    }

    pub fn has_bytesCached(&self) -> bool {
        self.bytesCached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesCached(&mut self, v: i64) {
        self.bytesCached = ::std::option::Option::Some(v);
    }

    // required int64 filesNeeded = 3;


    pub fn get_filesNeeded(&self) -> i64 {
        self.filesNeeded.unwrap_or(0)
    }
    pub fn clear_filesNeeded(&mut self) {
        self.filesNeeded = ::std::option::Option::None;
    }

    pub fn has_filesNeeded(&self) -> bool {
        self.filesNeeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesNeeded(&mut self, v: i64) {
        self.filesNeeded = ::std::option::Option::Some(v);
    }

    // required int64 filesCached = 4;


    pub fn get_filesCached(&self) -> i64 {
        self.filesCached.unwrap_or(0)
    }
    pub fn clear_filesCached(&mut self) {
        self.filesCached = ::std::option::Option::None;
    }

    pub fn has_filesCached(&self) -> bool {
        self.filesCached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesCached(&mut self, v: i64) {
        self.filesCached = ::std::option::Option::Some(v);
    }

    // required bool hasExpired = 5;


    pub fn get_hasExpired(&self) -> bool {
        self.hasExpired.unwrap_or(false)
    }
    pub fn clear_hasExpired(&mut self) {
        self.hasExpired = ::std::option::Option::None;
    }

    pub fn has_hasExpired(&self) -> bool {
        self.hasExpired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasExpired(&mut self, v: bool) {
        self.hasExpired = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CacheDirectiveStatsProto {
    fn is_initialized(&self) -> bool {
        if self.bytesNeeded.is_none() {
            return false;
        }
        if self.bytesCached.is_none() {
            return false;
        }
        if self.filesNeeded.is_none() {
            return false;
        }
        if self.filesCached.is_none() {
            return false;
        }
        if self.hasExpired.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytesNeeded = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytesCached = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.filesNeeded = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.filesCached = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasExpired = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bytesNeeded {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytesCached {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesNeeded {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesCached {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hasExpired {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bytesNeeded {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.bytesCached {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.filesNeeded {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.filesCached {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.hasExpired {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CacheDirectiveStatsProto {
        CacheDirectiveStatsProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "bytesNeeded",
                |m: &CacheDirectiveStatsProto| { &m.bytesNeeded },
                |m: &mut CacheDirectiveStatsProto| { &mut m.bytesNeeded },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "bytesCached",
                |m: &CacheDirectiveStatsProto| { &m.bytesCached },
                |m: &mut CacheDirectiveStatsProto| { &mut m.bytesCached },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "filesNeeded",
                |m: &CacheDirectiveStatsProto| { &m.filesNeeded },
                |m: &mut CacheDirectiveStatsProto| { &mut m.filesNeeded },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "filesCached",
                |m: &CacheDirectiveStatsProto| { &m.filesCached },
                |m: &mut CacheDirectiveStatsProto| { &mut m.filesCached },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasExpired",
                |m: &CacheDirectiveStatsProto| { &m.hasExpired },
                |m: &mut CacheDirectiveStatsProto| { &mut m.hasExpired },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CacheDirectiveStatsProto>(
                "CacheDirectiveStatsProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CacheDirectiveStatsProto {
        static instance: ::protobuf::rt::LazyV2<CacheDirectiveStatsProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CacheDirectiveStatsProto::new)
    }
}

impl ::protobuf::Clear for CacheDirectiveStatsProto {
    fn clear(&mut self) {
        self.bytesNeeded = ::std::option::Option::None;
        self.bytesCached = ::std::option::Option::None;
        self.filesNeeded = ::std::option::Option::None;
        self.filesCached = ::std::option::Option::None;
        self.hasExpired = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheDirectiveStatsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheDirectiveStatsProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddCacheDirectiveRequestProto {
    // message fields
    pub info: ::protobuf::SingularPtrField<CacheDirectiveInfoProto>,
    cacheFlags: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddCacheDirectiveRequestProto {
    fn default() -> &'a AddCacheDirectiveRequestProto {
        <AddCacheDirectiveRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl AddCacheDirectiveRequestProto {
    pub fn new() -> AddCacheDirectiveRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CacheDirectiveInfoProto info = 1;


    pub fn get_info(&self) -> &CacheDirectiveInfoProto {
        self.info.as_ref().unwrap_or_else(|| <CacheDirectiveInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CacheDirectiveInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CacheDirectiveInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CacheDirectiveInfoProto {
        self.info.take().unwrap_or_else(|| CacheDirectiveInfoProto::new())
    }

    // optional uint32 cacheFlags = 2;


    pub fn get_cacheFlags(&self) -> u32 {
        self.cacheFlags.unwrap_or(0)
    }
    pub fn clear_cacheFlags(&mut self) {
        self.cacheFlags = ::std::option::Option::None;
    }

    pub fn has_cacheFlags(&self) -> bool {
        self.cacheFlags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cacheFlags(&mut self, v: u32) {
        self.cacheFlags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for AddCacheDirectiveRequestProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cacheFlags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.cacheFlags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.cacheFlags {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddCacheDirectiveRequestProto {
        AddCacheDirectiveRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveInfoProto>>(
                "info",
                |m: &AddCacheDirectiveRequestProto| { &m.info },
                |m: &mut AddCacheDirectiveRequestProto| { &mut m.info },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cacheFlags",
                |m: &AddCacheDirectiveRequestProto| { &m.cacheFlags },
                |m: &mut AddCacheDirectiveRequestProto| { &mut m.cacheFlags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddCacheDirectiveRequestProto>(
                "AddCacheDirectiveRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddCacheDirectiveRequestProto {
        static instance: ::protobuf::rt::LazyV2<AddCacheDirectiveRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddCacheDirectiveRequestProto::new)
    }
}

impl ::protobuf::Clear for AddCacheDirectiveRequestProto {
    fn clear(&mut self) {
        self.info.clear();
        self.cacheFlags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddCacheDirectiveRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddCacheDirectiveRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddCacheDirectiveResponseProto {
    // message fields
    id: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddCacheDirectiveResponseProto {
    fn default() -> &'a AddCacheDirectiveResponseProto {
        <AddCacheDirectiveResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl AddCacheDirectiveResponseProto {
    pub fn new() -> AddCacheDirectiveResponseProto {
        ::std::default::Default::default()
    }

    // required int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for AddCacheDirectiveResponseProto {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddCacheDirectiveResponseProto {
        AddCacheDirectiveResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &AddCacheDirectiveResponseProto| { &m.id },
                |m: &mut AddCacheDirectiveResponseProto| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddCacheDirectiveResponseProto>(
                "AddCacheDirectiveResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddCacheDirectiveResponseProto {
        static instance: ::protobuf::rt::LazyV2<AddCacheDirectiveResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddCacheDirectiveResponseProto::new)
    }
}

impl ::protobuf::Clear for AddCacheDirectiveResponseProto {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddCacheDirectiveResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddCacheDirectiveResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifyCacheDirectiveRequestProto {
    // message fields
    pub info: ::protobuf::SingularPtrField<CacheDirectiveInfoProto>,
    cacheFlags: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModifyCacheDirectiveRequestProto {
    fn default() -> &'a ModifyCacheDirectiveRequestProto {
        <ModifyCacheDirectiveRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ModifyCacheDirectiveRequestProto {
    pub fn new() -> ModifyCacheDirectiveRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CacheDirectiveInfoProto info = 1;


    pub fn get_info(&self) -> &CacheDirectiveInfoProto {
        self.info.as_ref().unwrap_or_else(|| <CacheDirectiveInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CacheDirectiveInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CacheDirectiveInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CacheDirectiveInfoProto {
        self.info.take().unwrap_or_else(|| CacheDirectiveInfoProto::new())
    }

    // optional uint32 cacheFlags = 2;


    pub fn get_cacheFlags(&self) -> u32 {
        self.cacheFlags.unwrap_or(0)
    }
    pub fn clear_cacheFlags(&mut self) {
        self.cacheFlags = ::std::option::Option::None;
    }

    pub fn has_cacheFlags(&self) -> bool {
        self.cacheFlags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cacheFlags(&mut self, v: u32) {
        self.cacheFlags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ModifyCacheDirectiveRequestProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cacheFlags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.cacheFlags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.cacheFlags {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyCacheDirectiveRequestProto {
        ModifyCacheDirectiveRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveInfoProto>>(
                "info",
                |m: &ModifyCacheDirectiveRequestProto| { &m.info },
                |m: &mut ModifyCacheDirectiveRequestProto| { &mut m.info },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cacheFlags",
                |m: &ModifyCacheDirectiveRequestProto| { &m.cacheFlags },
                |m: &mut ModifyCacheDirectiveRequestProto| { &mut m.cacheFlags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModifyCacheDirectiveRequestProto>(
                "ModifyCacheDirectiveRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModifyCacheDirectiveRequestProto {
        static instance: ::protobuf::rt::LazyV2<ModifyCacheDirectiveRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModifyCacheDirectiveRequestProto::new)
    }
}

impl ::protobuf::Clear for ModifyCacheDirectiveRequestProto {
    fn clear(&mut self) {
        self.info.clear();
        self.cacheFlags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyCacheDirectiveRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyCacheDirectiveRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifyCacheDirectiveResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModifyCacheDirectiveResponseProto {
    fn default() -> &'a ModifyCacheDirectiveResponseProto {
        <ModifyCacheDirectiveResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ModifyCacheDirectiveResponseProto {
    pub fn new() -> ModifyCacheDirectiveResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ModifyCacheDirectiveResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyCacheDirectiveResponseProto {
        ModifyCacheDirectiveResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModifyCacheDirectiveResponseProto>(
                "ModifyCacheDirectiveResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModifyCacheDirectiveResponseProto {
        static instance: ::protobuf::rt::LazyV2<ModifyCacheDirectiveResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModifyCacheDirectiveResponseProto::new)
    }
}

impl ::protobuf::Clear for ModifyCacheDirectiveResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyCacheDirectiveResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyCacheDirectiveResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveCacheDirectiveRequestProto {
    // message fields
    id: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveCacheDirectiveRequestProto {
    fn default() -> &'a RemoveCacheDirectiveRequestProto {
        <RemoveCacheDirectiveRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RemoveCacheDirectiveRequestProto {
    pub fn new() -> RemoveCacheDirectiveRequestProto {
        ::std::default::Default::default()
    }

    // required int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RemoveCacheDirectiveRequestProto {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveCacheDirectiveRequestProto {
        RemoveCacheDirectiveRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &RemoveCacheDirectiveRequestProto| { &m.id },
                |m: &mut RemoveCacheDirectiveRequestProto| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveCacheDirectiveRequestProto>(
                "RemoveCacheDirectiveRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RemoveCacheDirectiveRequestProto {
        static instance: ::protobuf::rt::LazyV2<RemoveCacheDirectiveRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoveCacheDirectiveRequestProto::new)
    }
}

impl ::protobuf::Clear for RemoveCacheDirectiveRequestProto {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveCacheDirectiveRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveCacheDirectiveRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveCacheDirectiveResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveCacheDirectiveResponseProto {
    fn default() -> &'a RemoveCacheDirectiveResponseProto {
        <RemoveCacheDirectiveResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RemoveCacheDirectiveResponseProto {
    pub fn new() -> RemoveCacheDirectiveResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RemoveCacheDirectiveResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveCacheDirectiveResponseProto {
        RemoveCacheDirectiveResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveCacheDirectiveResponseProto>(
                "RemoveCacheDirectiveResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RemoveCacheDirectiveResponseProto {
        static instance: ::protobuf::rt::LazyV2<RemoveCacheDirectiveResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoveCacheDirectiveResponseProto::new)
    }
}

impl ::protobuf::Clear for RemoveCacheDirectiveResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveCacheDirectiveResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveCacheDirectiveResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCacheDirectivesRequestProto {
    // message fields
    prevId: ::std::option::Option<i64>,
    pub filter: ::protobuf::SingularPtrField<CacheDirectiveInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListCacheDirectivesRequestProto {
    fn default() -> &'a ListCacheDirectivesRequestProto {
        <ListCacheDirectivesRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ListCacheDirectivesRequestProto {
    pub fn new() -> ListCacheDirectivesRequestProto {
        ::std::default::Default::default()
    }

    // required int64 prevId = 1;


    pub fn get_prevId(&self) -> i64 {
        self.prevId.unwrap_or(0)
    }
    pub fn clear_prevId(&mut self) {
        self.prevId = ::std::option::Option::None;
    }

    pub fn has_prevId(&self) -> bool {
        self.prevId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevId(&mut self, v: i64) {
        self.prevId = ::std::option::Option::Some(v);
    }

    // required .hadoop.hdfs.CacheDirectiveInfoProto filter = 2;


    pub fn get_filter(&self) -> &CacheDirectiveInfoProto {
        self.filter.as_ref().unwrap_or_else(|| <CacheDirectiveInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    pub fn has_filter(&self) -> bool {
        self.filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: CacheDirectiveInfoProto) {
        self.filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut CacheDirectiveInfoProto {
        if self.filter.is_none() {
            self.filter.set_default();
        }
        self.filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter(&mut self) -> CacheDirectiveInfoProto {
        self.filter.take().unwrap_or_else(|| CacheDirectiveInfoProto::new())
    }
}

impl ::protobuf::Message for ListCacheDirectivesRequestProto {
    fn is_initialized(&self) -> bool {
        if self.prevId.is_none() {
            return false;
        }
        if self.filter.is_none() {
            return false;
        }
        for v in &self.filter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.prevId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.prevId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.prevId {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.filter.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListCacheDirectivesRequestProto {
        ListCacheDirectivesRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "prevId",
                |m: &ListCacheDirectivesRequestProto| { &m.prevId },
                |m: &mut ListCacheDirectivesRequestProto| { &mut m.prevId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveInfoProto>>(
                "filter",
                |m: &ListCacheDirectivesRequestProto| { &m.filter },
                |m: &mut ListCacheDirectivesRequestProto| { &mut m.filter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListCacheDirectivesRequestProto>(
                "ListCacheDirectivesRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListCacheDirectivesRequestProto {
        static instance: ::protobuf::rt::LazyV2<ListCacheDirectivesRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListCacheDirectivesRequestProto::new)
    }
}

impl ::protobuf::Clear for ListCacheDirectivesRequestProto {
    fn clear(&mut self) {
        self.prevId = ::std::option::Option::None;
        self.filter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCacheDirectivesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCacheDirectivesRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CacheDirectiveEntryProto {
    // message fields
    pub info: ::protobuf::SingularPtrField<CacheDirectiveInfoProto>,
    pub stats: ::protobuf::SingularPtrField<CacheDirectiveStatsProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CacheDirectiveEntryProto {
    fn default() -> &'a CacheDirectiveEntryProto {
        <CacheDirectiveEntryProto as ::protobuf::Message>::default_instance()
    }
}

impl CacheDirectiveEntryProto {
    pub fn new() -> CacheDirectiveEntryProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CacheDirectiveInfoProto info = 1;


    pub fn get_info(&self) -> &CacheDirectiveInfoProto {
        self.info.as_ref().unwrap_or_else(|| <CacheDirectiveInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CacheDirectiveInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CacheDirectiveInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CacheDirectiveInfoProto {
        self.info.take().unwrap_or_else(|| CacheDirectiveInfoProto::new())
    }

    // required .hadoop.hdfs.CacheDirectiveStatsProto stats = 2;


    pub fn get_stats(&self) -> &CacheDirectiveStatsProto {
        self.stats.as_ref().unwrap_or_else(|| <CacheDirectiveStatsProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: CacheDirectiveStatsProto) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut CacheDirectiveStatsProto {
        if self.stats.is_none() {
            self.stats.set_default();
        }
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> CacheDirectiveStatsProto {
        self.stats.take().unwrap_or_else(|| CacheDirectiveStatsProto::new())
    }
}

impl ::protobuf::Message for CacheDirectiveEntryProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        if self.stats.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stats.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CacheDirectiveEntryProto {
        CacheDirectiveEntryProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveInfoProto>>(
                "info",
                |m: &CacheDirectiveEntryProto| { &m.info },
                |m: &mut CacheDirectiveEntryProto| { &mut m.info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveStatsProto>>(
                "stats",
                |m: &CacheDirectiveEntryProto| { &m.stats },
                |m: &mut CacheDirectiveEntryProto| { &mut m.stats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CacheDirectiveEntryProto>(
                "CacheDirectiveEntryProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CacheDirectiveEntryProto {
        static instance: ::protobuf::rt::LazyV2<CacheDirectiveEntryProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CacheDirectiveEntryProto::new)
    }
}

impl ::protobuf::Clear for CacheDirectiveEntryProto {
    fn clear(&mut self) {
        self.info.clear();
        self.stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheDirectiveEntryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheDirectiveEntryProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCacheDirectivesResponseProto {
    // message fields
    pub elements: ::protobuf::RepeatedField<CacheDirectiveEntryProto>,
    hasMore: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListCacheDirectivesResponseProto {
    fn default() -> &'a ListCacheDirectivesResponseProto {
        <ListCacheDirectivesResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ListCacheDirectivesResponseProto {
    pub fn new() -> ListCacheDirectivesResponseProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.CacheDirectiveEntryProto elements = 1;


    pub fn get_elements(&self) -> &[CacheDirectiveEntryProto] {
        &self.elements
    }
    pub fn clear_elements(&mut self) {
        self.elements.clear();
    }

    // Param is passed by value, moved
    pub fn set_elements(&mut self, v: ::protobuf::RepeatedField<CacheDirectiveEntryProto>) {
        self.elements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_elements(&mut self) -> &mut ::protobuf::RepeatedField<CacheDirectiveEntryProto> {
        &mut self.elements
    }

    // Take field
    pub fn take_elements(&mut self) -> ::protobuf::RepeatedField<CacheDirectiveEntryProto> {
        ::std::mem::replace(&mut self.elements, ::protobuf::RepeatedField::new())
    }

    // required bool hasMore = 2;


    pub fn get_hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }
    pub fn clear_hasMore(&mut self) {
        self.hasMore = ::std::option::Option::None;
    }

    pub fn has_hasMore(&self) -> bool {
        self.hasMore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMore(&mut self, v: bool) {
        self.hasMore = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ListCacheDirectivesResponseProto {
    fn is_initialized(&self) -> bool {
        if self.hasMore.is_none() {
            return false;
        }
        for v in &self.elements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.elements)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasMore = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.elements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.hasMore {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.elements {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.hasMore {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListCacheDirectivesResponseProto {
        ListCacheDirectivesResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveEntryProto>>(
                "elements",
                |m: &ListCacheDirectivesResponseProto| { &m.elements },
                |m: &mut ListCacheDirectivesResponseProto| { &mut m.elements },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasMore",
                |m: &ListCacheDirectivesResponseProto| { &m.hasMore },
                |m: &mut ListCacheDirectivesResponseProto| { &mut m.hasMore },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListCacheDirectivesResponseProto>(
                "ListCacheDirectivesResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListCacheDirectivesResponseProto {
        static instance: ::protobuf::rt::LazyV2<ListCacheDirectivesResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListCacheDirectivesResponseProto::new)
    }
}

impl ::protobuf::Clear for ListCacheDirectivesResponseProto {
    fn clear(&mut self) {
        self.elements.clear();
        self.hasMore = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCacheDirectivesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCacheDirectivesResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CachePoolInfoProto {
    // message fields
    poolName: ::protobuf::SingularField<::std::string::String>,
    ownerName: ::protobuf::SingularField<::std::string::String>,
    groupName: ::protobuf::SingularField<::std::string::String>,
    mode: ::std::option::Option<i32>,
    limit: ::std::option::Option<i64>,
    maxRelativeExpiry: ::std::option::Option<i64>,
    defaultReplication: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CachePoolInfoProto {
    fn default() -> &'a CachePoolInfoProto {
        <CachePoolInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl CachePoolInfoProto {
    pub fn new() -> CachePoolInfoProto {
        ::std::default::Default::default()
    }

    // optional string poolName = 1;


    pub fn get_poolName(&self) -> &str {
        match self.poolName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_poolName(&mut self) {
        self.poolName.clear();
    }

    pub fn has_poolName(&self) -> bool {
        self.poolName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poolName(&mut self, v: ::std::string::String) {
        self.poolName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poolName(&mut self) -> &mut ::std::string::String {
        if self.poolName.is_none() {
            self.poolName.set_default();
        }
        self.poolName.as_mut().unwrap()
    }

    // Take field
    pub fn take_poolName(&mut self) -> ::std::string::String {
        self.poolName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ownerName = 2;


    pub fn get_ownerName(&self) -> &str {
        match self.ownerName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ownerName(&mut self) {
        self.ownerName.clear();
    }

    pub fn has_ownerName(&self) -> bool {
        self.ownerName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ownerName(&mut self, v: ::std::string::String) {
        self.ownerName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ownerName(&mut self) -> &mut ::std::string::String {
        if self.ownerName.is_none() {
            self.ownerName.set_default();
        }
        self.ownerName.as_mut().unwrap()
    }

    // Take field
    pub fn take_ownerName(&mut self) -> ::std::string::String {
        self.ownerName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string groupName = 3;


    pub fn get_groupName(&self) -> &str {
        match self.groupName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_groupName(&mut self) {
        self.groupName.clear();
    }

    pub fn has_groupName(&self) -> bool {
        self.groupName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupName(&mut self, v: ::std::string::String) {
        self.groupName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupName(&mut self) -> &mut ::std::string::String {
        if self.groupName.is_none() {
            self.groupName.set_default();
        }
        self.groupName.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupName(&mut self) -> ::std::string::String {
        self.groupName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 mode = 4;


    pub fn get_mode(&self) -> i32 {
        self.mode.unwrap_or(0)
    }
    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: i32) {
        self.mode = ::std::option::Option::Some(v);
    }

    // optional int64 limit = 5;


    pub fn get_limit(&self) -> i64 {
        self.limit.unwrap_or(0)
    }
    pub fn clear_limit(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = ::std::option::Option::Some(v);
    }

    // optional int64 maxRelativeExpiry = 6;


    pub fn get_maxRelativeExpiry(&self) -> i64 {
        self.maxRelativeExpiry.unwrap_or(0)
    }
    pub fn clear_maxRelativeExpiry(&mut self) {
        self.maxRelativeExpiry = ::std::option::Option::None;
    }

    pub fn has_maxRelativeExpiry(&self) -> bool {
        self.maxRelativeExpiry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxRelativeExpiry(&mut self, v: i64) {
        self.maxRelativeExpiry = ::std::option::Option::Some(v);
    }

    // optional uint32 defaultReplication = 7;


    pub fn get_defaultReplication(&self) -> u32 {
        self.defaultReplication.unwrap_or(1u32)
    }
    pub fn clear_defaultReplication(&mut self) {
        self.defaultReplication = ::std::option::Option::None;
    }

    pub fn has_defaultReplication(&self) -> bool {
        self.defaultReplication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defaultReplication(&mut self, v: u32) {
        self.defaultReplication = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CachePoolInfoProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.poolName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ownerName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.groupName)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mode = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.maxRelativeExpiry = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.defaultReplication = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.poolName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.ownerName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.groupName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.limit {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxRelativeExpiry {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.defaultReplication {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.poolName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.ownerName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.groupName.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.mode {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.limit {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.maxRelativeExpiry {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.defaultReplication {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CachePoolInfoProto {
        CachePoolInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "poolName",
                |m: &CachePoolInfoProto| { &m.poolName },
                |m: &mut CachePoolInfoProto| { &mut m.poolName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ownerName",
                |m: &CachePoolInfoProto| { &m.ownerName },
                |m: &mut CachePoolInfoProto| { &mut m.ownerName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "groupName",
                |m: &CachePoolInfoProto| { &m.groupName },
                |m: &mut CachePoolInfoProto| { &mut m.groupName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mode",
                |m: &CachePoolInfoProto| { &m.mode },
                |m: &mut CachePoolInfoProto| { &mut m.mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "limit",
                |m: &CachePoolInfoProto| { &m.limit },
                |m: &mut CachePoolInfoProto| { &mut m.limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "maxRelativeExpiry",
                |m: &CachePoolInfoProto| { &m.maxRelativeExpiry },
                |m: &mut CachePoolInfoProto| { &mut m.maxRelativeExpiry },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "defaultReplication",
                |m: &CachePoolInfoProto| { &m.defaultReplication },
                |m: &mut CachePoolInfoProto| { &mut m.defaultReplication },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CachePoolInfoProto>(
                "CachePoolInfoProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CachePoolInfoProto {
        static instance: ::protobuf::rt::LazyV2<CachePoolInfoProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CachePoolInfoProto::new)
    }
}

impl ::protobuf::Clear for CachePoolInfoProto {
    fn clear(&mut self) {
        self.poolName.clear();
        self.ownerName.clear();
        self.groupName.clear();
        self.mode = ::std::option::Option::None;
        self.limit = ::std::option::Option::None;
        self.maxRelativeExpiry = ::std::option::Option::None;
        self.defaultReplication = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CachePoolInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CachePoolInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CachePoolStatsProto {
    // message fields
    bytesNeeded: ::std::option::Option<i64>,
    bytesCached: ::std::option::Option<i64>,
    bytesOverlimit: ::std::option::Option<i64>,
    filesNeeded: ::std::option::Option<i64>,
    filesCached: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CachePoolStatsProto {
    fn default() -> &'a CachePoolStatsProto {
        <CachePoolStatsProto as ::protobuf::Message>::default_instance()
    }
}

impl CachePoolStatsProto {
    pub fn new() -> CachePoolStatsProto {
        ::std::default::Default::default()
    }

    // required int64 bytesNeeded = 1;


    pub fn get_bytesNeeded(&self) -> i64 {
        self.bytesNeeded.unwrap_or(0)
    }
    pub fn clear_bytesNeeded(&mut self) {
        self.bytesNeeded = ::std::option::Option::None;
    }

    pub fn has_bytesNeeded(&self) -> bool {
        self.bytesNeeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesNeeded(&mut self, v: i64) {
        self.bytesNeeded = ::std::option::Option::Some(v);
    }

    // required int64 bytesCached = 2;


    pub fn get_bytesCached(&self) -> i64 {
        self.bytesCached.unwrap_or(0)
    }
    pub fn clear_bytesCached(&mut self) {
        self.bytesCached = ::std::option::Option::None;
    }

    pub fn has_bytesCached(&self) -> bool {
        self.bytesCached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesCached(&mut self, v: i64) {
        self.bytesCached = ::std::option::Option::Some(v);
    }

    // required int64 bytesOverlimit = 3;


    pub fn get_bytesOverlimit(&self) -> i64 {
        self.bytesOverlimit.unwrap_or(0)
    }
    pub fn clear_bytesOverlimit(&mut self) {
        self.bytesOverlimit = ::std::option::Option::None;
    }

    pub fn has_bytesOverlimit(&self) -> bool {
        self.bytesOverlimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesOverlimit(&mut self, v: i64) {
        self.bytesOverlimit = ::std::option::Option::Some(v);
    }

    // required int64 filesNeeded = 4;


    pub fn get_filesNeeded(&self) -> i64 {
        self.filesNeeded.unwrap_or(0)
    }
    pub fn clear_filesNeeded(&mut self) {
        self.filesNeeded = ::std::option::Option::None;
    }

    pub fn has_filesNeeded(&self) -> bool {
        self.filesNeeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesNeeded(&mut self, v: i64) {
        self.filesNeeded = ::std::option::Option::Some(v);
    }

    // required int64 filesCached = 5;


    pub fn get_filesCached(&self) -> i64 {
        self.filesCached.unwrap_or(0)
    }
    pub fn clear_filesCached(&mut self) {
        self.filesCached = ::std::option::Option::None;
    }

    pub fn has_filesCached(&self) -> bool {
        self.filesCached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesCached(&mut self, v: i64) {
        self.filesCached = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CachePoolStatsProto {
    fn is_initialized(&self) -> bool {
        if self.bytesNeeded.is_none() {
            return false;
        }
        if self.bytesCached.is_none() {
            return false;
        }
        if self.bytesOverlimit.is_none() {
            return false;
        }
        if self.filesNeeded.is_none() {
            return false;
        }
        if self.filesCached.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytesNeeded = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytesCached = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytesOverlimit = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.filesNeeded = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.filesCached = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bytesNeeded {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytesCached {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytesOverlimit {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesNeeded {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesCached {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bytesNeeded {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.bytesCached {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.bytesOverlimit {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.filesNeeded {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.filesCached {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CachePoolStatsProto {
        CachePoolStatsProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "bytesNeeded",
                |m: &CachePoolStatsProto| { &m.bytesNeeded },
                |m: &mut CachePoolStatsProto| { &mut m.bytesNeeded },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "bytesCached",
                |m: &CachePoolStatsProto| { &m.bytesCached },
                |m: &mut CachePoolStatsProto| { &mut m.bytesCached },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "bytesOverlimit",
                |m: &CachePoolStatsProto| { &m.bytesOverlimit },
                |m: &mut CachePoolStatsProto| { &mut m.bytesOverlimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "filesNeeded",
                |m: &CachePoolStatsProto| { &m.filesNeeded },
                |m: &mut CachePoolStatsProto| { &mut m.filesNeeded },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "filesCached",
                |m: &CachePoolStatsProto| { &m.filesCached },
                |m: &mut CachePoolStatsProto| { &mut m.filesCached },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CachePoolStatsProto>(
                "CachePoolStatsProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CachePoolStatsProto {
        static instance: ::protobuf::rt::LazyV2<CachePoolStatsProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CachePoolStatsProto::new)
    }
}

impl ::protobuf::Clear for CachePoolStatsProto {
    fn clear(&mut self) {
        self.bytesNeeded = ::std::option::Option::None;
        self.bytesCached = ::std::option::Option::None;
        self.bytesOverlimit = ::std::option::Option::None;
        self.filesNeeded = ::std::option::Option::None;
        self.filesCached = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CachePoolStatsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CachePoolStatsProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddCachePoolRequestProto {
    // message fields
    pub info: ::protobuf::SingularPtrField<CachePoolInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddCachePoolRequestProto {
    fn default() -> &'a AddCachePoolRequestProto {
        <AddCachePoolRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl AddCachePoolRequestProto {
    pub fn new() -> AddCachePoolRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CachePoolInfoProto info = 1;


    pub fn get_info(&self) -> &CachePoolInfoProto {
        self.info.as_ref().unwrap_or_else(|| <CachePoolInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CachePoolInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CachePoolInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CachePoolInfoProto {
        self.info.take().unwrap_or_else(|| CachePoolInfoProto::new())
    }
}

impl ::protobuf::Message for AddCachePoolRequestProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddCachePoolRequestProto {
        AddCachePoolRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachePoolInfoProto>>(
                "info",
                |m: &AddCachePoolRequestProto| { &m.info },
                |m: &mut AddCachePoolRequestProto| { &mut m.info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddCachePoolRequestProto>(
                "AddCachePoolRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddCachePoolRequestProto {
        static instance: ::protobuf::rt::LazyV2<AddCachePoolRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddCachePoolRequestProto::new)
    }
}

impl ::protobuf::Clear for AddCachePoolRequestProto {
    fn clear(&mut self) {
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddCachePoolRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddCachePoolRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddCachePoolResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddCachePoolResponseProto {
    fn default() -> &'a AddCachePoolResponseProto {
        <AddCachePoolResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl AddCachePoolResponseProto {
    pub fn new() -> AddCachePoolResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AddCachePoolResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddCachePoolResponseProto {
        AddCachePoolResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddCachePoolResponseProto>(
                "AddCachePoolResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddCachePoolResponseProto {
        static instance: ::protobuf::rt::LazyV2<AddCachePoolResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddCachePoolResponseProto::new)
    }
}

impl ::protobuf::Clear for AddCachePoolResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddCachePoolResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddCachePoolResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifyCachePoolRequestProto {
    // message fields
    pub info: ::protobuf::SingularPtrField<CachePoolInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModifyCachePoolRequestProto {
    fn default() -> &'a ModifyCachePoolRequestProto {
        <ModifyCachePoolRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ModifyCachePoolRequestProto {
    pub fn new() -> ModifyCachePoolRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CachePoolInfoProto info = 1;


    pub fn get_info(&self) -> &CachePoolInfoProto {
        self.info.as_ref().unwrap_or_else(|| <CachePoolInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CachePoolInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CachePoolInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CachePoolInfoProto {
        self.info.take().unwrap_or_else(|| CachePoolInfoProto::new())
    }
}

impl ::protobuf::Message for ModifyCachePoolRequestProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyCachePoolRequestProto {
        ModifyCachePoolRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachePoolInfoProto>>(
                "info",
                |m: &ModifyCachePoolRequestProto| { &m.info },
                |m: &mut ModifyCachePoolRequestProto| { &mut m.info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModifyCachePoolRequestProto>(
                "ModifyCachePoolRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModifyCachePoolRequestProto {
        static instance: ::protobuf::rt::LazyV2<ModifyCachePoolRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModifyCachePoolRequestProto::new)
    }
}

impl ::protobuf::Clear for ModifyCachePoolRequestProto {
    fn clear(&mut self) {
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyCachePoolRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyCachePoolRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifyCachePoolResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModifyCachePoolResponseProto {
    fn default() -> &'a ModifyCachePoolResponseProto {
        <ModifyCachePoolResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ModifyCachePoolResponseProto {
    pub fn new() -> ModifyCachePoolResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ModifyCachePoolResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyCachePoolResponseProto {
        ModifyCachePoolResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModifyCachePoolResponseProto>(
                "ModifyCachePoolResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModifyCachePoolResponseProto {
        static instance: ::protobuf::rt::LazyV2<ModifyCachePoolResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModifyCachePoolResponseProto::new)
    }
}

impl ::protobuf::Clear for ModifyCachePoolResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyCachePoolResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyCachePoolResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveCachePoolRequestProto {
    // message fields
    poolName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveCachePoolRequestProto {
    fn default() -> &'a RemoveCachePoolRequestProto {
        <RemoveCachePoolRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RemoveCachePoolRequestProto {
    pub fn new() -> RemoveCachePoolRequestProto {
        ::std::default::Default::default()
    }

    // required string poolName = 1;


    pub fn get_poolName(&self) -> &str {
        match self.poolName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_poolName(&mut self) {
        self.poolName.clear();
    }

    pub fn has_poolName(&self) -> bool {
        self.poolName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poolName(&mut self, v: ::std::string::String) {
        self.poolName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poolName(&mut self) -> &mut ::std::string::String {
        if self.poolName.is_none() {
            self.poolName.set_default();
        }
        self.poolName.as_mut().unwrap()
    }

    // Take field
    pub fn take_poolName(&mut self) -> ::std::string::String {
        self.poolName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for RemoveCachePoolRequestProto {
    fn is_initialized(&self) -> bool {
        if self.poolName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.poolName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.poolName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.poolName.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveCachePoolRequestProto {
        RemoveCachePoolRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "poolName",
                |m: &RemoveCachePoolRequestProto| { &m.poolName },
                |m: &mut RemoveCachePoolRequestProto| { &mut m.poolName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveCachePoolRequestProto>(
                "RemoveCachePoolRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RemoveCachePoolRequestProto {
        static instance: ::protobuf::rt::LazyV2<RemoveCachePoolRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoveCachePoolRequestProto::new)
    }
}

impl ::protobuf::Clear for RemoveCachePoolRequestProto {
    fn clear(&mut self) {
        self.poolName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveCachePoolRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveCachePoolRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveCachePoolResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveCachePoolResponseProto {
    fn default() -> &'a RemoveCachePoolResponseProto {
        <RemoveCachePoolResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RemoveCachePoolResponseProto {
    pub fn new() -> RemoveCachePoolResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RemoveCachePoolResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveCachePoolResponseProto {
        RemoveCachePoolResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveCachePoolResponseProto>(
                "RemoveCachePoolResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RemoveCachePoolResponseProto {
        static instance: ::protobuf::rt::LazyV2<RemoveCachePoolResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoveCachePoolResponseProto::new)
    }
}

impl ::protobuf::Clear for RemoveCachePoolResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveCachePoolResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveCachePoolResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCachePoolsRequestProto {
    // message fields
    prevPoolName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListCachePoolsRequestProto {
    fn default() -> &'a ListCachePoolsRequestProto {
        <ListCachePoolsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ListCachePoolsRequestProto {
    pub fn new() -> ListCachePoolsRequestProto {
        ::std::default::Default::default()
    }

    // required string prevPoolName = 1;


    pub fn get_prevPoolName(&self) -> &str {
        match self.prevPoolName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_prevPoolName(&mut self) {
        self.prevPoolName.clear();
    }

    pub fn has_prevPoolName(&self) -> bool {
        self.prevPoolName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevPoolName(&mut self, v: ::std::string::String) {
        self.prevPoolName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prevPoolName(&mut self) -> &mut ::std::string::String {
        if self.prevPoolName.is_none() {
            self.prevPoolName.set_default();
        }
        self.prevPoolName.as_mut().unwrap()
    }

    // Take field
    pub fn take_prevPoolName(&mut self) -> ::std::string::String {
        self.prevPoolName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListCachePoolsRequestProto {
    fn is_initialized(&self) -> bool {
        if self.prevPoolName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.prevPoolName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.prevPoolName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.prevPoolName.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListCachePoolsRequestProto {
        ListCachePoolsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "prevPoolName",
                |m: &ListCachePoolsRequestProto| { &m.prevPoolName },
                |m: &mut ListCachePoolsRequestProto| { &mut m.prevPoolName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListCachePoolsRequestProto>(
                "ListCachePoolsRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListCachePoolsRequestProto {
        static instance: ::protobuf::rt::LazyV2<ListCachePoolsRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListCachePoolsRequestProto::new)
    }
}

impl ::protobuf::Clear for ListCachePoolsRequestProto {
    fn clear(&mut self) {
        self.prevPoolName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCachePoolsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCachePoolsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCachePoolsResponseProto {
    // message fields
    pub entries: ::protobuf::RepeatedField<CachePoolEntryProto>,
    hasMore: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListCachePoolsResponseProto {
    fn default() -> &'a ListCachePoolsResponseProto {
        <ListCachePoolsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ListCachePoolsResponseProto {
    pub fn new() -> ListCachePoolsResponseProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.CachePoolEntryProto entries = 1;


    pub fn get_entries(&self) -> &[CachePoolEntryProto] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<CachePoolEntryProto>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<CachePoolEntryProto> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<CachePoolEntryProto> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }

    // required bool hasMore = 2;


    pub fn get_hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }
    pub fn clear_hasMore(&mut self) {
        self.hasMore = ::std::option::Option::None;
    }

    pub fn has_hasMore(&self) -> bool {
        self.hasMore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMore(&mut self, v: bool) {
        self.hasMore = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ListCachePoolsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.hasMore.is_none() {
            return false;
        }
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasMore = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.hasMore {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.hasMore {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListCachePoolsResponseProto {
        ListCachePoolsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachePoolEntryProto>>(
                "entries",
                |m: &ListCachePoolsResponseProto| { &m.entries },
                |m: &mut ListCachePoolsResponseProto| { &mut m.entries },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasMore",
                |m: &ListCachePoolsResponseProto| { &m.hasMore },
                |m: &mut ListCachePoolsResponseProto| { &mut m.hasMore },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListCachePoolsResponseProto>(
                "ListCachePoolsResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListCachePoolsResponseProto {
        static instance: ::protobuf::rt::LazyV2<ListCachePoolsResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListCachePoolsResponseProto::new)
    }
}

impl ::protobuf::Clear for ListCachePoolsResponseProto {
    fn clear(&mut self) {
        self.entries.clear();
        self.hasMore = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCachePoolsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCachePoolsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CachePoolEntryProto {
    // message fields
    pub info: ::protobuf::SingularPtrField<CachePoolInfoProto>,
    pub stats: ::protobuf::SingularPtrField<CachePoolStatsProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CachePoolEntryProto {
    fn default() -> &'a CachePoolEntryProto {
        <CachePoolEntryProto as ::protobuf::Message>::default_instance()
    }
}

impl CachePoolEntryProto {
    pub fn new() -> CachePoolEntryProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CachePoolInfoProto info = 1;


    pub fn get_info(&self) -> &CachePoolInfoProto {
        self.info.as_ref().unwrap_or_else(|| <CachePoolInfoProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CachePoolInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CachePoolInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CachePoolInfoProto {
        self.info.take().unwrap_or_else(|| CachePoolInfoProto::new())
    }

    // required .hadoop.hdfs.CachePoolStatsProto stats = 2;


    pub fn get_stats(&self) -> &CachePoolStatsProto {
        self.stats.as_ref().unwrap_or_else(|| <CachePoolStatsProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: CachePoolStatsProto) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut CachePoolStatsProto {
        if self.stats.is_none() {
            self.stats.set_default();
        }
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> CachePoolStatsProto {
        self.stats.take().unwrap_or_else(|| CachePoolStatsProto::new())
    }
}

impl ::protobuf::Message for CachePoolEntryProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        if self.stats.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stats.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CachePoolEntryProto {
        CachePoolEntryProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachePoolInfoProto>>(
                "info",
                |m: &CachePoolEntryProto| { &m.info },
                |m: &mut CachePoolEntryProto| { &mut m.info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachePoolStatsProto>>(
                "stats",
                |m: &CachePoolEntryProto| { &m.stats },
                |m: &mut CachePoolEntryProto| { &mut m.stats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CachePoolEntryProto>(
                "CachePoolEntryProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CachePoolEntryProto {
        static instance: ::protobuf::rt::LazyV2<CachePoolEntryProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CachePoolEntryProto::new)
    }
}

impl ::protobuf::Clear for CachePoolEntryProto {
    fn clear(&mut self) {
        self.info.clear();
        self.stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CachePoolEntryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CachePoolEntryProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFileLinkInfoRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFileLinkInfoRequestProto {
    fn default() -> &'a GetFileLinkInfoRequestProto {
        <GetFileLinkInfoRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetFileLinkInfoRequestProto {
    pub fn new() -> GetFileLinkInfoRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetFileLinkInfoRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFileLinkInfoRequestProto {
        GetFileLinkInfoRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &GetFileLinkInfoRequestProto| { &m.src },
                |m: &mut GetFileLinkInfoRequestProto| { &mut m.src },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFileLinkInfoRequestProto>(
                "GetFileLinkInfoRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFileLinkInfoRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetFileLinkInfoRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFileLinkInfoRequestProto::new)
    }
}

impl ::protobuf::Clear for GetFileLinkInfoRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFileLinkInfoRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFileLinkInfoRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFileLinkInfoResponseProto {
    // message fields
    pub fs: ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFileLinkInfoResponseProto {
    fn default() -> &'a GetFileLinkInfoResponseProto {
        <GetFileLinkInfoResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetFileLinkInfoResponseProto {
    pub fn new() -> GetFileLinkInfoResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.HdfsFileStatusProto fs = 1;


    pub fn get_fs(&self) -> &super::hdfs::HdfsFileStatusProto {
        self.fs.as_ref().unwrap_or_else(|| <super::hdfs::HdfsFileStatusProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fs(&mut self) {
        self.fs.clear();
    }

    pub fn has_fs(&self) -> bool {
        self.fs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fs(&mut self, v: super::hdfs::HdfsFileStatusProto) {
        self.fs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fs(&mut self) -> &mut super::hdfs::HdfsFileStatusProto {
        if self.fs.is_none() {
            self.fs.set_default();
        }
        self.fs.as_mut().unwrap()
    }

    // Take field
    pub fn take_fs(&mut self) -> super::hdfs::HdfsFileStatusProto {
        self.fs.take().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::new())
    }
}

impl ::protobuf::Message for GetFileLinkInfoResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.fs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fs.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFileLinkInfoResponseProto {
        GetFileLinkInfoResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::HdfsFileStatusProto>>(
                "fs",
                |m: &GetFileLinkInfoResponseProto| { &m.fs },
                |m: &mut GetFileLinkInfoResponseProto| { &mut m.fs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFileLinkInfoResponseProto>(
                "GetFileLinkInfoResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFileLinkInfoResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetFileLinkInfoResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFileLinkInfoResponseProto::new)
    }
}

impl ::protobuf::Clear for GetFileLinkInfoResponseProto {
    fn clear(&mut self) {
        self.fs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFileLinkInfoResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFileLinkInfoResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetContentSummaryRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetContentSummaryRequestProto {
    fn default() -> &'a GetContentSummaryRequestProto {
        <GetContentSummaryRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetContentSummaryRequestProto {
    pub fn new() -> GetContentSummaryRequestProto {
        ::std::default::Default::default()
    }

    // required string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetContentSummaryRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetContentSummaryRequestProto {
        GetContentSummaryRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &GetContentSummaryRequestProto| { &m.path },
                |m: &mut GetContentSummaryRequestProto| { &mut m.path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetContentSummaryRequestProto>(
                "GetContentSummaryRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetContentSummaryRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetContentSummaryRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetContentSummaryRequestProto::new)
    }
}

impl ::protobuf::Clear for GetContentSummaryRequestProto {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetContentSummaryRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetContentSummaryRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetContentSummaryResponseProto {
    // message fields
    pub summary: ::protobuf::SingularPtrField<super::hdfs::ContentSummaryProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetContentSummaryResponseProto {
    fn default() -> &'a GetContentSummaryResponseProto {
        <GetContentSummaryResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetContentSummaryResponseProto {
    pub fn new() -> GetContentSummaryResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ContentSummaryProto summary = 1;


    pub fn get_summary(&self) -> &super::hdfs::ContentSummaryProto {
        self.summary.as_ref().unwrap_or_else(|| <super::hdfs::ContentSummaryProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_summary(&mut self) {
        self.summary.clear();
    }

    pub fn has_summary(&self) -> bool {
        self.summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: super::hdfs::ContentSummaryProto) {
        self.summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary(&mut self) -> &mut super::hdfs::ContentSummaryProto {
        if self.summary.is_none() {
            self.summary.set_default();
        }
        self.summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_summary(&mut self) -> super::hdfs::ContentSummaryProto {
        self.summary.take().unwrap_or_else(|| super::hdfs::ContentSummaryProto::new())
    }
}

impl ::protobuf::Message for GetContentSummaryResponseProto {
    fn is_initialized(&self) -> bool {
        if self.summary.is_none() {
            return false;
        }
        for v in &self.summary {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.summary)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.summary.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetContentSummaryResponseProto {
        GetContentSummaryResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ContentSummaryProto>>(
                "summary",
                |m: &GetContentSummaryResponseProto| { &m.summary },
                |m: &mut GetContentSummaryResponseProto| { &mut m.summary },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetContentSummaryResponseProto>(
                "GetContentSummaryResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetContentSummaryResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetContentSummaryResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetContentSummaryResponseProto::new)
    }
}

impl ::protobuf::Clear for GetContentSummaryResponseProto {
    fn clear(&mut self) {
        self.summary.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetContentSummaryResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetContentSummaryResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetQuotaUsageRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetQuotaUsageRequestProto {
    fn default() -> &'a GetQuotaUsageRequestProto {
        <GetQuotaUsageRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetQuotaUsageRequestProto {
    pub fn new() -> GetQuotaUsageRequestProto {
        ::std::default::Default::default()
    }

    // required string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetQuotaUsageRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetQuotaUsageRequestProto {
        GetQuotaUsageRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &GetQuotaUsageRequestProto| { &m.path },
                |m: &mut GetQuotaUsageRequestProto| { &mut m.path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetQuotaUsageRequestProto>(
                "GetQuotaUsageRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetQuotaUsageRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetQuotaUsageRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetQuotaUsageRequestProto::new)
    }
}

impl ::protobuf::Clear for GetQuotaUsageRequestProto {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetQuotaUsageRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetQuotaUsageRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetQuotaUsageResponseProto {
    // message fields
    pub usage: ::protobuf::SingularPtrField<super::hdfs::QuotaUsageProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetQuotaUsageResponseProto {
    fn default() -> &'a GetQuotaUsageResponseProto {
        <GetQuotaUsageResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetQuotaUsageResponseProto {
    pub fn new() -> GetQuotaUsageResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.QuotaUsageProto usage = 1;


    pub fn get_usage(&self) -> &super::hdfs::QuotaUsageProto {
        self.usage.as_ref().unwrap_or_else(|| <super::hdfs::QuotaUsageProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_usage(&mut self) {
        self.usage.clear();
    }

    pub fn has_usage(&self) -> bool {
        self.usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: super::hdfs::QuotaUsageProto) {
        self.usage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_usage(&mut self) -> &mut super::hdfs::QuotaUsageProto {
        if self.usage.is_none() {
            self.usage.set_default();
        }
        self.usage.as_mut().unwrap()
    }

    // Take field
    pub fn take_usage(&mut self) -> super::hdfs::QuotaUsageProto {
        self.usage.take().unwrap_or_else(|| super::hdfs::QuotaUsageProto::new())
    }
}

impl ::protobuf::Message for GetQuotaUsageResponseProto {
    fn is_initialized(&self) -> bool {
        if self.usage.is_none() {
            return false;
        }
        for v in &self.usage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.usage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.usage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.usage.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetQuotaUsageResponseProto {
        GetQuotaUsageResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::QuotaUsageProto>>(
                "usage",
                |m: &GetQuotaUsageResponseProto| { &m.usage },
                |m: &mut GetQuotaUsageResponseProto| { &mut m.usage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetQuotaUsageResponseProto>(
                "GetQuotaUsageResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetQuotaUsageResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetQuotaUsageResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetQuotaUsageResponseProto::new)
    }
}

impl ::protobuf::Clear for GetQuotaUsageResponseProto {
    fn clear(&mut self) {
        self.usage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetQuotaUsageResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetQuotaUsageResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetQuotaRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    namespaceQuota: ::std::option::Option<u64>,
    storagespaceQuota: ::std::option::Option<u64>,
    storageType: ::std::option::Option<super::hdfs::StorageTypeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetQuotaRequestProto {
    fn default() -> &'a SetQuotaRequestProto {
        <SetQuotaRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl SetQuotaRequestProto {
    pub fn new() -> SetQuotaRequestProto {
        ::std::default::Default::default()
    }

    // required string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 namespaceQuota = 2;


    pub fn get_namespaceQuota(&self) -> u64 {
        self.namespaceQuota.unwrap_or(0)
    }
    pub fn clear_namespaceQuota(&mut self) {
        self.namespaceQuota = ::std::option::Option::None;
    }

    pub fn has_namespaceQuota(&self) -> bool {
        self.namespaceQuota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespaceQuota(&mut self, v: u64) {
        self.namespaceQuota = ::std::option::Option::Some(v);
    }

    // required uint64 storagespaceQuota = 3;


    pub fn get_storagespaceQuota(&self) -> u64 {
        self.storagespaceQuota.unwrap_or(0)
    }
    pub fn clear_storagespaceQuota(&mut self) {
        self.storagespaceQuota = ::std::option::Option::None;
    }

    pub fn has_storagespaceQuota(&self) -> bool {
        self.storagespaceQuota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagespaceQuota(&mut self, v: u64) {
        self.storagespaceQuota = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.StorageTypeProto storageType = 4;


    pub fn get_storageType(&self) -> super::hdfs::StorageTypeProto {
        self.storageType.unwrap_or(super::hdfs::StorageTypeProto::DISK)
    }
    pub fn clear_storageType(&mut self) {
        self.storageType = ::std::option::Option::None;
    }

    pub fn has_storageType(&self) -> bool {
        self.storageType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageType(&mut self, v: super::hdfs::StorageTypeProto) {
        self.storageType = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SetQuotaRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        if self.namespaceQuota.is_none() {
            return false;
        }
        if self.storagespaceQuota.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.namespaceQuota = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.storagespaceQuota = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.storageType, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.namespaceQuota {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.storagespaceQuota {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.storageType {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.namespaceQuota {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.storagespaceQuota {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.storageType {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetQuotaRequestProto {
        SetQuotaRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &SetQuotaRequestProto| { &m.path },
                |m: &mut SetQuotaRequestProto| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "namespaceQuota",
                |m: &SetQuotaRequestProto| { &m.namespaceQuota },
                |m: &mut SetQuotaRequestProto| { &mut m.namespaceQuota },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "storagespaceQuota",
                |m: &SetQuotaRequestProto| { &m.storagespaceQuota },
                |m: &mut SetQuotaRequestProto| { &mut m.storagespaceQuota },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::StorageTypeProto>>(
                "storageType",
                |m: &SetQuotaRequestProto| { &m.storageType },
                |m: &mut SetQuotaRequestProto| { &mut m.storageType },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetQuotaRequestProto>(
                "SetQuotaRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetQuotaRequestProto {
        static instance: ::protobuf::rt::LazyV2<SetQuotaRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetQuotaRequestProto::new)
    }
}

impl ::protobuf::Clear for SetQuotaRequestProto {
    fn clear(&mut self) {
        self.path.clear();
        self.namespaceQuota = ::std::option::Option::None;
        self.storagespaceQuota = ::std::option::Option::None;
        self.storageType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetQuotaRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetQuotaRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetQuotaResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetQuotaResponseProto {
    fn default() -> &'a SetQuotaResponseProto {
        <SetQuotaResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl SetQuotaResponseProto {
    pub fn new() -> SetQuotaResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetQuotaResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetQuotaResponseProto {
        SetQuotaResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetQuotaResponseProto>(
                "SetQuotaResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetQuotaResponseProto {
        static instance: ::protobuf::rt::LazyV2<SetQuotaResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetQuotaResponseProto::new)
    }
}

impl ::protobuf::Clear for SetQuotaResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetQuotaResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetQuotaResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FsyncRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    client: ::protobuf::SingularField<::std::string::String>,
    lastBlockLength: ::std::option::Option<i64>,
    fileId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FsyncRequestProto {
    fn default() -> &'a FsyncRequestProto {
        <FsyncRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl FsyncRequestProto {
    pub fn new() -> FsyncRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string client = 2;


    pub fn get_client(&self) -> &str {
        match self.client.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_client(&mut self) {
        self.client.clear();
    }

    pub fn has_client(&self) -> bool {
        self.client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: ::std::string::String) {
        self.client = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client(&mut self) -> &mut ::std::string::String {
        if self.client.is_none() {
            self.client.set_default();
        }
        self.client.as_mut().unwrap()
    }

    // Take field
    pub fn take_client(&mut self) -> ::std::string::String {
        self.client.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional sint64 lastBlockLength = 3;


    pub fn get_lastBlockLength(&self) -> i64 {
        self.lastBlockLength.unwrap_or(-1i64)
    }
    pub fn clear_lastBlockLength(&mut self) {
        self.lastBlockLength = ::std::option::Option::None;
    }

    pub fn has_lastBlockLength(&self) -> bool {
        self.lastBlockLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastBlockLength(&mut self, v: i64) {
        self.lastBlockLength = ::std::option::Option::Some(v);
    }

    // optional uint64 fileId = 4;


    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }
    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for FsyncRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.client.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.client)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.lastBlockLength = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.client.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastBlockLength {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.client.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.lastBlockLength {
            os.write_sint64(3, v)?;
        }
        if let Some(v) = self.fileId {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FsyncRequestProto {
        FsyncRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &FsyncRequestProto| { &m.src },
                |m: &mut FsyncRequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client",
                |m: &FsyncRequestProto| { &m.client },
                |m: &mut FsyncRequestProto| { &mut m.client },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "lastBlockLength",
                |m: &FsyncRequestProto| { &m.lastBlockLength },
                |m: &mut FsyncRequestProto| { &mut m.lastBlockLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fileId",
                |m: &FsyncRequestProto| { &m.fileId },
                |m: &mut FsyncRequestProto| { &mut m.fileId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FsyncRequestProto>(
                "FsyncRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FsyncRequestProto {
        static instance: ::protobuf::rt::LazyV2<FsyncRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FsyncRequestProto::new)
    }
}

impl ::protobuf::Clear for FsyncRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.client.clear();
        self.lastBlockLength = ::std::option::Option::None;
        self.fileId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FsyncRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FsyncRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FsyncResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FsyncResponseProto {
    fn default() -> &'a FsyncResponseProto {
        <FsyncResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl FsyncResponseProto {
    pub fn new() -> FsyncResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FsyncResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FsyncResponseProto {
        FsyncResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FsyncResponseProto>(
                "FsyncResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FsyncResponseProto {
        static instance: ::protobuf::rt::LazyV2<FsyncResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FsyncResponseProto::new)
    }
}

impl ::protobuf::Clear for FsyncResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FsyncResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FsyncResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetTimesRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    mtime: ::std::option::Option<u64>,
    atime: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetTimesRequestProto {
    fn default() -> &'a SetTimesRequestProto {
        <SetTimesRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl SetTimesRequestProto {
    pub fn new() -> SetTimesRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 mtime = 2;


    pub fn get_mtime(&self) -> u64 {
        self.mtime.unwrap_or(0)
    }
    pub fn clear_mtime(&mut self) {
        self.mtime = ::std::option::Option::None;
    }

    pub fn has_mtime(&self) -> bool {
        self.mtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mtime(&mut self, v: u64) {
        self.mtime = ::std::option::Option::Some(v);
    }

    // required uint64 atime = 3;


    pub fn get_atime(&self) -> u64 {
        self.atime.unwrap_or(0)
    }
    pub fn clear_atime(&mut self) {
        self.atime = ::std::option::Option::None;
    }

    pub fn has_atime(&self) -> bool {
        self.atime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_atime(&mut self, v: u64) {
        self.atime = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SetTimesRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.mtime.is_none() {
            return false;
        }
        if self.atime.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mtime = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.atime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mtime {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.atime {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.mtime {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.atime {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetTimesRequestProto {
        SetTimesRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &SetTimesRequestProto| { &m.src },
                |m: &mut SetTimesRequestProto| { &mut m.src },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "mtime",
                |m: &SetTimesRequestProto| { &m.mtime },
                |m: &mut SetTimesRequestProto| { &mut m.mtime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "atime",
                |m: &SetTimesRequestProto| { &m.atime },
                |m: &mut SetTimesRequestProto| { &mut m.atime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetTimesRequestProto>(
                "SetTimesRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetTimesRequestProto {
        static instance: ::protobuf::rt::LazyV2<SetTimesRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetTimesRequestProto::new)
    }
}

impl ::protobuf::Clear for SetTimesRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.mtime = ::std::option::Option::None;
        self.atime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetTimesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetTimesRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetTimesResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetTimesResponseProto {
    fn default() -> &'a SetTimesResponseProto {
        <SetTimesResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl SetTimesResponseProto {
    pub fn new() -> SetTimesResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetTimesResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetTimesResponseProto {
        SetTimesResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetTimesResponseProto>(
                "SetTimesResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetTimesResponseProto {
        static instance: ::protobuf::rt::LazyV2<SetTimesResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetTimesResponseProto::new)
    }
}

impl ::protobuf::Clear for SetTimesResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetTimesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetTimesResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSymlinkRequestProto {
    // message fields
    target: ::protobuf::SingularField<::std::string::String>,
    link: ::protobuf::SingularField<::std::string::String>,
    pub dirPerm: ::protobuf::SingularPtrField<super::acl::FsPermissionProto>,
    createParent: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateSymlinkRequestProto {
    fn default() -> &'a CreateSymlinkRequestProto {
        <CreateSymlinkRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl CreateSymlinkRequestProto {
    pub fn new() -> CreateSymlinkRequestProto {
        ::std::default::Default::default()
    }

    // required string target = 1;


    pub fn get_target(&self) -> &str {
        match self.target.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ::std::string::String) {
        self.target = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut ::std::string::String {
        if self.target.is_none() {
            self.target.set_default();
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> ::std::string::String {
        self.target.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string link = 2;


    pub fn get_link(&self) -> &str {
        match self.link.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_link(&mut self) {
        self.link.clear();
    }

    pub fn has_link(&self) -> bool {
        self.link.is_some()
    }

    // Param is passed by value, moved
    pub fn set_link(&mut self, v: ::std::string::String) {
        self.link = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link(&mut self) -> &mut ::std::string::String {
        if self.link.is_none() {
            self.link.set_default();
        }
        self.link.as_mut().unwrap()
    }

    // Take field
    pub fn take_link(&mut self) -> ::std::string::String {
        self.link.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.FsPermissionProto dirPerm = 3;


    pub fn get_dirPerm(&self) -> &super::acl::FsPermissionProto {
        self.dirPerm.as_ref().unwrap_or_else(|| <super::acl::FsPermissionProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dirPerm(&mut self) {
        self.dirPerm.clear();
    }

    pub fn has_dirPerm(&self) -> bool {
        self.dirPerm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dirPerm(&mut self, v: super::acl::FsPermissionProto) {
        self.dirPerm = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dirPerm(&mut self) -> &mut super::acl::FsPermissionProto {
        if self.dirPerm.is_none() {
            self.dirPerm.set_default();
        }
        self.dirPerm.as_mut().unwrap()
    }

    // Take field
    pub fn take_dirPerm(&mut self) -> super::acl::FsPermissionProto {
        self.dirPerm.take().unwrap_or_else(|| super::acl::FsPermissionProto::new())
    }

    // required bool createParent = 4;


    pub fn get_createParent(&self) -> bool {
        self.createParent.unwrap_or(false)
    }
    pub fn clear_createParent(&mut self) {
        self.createParent = ::std::option::Option::None;
    }

    pub fn has_createParent(&self) -> bool {
        self.createParent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createParent(&mut self, v: bool) {
        self.createParent = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CreateSymlinkRequestProto {
    fn is_initialized(&self) -> bool {
        if self.target.is_none() {
            return false;
        }
        if self.link.is_none() {
            return false;
        }
        if self.dirPerm.is_none() {
            return false;
        }
        if self.createParent.is_none() {
            return false;
        }
        for v in &self.dirPerm {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.target)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.link)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dirPerm)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.createParent = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.target.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.link.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.dirPerm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.createParent {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.target.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.link.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.dirPerm.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.createParent {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateSymlinkRequestProto {
        CreateSymlinkRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "target",
                |m: &CreateSymlinkRequestProto| { &m.target },
                |m: &mut CreateSymlinkRequestProto| { &mut m.target },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "link",
                |m: &CreateSymlinkRequestProto| { &m.link },
                |m: &mut CreateSymlinkRequestProto| { &mut m.link },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::acl::FsPermissionProto>>(
                "dirPerm",
                |m: &CreateSymlinkRequestProto| { &m.dirPerm },
                |m: &mut CreateSymlinkRequestProto| { &mut m.dirPerm },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "createParent",
                |m: &CreateSymlinkRequestProto| { &m.createParent },
                |m: &mut CreateSymlinkRequestProto| { &mut m.createParent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateSymlinkRequestProto>(
                "CreateSymlinkRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateSymlinkRequestProto {
        static instance: ::protobuf::rt::LazyV2<CreateSymlinkRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateSymlinkRequestProto::new)
    }
}

impl ::protobuf::Clear for CreateSymlinkRequestProto {
    fn clear(&mut self) {
        self.target.clear();
        self.link.clear();
        self.dirPerm.clear();
        self.createParent = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSymlinkRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSymlinkRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSymlinkResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateSymlinkResponseProto {
    fn default() -> &'a CreateSymlinkResponseProto {
        <CreateSymlinkResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl CreateSymlinkResponseProto {
    pub fn new() -> CreateSymlinkResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CreateSymlinkResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateSymlinkResponseProto {
        CreateSymlinkResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateSymlinkResponseProto>(
                "CreateSymlinkResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateSymlinkResponseProto {
        static instance: ::protobuf::rt::LazyV2<CreateSymlinkResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateSymlinkResponseProto::new)
    }
}

impl ::protobuf::Clear for CreateSymlinkResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSymlinkResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSymlinkResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLinkTargetRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLinkTargetRequestProto {
    fn default() -> &'a GetLinkTargetRequestProto {
        <GetLinkTargetRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetLinkTargetRequestProto {
    pub fn new() -> GetLinkTargetRequestProto {
        ::std::default::Default::default()
    }

    // required string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetLinkTargetRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLinkTargetRequestProto {
        GetLinkTargetRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &GetLinkTargetRequestProto| { &m.path },
                |m: &mut GetLinkTargetRequestProto| { &mut m.path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetLinkTargetRequestProto>(
                "GetLinkTargetRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetLinkTargetRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetLinkTargetRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetLinkTargetRequestProto::new)
    }
}

impl ::protobuf::Clear for GetLinkTargetRequestProto {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLinkTargetRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLinkTargetRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLinkTargetResponseProto {
    // message fields
    targetPath: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLinkTargetResponseProto {
    fn default() -> &'a GetLinkTargetResponseProto {
        <GetLinkTargetResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetLinkTargetResponseProto {
    pub fn new() -> GetLinkTargetResponseProto {
        ::std::default::Default::default()
    }

    // optional string targetPath = 1;


    pub fn get_targetPath(&self) -> &str {
        match self.targetPath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_targetPath(&mut self) {
        self.targetPath.clear();
    }

    pub fn has_targetPath(&self) -> bool {
        self.targetPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetPath(&mut self, v: ::std::string::String) {
        self.targetPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetPath(&mut self) -> &mut ::std::string::String {
        if self.targetPath.is_none() {
            self.targetPath.set_default();
        }
        self.targetPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetPath(&mut self) -> ::std::string::String {
        self.targetPath.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetLinkTargetResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.targetPath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.targetPath.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.targetPath.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLinkTargetResponseProto {
        GetLinkTargetResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "targetPath",
                |m: &GetLinkTargetResponseProto| { &m.targetPath },
                |m: &mut GetLinkTargetResponseProto| { &mut m.targetPath },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetLinkTargetResponseProto>(
                "GetLinkTargetResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetLinkTargetResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetLinkTargetResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetLinkTargetResponseProto::new)
    }
}

impl ::protobuf::Clear for GetLinkTargetResponseProto {
    fn clear(&mut self) {
        self.targetPath.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLinkTargetResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLinkTargetResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateBlockForPipelineRequestProto {
    // message fields
    pub block: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateBlockForPipelineRequestProto {
    fn default() -> &'a UpdateBlockForPipelineRequestProto {
        <UpdateBlockForPipelineRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl UpdateBlockForPipelineRequestProto {
    pub fn new() -> UpdateBlockForPipelineRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ExtendedBlockProto block = 1;


    pub fn get_block(&self) -> &super::hdfs::ExtendedBlockProto {
        self.block.as_ref().unwrap_or_else(|| <super::hdfs::ExtendedBlockProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    // required string clientName = 2;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateBlockForPipelineRequestProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateBlockForPipelineRequestProto {
        UpdateBlockForPipelineRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                "block",
                |m: &UpdateBlockForPipelineRequestProto| { &m.block },
                |m: &mut UpdateBlockForPipelineRequestProto| { &mut m.block },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientName",
                |m: &UpdateBlockForPipelineRequestProto| { &m.clientName },
                |m: &mut UpdateBlockForPipelineRequestProto| { &mut m.clientName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateBlockForPipelineRequestProto>(
                "UpdateBlockForPipelineRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateBlockForPipelineRequestProto {
        static instance: ::protobuf::rt::LazyV2<UpdateBlockForPipelineRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateBlockForPipelineRequestProto::new)
    }
}

impl ::protobuf::Clear for UpdateBlockForPipelineRequestProto {
    fn clear(&mut self) {
        self.block.clear();
        self.clientName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateBlockForPipelineRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateBlockForPipelineRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateBlockForPipelineResponseProto {
    // message fields
    pub block: ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateBlockForPipelineResponseProto {
    fn default() -> &'a UpdateBlockForPipelineResponseProto {
        <UpdateBlockForPipelineResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl UpdateBlockForPipelineResponseProto {
    pub fn new() -> UpdateBlockForPipelineResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.LocatedBlockProto block = 1;


    pub fn get_block(&self) -> &super::hdfs::LocatedBlockProto {
        self.block.as_ref().unwrap_or_else(|| <super::hdfs::LocatedBlockProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::LocatedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::LocatedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::LocatedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::LocatedBlockProto::new())
    }
}

impl ::protobuf::Message for UpdateBlockForPipelineResponseProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateBlockForPipelineResponseProto {
        UpdateBlockForPipelineResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlockProto>>(
                "block",
                |m: &UpdateBlockForPipelineResponseProto| { &m.block },
                |m: &mut UpdateBlockForPipelineResponseProto| { &mut m.block },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateBlockForPipelineResponseProto>(
                "UpdateBlockForPipelineResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateBlockForPipelineResponseProto {
        static instance: ::protobuf::rt::LazyV2<UpdateBlockForPipelineResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateBlockForPipelineResponseProto::new)
    }
}

impl ::protobuf::Clear for UpdateBlockForPipelineResponseProto {
    fn clear(&mut self) {
        self.block.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateBlockForPipelineResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateBlockForPipelineResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdatePipelineRequestProto {
    // message fields
    clientName: ::protobuf::SingularField<::std::string::String>,
    pub oldBlock: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    pub newBlock: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    pub newNodes: ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto>,
    pub storageIDs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdatePipelineRequestProto {
    fn default() -> &'a UpdatePipelineRequestProto {
        <UpdatePipelineRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl UpdatePipelineRequestProto {
    pub fn new() -> UpdatePipelineRequestProto {
        ::std::default::Default::default()
    }

    // required string clientName = 1;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.ExtendedBlockProto oldBlock = 2;


    pub fn get_oldBlock(&self) -> &super::hdfs::ExtendedBlockProto {
        self.oldBlock.as_ref().unwrap_or_else(|| <super::hdfs::ExtendedBlockProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_oldBlock(&mut self) {
        self.oldBlock.clear();
    }

    pub fn has_oldBlock(&self) -> bool {
        self.oldBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oldBlock(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.oldBlock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oldBlock(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.oldBlock.is_none() {
            self.oldBlock.set_default();
        }
        self.oldBlock.as_mut().unwrap()
    }

    // Take field
    pub fn take_oldBlock(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.oldBlock.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    // required .hadoop.hdfs.ExtendedBlockProto newBlock = 3;


    pub fn get_newBlock(&self) -> &super::hdfs::ExtendedBlockProto {
        self.newBlock.as_ref().unwrap_or_else(|| <super::hdfs::ExtendedBlockProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_newBlock(&mut self) {
        self.newBlock.clear();
    }

    pub fn has_newBlock(&self) -> bool {
        self.newBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newBlock(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.newBlock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newBlock(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.newBlock.is_none() {
            self.newBlock.set_default();
        }
        self.newBlock.as_mut().unwrap()
    }

    // Take field
    pub fn take_newBlock(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.newBlock.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    // repeated .hadoop.hdfs.DatanodeIDProto newNodes = 4;


    pub fn get_newNodes(&self) -> &[super::hdfs::DatanodeIDProto] {
        &self.newNodes
    }
    pub fn clear_newNodes(&mut self) {
        self.newNodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_newNodes(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto>) {
        self.newNodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_newNodes(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto> {
        &mut self.newNodes
    }

    // Take field
    pub fn take_newNodes(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto> {
        ::std::mem::replace(&mut self.newNodes, ::protobuf::RepeatedField::new())
    }

    // repeated string storageIDs = 5;


    pub fn get_storageIDs(&self) -> &[::std::string::String] {
        &self.storageIDs
    }
    pub fn clear_storageIDs(&mut self) {
        self.storageIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageIDs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.storageIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageIDs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.storageIDs
    }

    // Take field
    pub fn take_storageIDs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.storageIDs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UpdatePipelineRequestProto {
    fn is_initialized(&self) -> bool {
        if self.clientName.is_none() {
            return false;
        }
        if self.oldBlock.is_none() {
            return false;
        }
        if self.newBlock.is_none() {
            return false;
        }
        for v in &self.oldBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.newBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.newNodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.oldBlock)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.newBlock)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.newNodes)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.storageIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.oldBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.newBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.newNodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.storageIDs {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.oldBlock.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.newBlock.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.newNodes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.storageIDs {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdatePipelineRequestProto {
        UpdatePipelineRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientName",
                |m: &UpdatePipelineRequestProto| { &m.clientName },
                |m: &mut UpdatePipelineRequestProto| { &mut m.clientName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                "oldBlock",
                |m: &UpdatePipelineRequestProto| { &m.oldBlock },
                |m: &mut UpdatePipelineRequestProto| { &mut m.oldBlock },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                "newBlock",
                |m: &UpdatePipelineRequestProto| { &m.newBlock },
                |m: &mut UpdatePipelineRequestProto| { &mut m.newBlock },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeIDProto>>(
                "newNodes",
                |m: &UpdatePipelineRequestProto| { &m.newNodes },
                |m: &mut UpdatePipelineRequestProto| { &mut m.newNodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storageIDs",
                |m: &UpdatePipelineRequestProto| { &m.storageIDs },
                |m: &mut UpdatePipelineRequestProto| { &mut m.storageIDs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdatePipelineRequestProto>(
                "UpdatePipelineRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdatePipelineRequestProto {
        static instance: ::protobuf::rt::LazyV2<UpdatePipelineRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdatePipelineRequestProto::new)
    }
}

impl ::protobuf::Clear for UpdatePipelineRequestProto {
    fn clear(&mut self) {
        self.clientName.clear();
        self.oldBlock.clear();
        self.newBlock.clear();
        self.newNodes.clear();
        self.storageIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdatePipelineRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdatePipelineRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdatePipelineResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdatePipelineResponseProto {
    fn default() -> &'a UpdatePipelineResponseProto {
        <UpdatePipelineResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl UpdatePipelineResponseProto {
    pub fn new() -> UpdatePipelineResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdatePipelineResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdatePipelineResponseProto {
        UpdatePipelineResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdatePipelineResponseProto>(
                "UpdatePipelineResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdatePipelineResponseProto {
        static instance: ::protobuf::rt::LazyV2<UpdatePipelineResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdatePipelineResponseProto::new)
    }
}

impl ::protobuf::Clear for UpdatePipelineResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdatePipelineResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdatePipelineResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetBalancerBandwidthRequestProto {
    // message fields
    bandwidth: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetBalancerBandwidthRequestProto {
    fn default() -> &'a SetBalancerBandwidthRequestProto {
        <SetBalancerBandwidthRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl SetBalancerBandwidthRequestProto {
    pub fn new() -> SetBalancerBandwidthRequestProto {
        ::std::default::Default::default()
    }

    // required int64 bandwidth = 1;


    pub fn get_bandwidth(&self) -> i64 {
        self.bandwidth.unwrap_or(0)
    }
    pub fn clear_bandwidth(&mut self) {
        self.bandwidth = ::std::option::Option::None;
    }

    pub fn has_bandwidth(&self) -> bool {
        self.bandwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bandwidth(&mut self, v: i64) {
        self.bandwidth = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SetBalancerBandwidthRequestProto {
    fn is_initialized(&self) -> bool {
        if self.bandwidth.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bandwidth = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bandwidth {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bandwidth {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetBalancerBandwidthRequestProto {
        SetBalancerBandwidthRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "bandwidth",
                |m: &SetBalancerBandwidthRequestProto| { &m.bandwidth },
                |m: &mut SetBalancerBandwidthRequestProto| { &mut m.bandwidth },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetBalancerBandwidthRequestProto>(
                "SetBalancerBandwidthRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetBalancerBandwidthRequestProto {
        static instance: ::protobuf::rt::LazyV2<SetBalancerBandwidthRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetBalancerBandwidthRequestProto::new)
    }
}

impl ::protobuf::Clear for SetBalancerBandwidthRequestProto {
    fn clear(&mut self) {
        self.bandwidth = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetBalancerBandwidthRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetBalancerBandwidthRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetBalancerBandwidthResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetBalancerBandwidthResponseProto {
    fn default() -> &'a SetBalancerBandwidthResponseProto {
        <SetBalancerBandwidthResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl SetBalancerBandwidthResponseProto {
    pub fn new() -> SetBalancerBandwidthResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetBalancerBandwidthResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetBalancerBandwidthResponseProto {
        SetBalancerBandwidthResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetBalancerBandwidthResponseProto>(
                "SetBalancerBandwidthResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetBalancerBandwidthResponseProto {
        static instance: ::protobuf::rt::LazyV2<SetBalancerBandwidthResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetBalancerBandwidthResponseProto::new)
    }
}

impl ::protobuf::Clear for SetBalancerBandwidthResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetBalancerBandwidthResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetBalancerBandwidthResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDataEncryptionKeyRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDataEncryptionKeyRequestProto {
    fn default() -> &'a GetDataEncryptionKeyRequestProto {
        <GetDataEncryptionKeyRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetDataEncryptionKeyRequestProto {
    pub fn new() -> GetDataEncryptionKeyRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetDataEncryptionKeyRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDataEncryptionKeyRequestProto {
        GetDataEncryptionKeyRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDataEncryptionKeyRequestProto>(
                "GetDataEncryptionKeyRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetDataEncryptionKeyRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetDataEncryptionKeyRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetDataEncryptionKeyRequestProto::new)
    }
}

impl ::protobuf::Clear for GetDataEncryptionKeyRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDataEncryptionKeyRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDataEncryptionKeyRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDataEncryptionKeyResponseProto {
    // message fields
    pub dataEncryptionKey: ::protobuf::SingularPtrField<super::hdfs::DataEncryptionKeyProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDataEncryptionKeyResponseProto {
    fn default() -> &'a GetDataEncryptionKeyResponseProto {
        <GetDataEncryptionKeyResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetDataEncryptionKeyResponseProto {
    pub fn new() -> GetDataEncryptionKeyResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.DataEncryptionKeyProto dataEncryptionKey = 1;


    pub fn get_dataEncryptionKey(&self) -> &super::hdfs::DataEncryptionKeyProto {
        self.dataEncryptionKey.as_ref().unwrap_or_else(|| <super::hdfs::DataEncryptionKeyProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dataEncryptionKey(&mut self) {
        self.dataEncryptionKey.clear();
    }

    pub fn has_dataEncryptionKey(&self) -> bool {
        self.dataEncryptionKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dataEncryptionKey(&mut self, v: super::hdfs::DataEncryptionKeyProto) {
        self.dataEncryptionKey = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataEncryptionKey(&mut self) -> &mut super::hdfs::DataEncryptionKeyProto {
        if self.dataEncryptionKey.is_none() {
            self.dataEncryptionKey.set_default();
        }
        self.dataEncryptionKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_dataEncryptionKey(&mut self) -> super::hdfs::DataEncryptionKeyProto {
        self.dataEncryptionKey.take().unwrap_or_else(|| super::hdfs::DataEncryptionKeyProto::new())
    }
}

impl ::protobuf::Message for GetDataEncryptionKeyResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.dataEncryptionKey {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dataEncryptionKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dataEncryptionKey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dataEncryptionKey.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDataEncryptionKeyResponseProto {
        GetDataEncryptionKeyResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DataEncryptionKeyProto>>(
                "dataEncryptionKey",
                |m: &GetDataEncryptionKeyResponseProto| { &m.dataEncryptionKey },
                |m: &mut GetDataEncryptionKeyResponseProto| { &mut m.dataEncryptionKey },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDataEncryptionKeyResponseProto>(
                "GetDataEncryptionKeyResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetDataEncryptionKeyResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetDataEncryptionKeyResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetDataEncryptionKeyResponseProto::new)
    }
}

impl ::protobuf::Clear for GetDataEncryptionKeyResponseProto {
    fn clear(&mut self) {
        self.dataEncryptionKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDataEncryptionKeyResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDataEncryptionKeyResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    snapshotName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateSnapshotRequestProto {
    fn default() -> &'a CreateSnapshotRequestProto {
        <CreateSnapshotRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl CreateSnapshotRequestProto {
    pub fn new() -> CreateSnapshotRequestProto {
        ::std::default::Default::default()
    }

    // required string snapshotRoot = 1;


    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string snapshotName = 2;


    pub fn get_snapshotName(&self) -> &str {
        match self.snapshotName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotName(&mut self) {
        self.snapshotName.clear();
    }

    pub fn has_snapshotName(&self) -> bool {
        self.snapshotName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotName(&mut self, v: ::std::string::String) {
        self.snapshotName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotName(&mut self) -> &mut ::std::string::String {
        if self.snapshotName.is_none() {
            self.snapshotName.set_default();
        }
        self.snapshotName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotName(&mut self) -> ::std::string::String {
        self.snapshotName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.snapshotName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.snapshotName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateSnapshotRequestProto {
        CreateSnapshotRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snapshotRoot",
                |m: &CreateSnapshotRequestProto| { &m.snapshotRoot },
                |m: &mut CreateSnapshotRequestProto| { &mut m.snapshotRoot },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snapshotName",
                |m: &CreateSnapshotRequestProto| { &m.snapshotName },
                |m: &mut CreateSnapshotRequestProto| { &mut m.snapshotName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateSnapshotRequestProto>(
                "CreateSnapshotRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateSnapshotRequestProto {
        static instance: ::protobuf::rt::LazyV2<CreateSnapshotRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateSnapshotRequestProto::new)
    }
}

impl ::protobuf::Clear for CreateSnapshotRequestProto {
    fn clear(&mut self) {
        self.snapshotRoot.clear();
        self.snapshotName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSnapshotRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSnapshotResponseProto {
    // message fields
    snapshotPath: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateSnapshotResponseProto {
    fn default() -> &'a CreateSnapshotResponseProto {
        <CreateSnapshotResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl CreateSnapshotResponseProto {
    pub fn new() -> CreateSnapshotResponseProto {
        ::std::default::Default::default()
    }

    // required string snapshotPath = 1;


    pub fn get_snapshotPath(&self) -> &str {
        match self.snapshotPath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotPath(&mut self) {
        self.snapshotPath.clear();
    }

    pub fn has_snapshotPath(&self) -> bool {
        self.snapshotPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotPath(&mut self, v: ::std::string::String) {
        self.snapshotPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotPath(&mut self) -> &mut ::std::string::String {
        if self.snapshotPath.is_none() {
            self.snapshotPath.set_default();
        }
        self.snapshotPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotPath(&mut self) -> ::std::string::String {
        self.snapshotPath.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotPath.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotPath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotPath.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotPath.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateSnapshotResponseProto {
        CreateSnapshotResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snapshotPath",
                |m: &CreateSnapshotResponseProto| { &m.snapshotPath },
                |m: &mut CreateSnapshotResponseProto| { &mut m.snapshotPath },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateSnapshotResponseProto>(
                "CreateSnapshotResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateSnapshotResponseProto {
        static instance: ::protobuf::rt::LazyV2<CreateSnapshotResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateSnapshotResponseProto::new)
    }
}

impl ::protobuf::Clear for CreateSnapshotResponseProto {
    fn clear(&mut self) {
        self.snapshotPath.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSnapshotResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenameSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    snapshotOldName: ::protobuf::SingularField<::std::string::String>,
    snapshotNewName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RenameSnapshotRequestProto {
    fn default() -> &'a RenameSnapshotRequestProto {
        <RenameSnapshotRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RenameSnapshotRequestProto {
    pub fn new() -> RenameSnapshotRequestProto {
        ::std::default::Default::default()
    }

    // required string snapshotRoot = 1;


    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string snapshotOldName = 2;


    pub fn get_snapshotOldName(&self) -> &str {
        match self.snapshotOldName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotOldName(&mut self) {
        self.snapshotOldName.clear();
    }

    pub fn has_snapshotOldName(&self) -> bool {
        self.snapshotOldName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotOldName(&mut self, v: ::std::string::String) {
        self.snapshotOldName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotOldName(&mut self) -> &mut ::std::string::String {
        if self.snapshotOldName.is_none() {
            self.snapshotOldName.set_default();
        }
        self.snapshotOldName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotOldName(&mut self) -> ::std::string::String {
        self.snapshotOldName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string snapshotNewName = 3;


    pub fn get_snapshotNewName(&self) -> &str {
        match self.snapshotNewName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotNewName(&mut self) {
        self.snapshotNewName.clear();
    }

    pub fn has_snapshotNewName(&self) -> bool {
        self.snapshotNewName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotNewName(&mut self, v: ::std::string::String) {
        self.snapshotNewName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotNewName(&mut self) -> &mut ::std::string::String {
        if self.snapshotNewName.is_none() {
            self.snapshotNewName.set_default();
        }
        self.snapshotNewName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotNewName(&mut self) -> ::std::string::String {
        self.snapshotNewName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for RenameSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        if self.snapshotOldName.is_none() {
            return false;
        }
        if self.snapshotNewName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotOldName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotNewName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.snapshotOldName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.snapshotNewName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.snapshotOldName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.snapshotNewName.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RenameSnapshotRequestProto {
        RenameSnapshotRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snapshotRoot",
                |m: &RenameSnapshotRequestProto| { &m.snapshotRoot },
                |m: &mut RenameSnapshotRequestProto| { &mut m.snapshotRoot },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snapshotOldName",
                |m: &RenameSnapshotRequestProto| { &m.snapshotOldName },
                |m: &mut RenameSnapshotRequestProto| { &mut m.snapshotOldName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snapshotNewName",
                |m: &RenameSnapshotRequestProto| { &m.snapshotNewName },
                |m: &mut RenameSnapshotRequestProto| { &mut m.snapshotNewName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RenameSnapshotRequestProto>(
                "RenameSnapshotRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RenameSnapshotRequestProto {
        static instance: ::protobuf::rt::LazyV2<RenameSnapshotRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RenameSnapshotRequestProto::new)
    }
}

impl ::protobuf::Clear for RenameSnapshotRequestProto {
    fn clear(&mut self) {
        self.snapshotRoot.clear();
        self.snapshotOldName.clear();
        self.snapshotNewName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenameSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameSnapshotRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenameSnapshotResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RenameSnapshotResponseProto {
    fn default() -> &'a RenameSnapshotResponseProto {
        <RenameSnapshotResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RenameSnapshotResponseProto {
    pub fn new() -> RenameSnapshotResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RenameSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RenameSnapshotResponseProto {
        RenameSnapshotResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RenameSnapshotResponseProto>(
                "RenameSnapshotResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RenameSnapshotResponseProto {
        static instance: ::protobuf::rt::LazyV2<RenameSnapshotResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RenameSnapshotResponseProto::new)
    }
}

impl ::protobuf::Clear for RenameSnapshotResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenameSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameSnapshotResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AllowSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AllowSnapshotRequestProto {
    fn default() -> &'a AllowSnapshotRequestProto {
        <AllowSnapshotRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl AllowSnapshotRequestProto {
    pub fn new() -> AllowSnapshotRequestProto {
        ::std::default::Default::default()
    }

    // required string snapshotRoot = 1;


    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for AllowSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AllowSnapshotRequestProto {
        AllowSnapshotRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snapshotRoot",
                |m: &AllowSnapshotRequestProto| { &m.snapshotRoot },
                |m: &mut AllowSnapshotRequestProto| { &mut m.snapshotRoot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AllowSnapshotRequestProto>(
                "AllowSnapshotRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AllowSnapshotRequestProto {
        static instance: ::protobuf::rt::LazyV2<AllowSnapshotRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AllowSnapshotRequestProto::new)
    }
}

impl ::protobuf::Clear for AllowSnapshotRequestProto {
    fn clear(&mut self) {
        self.snapshotRoot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AllowSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllowSnapshotRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AllowSnapshotResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AllowSnapshotResponseProto {
    fn default() -> &'a AllowSnapshotResponseProto {
        <AllowSnapshotResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl AllowSnapshotResponseProto {
    pub fn new() -> AllowSnapshotResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AllowSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AllowSnapshotResponseProto {
        AllowSnapshotResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AllowSnapshotResponseProto>(
                "AllowSnapshotResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AllowSnapshotResponseProto {
        static instance: ::protobuf::rt::LazyV2<AllowSnapshotResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AllowSnapshotResponseProto::new)
    }
}

impl ::protobuf::Clear for AllowSnapshotResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AllowSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllowSnapshotResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisallowSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisallowSnapshotRequestProto {
    fn default() -> &'a DisallowSnapshotRequestProto {
        <DisallowSnapshotRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl DisallowSnapshotRequestProto {
    pub fn new() -> DisallowSnapshotRequestProto {
        ::std::default::Default::default()
    }

    // required string snapshotRoot = 1;


    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DisallowSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisallowSnapshotRequestProto {
        DisallowSnapshotRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snapshotRoot",
                |m: &DisallowSnapshotRequestProto| { &m.snapshotRoot },
                |m: &mut DisallowSnapshotRequestProto| { &mut m.snapshotRoot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DisallowSnapshotRequestProto>(
                "DisallowSnapshotRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DisallowSnapshotRequestProto {
        static instance: ::protobuf::rt::LazyV2<DisallowSnapshotRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DisallowSnapshotRequestProto::new)
    }
}

impl ::protobuf::Clear for DisallowSnapshotRequestProto {
    fn clear(&mut self) {
        self.snapshotRoot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisallowSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisallowSnapshotRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisallowSnapshotResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisallowSnapshotResponseProto {
    fn default() -> &'a DisallowSnapshotResponseProto {
        <DisallowSnapshotResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl DisallowSnapshotResponseProto {
    pub fn new() -> DisallowSnapshotResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DisallowSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisallowSnapshotResponseProto {
        DisallowSnapshotResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DisallowSnapshotResponseProto>(
                "DisallowSnapshotResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DisallowSnapshotResponseProto {
        static instance: ::protobuf::rt::LazyV2<DisallowSnapshotResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DisallowSnapshotResponseProto::new)
    }
}

impl ::protobuf::Clear for DisallowSnapshotResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisallowSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisallowSnapshotResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    snapshotName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteSnapshotRequestProto {
    fn default() -> &'a DeleteSnapshotRequestProto {
        <DeleteSnapshotRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSnapshotRequestProto {
    pub fn new() -> DeleteSnapshotRequestProto {
        ::std::default::Default::default()
    }

    // required string snapshotRoot = 1;


    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string snapshotName = 2;


    pub fn get_snapshotName(&self) -> &str {
        match self.snapshotName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotName(&mut self) {
        self.snapshotName.clear();
    }

    pub fn has_snapshotName(&self) -> bool {
        self.snapshotName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotName(&mut self, v: ::std::string::String) {
        self.snapshotName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotName(&mut self) -> &mut ::std::string::String {
        if self.snapshotName.is_none() {
            self.snapshotName.set_default();
        }
        self.snapshotName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotName(&mut self) -> ::std::string::String {
        self.snapshotName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        if self.snapshotName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.snapshotName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.snapshotName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteSnapshotRequestProto {
        DeleteSnapshotRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snapshotRoot",
                |m: &DeleteSnapshotRequestProto| { &m.snapshotRoot },
                |m: &mut DeleteSnapshotRequestProto| { &mut m.snapshotRoot },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snapshotName",
                |m: &DeleteSnapshotRequestProto| { &m.snapshotName },
                |m: &mut DeleteSnapshotRequestProto| { &mut m.snapshotName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteSnapshotRequestProto>(
                "DeleteSnapshotRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteSnapshotRequestProto {
        static instance: ::protobuf::rt::LazyV2<DeleteSnapshotRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteSnapshotRequestProto::new)
    }
}

impl ::protobuf::Clear for DeleteSnapshotRequestProto {
    fn clear(&mut self) {
        self.snapshotRoot.clear();
        self.snapshotName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSnapshotRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteSnapshotResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteSnapshotResponseProto {
    fn default() -> &'a DeleteSnapshotResponseProto {
        <DeleteSnapshotResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSnapshotResponseProto {
    pub fn new() -> DeleteSnapshotResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeleteSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteSnapshotResponseProto {
        DeleteSnapshotResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteSnapshotResponseProto>(
                "DeleteSnapshotResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteSnapshotResponseProto {
        static instance: ::protobuf::rt::LazyV2<DeleteSnapshotResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteSnapshotResponseProto::new)
    }
}

impl ::protobuf::Clear for DeleteSnapshotResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSnapshotResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckAccessRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    mode: ::std::option::Option<super::acl::AclEntryProto_FsActionProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckAccessRequestProto {
    fn default() -> &'a CheckAccessRequestProto {
        <CheckAccessRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl CheckAccessRequestProto {
    pub fn new() -> CheckAccessRequestProto {
        ::std::default::Default::default()
    }

    // required string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.AclEntryProto.FsActionProto mode = 2;


    pub fn get_mode(&self) -> super::acl::AclEntryProto_FsActionProto {
        self.mode.unwrap_or(super::acl::AclEntryProto_FsActionProto::NONE)
    }
    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: super::acl::AclEntryProto_FsActionProto) {
        self.mode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CheckAccessRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        if self.mode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.mode {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckAccessRequestProto {
        CheckAccessRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &CheckAccessRequestProto| { &m.path },
                |m: &mut CheckAccessRequestProto| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::acl::AclEntryProto_FsActionProto>>(
                "mode",
                |m: &CheckAccessRequestProto| { &m.mode },
                |m: &mut CheckAccessRequestProto| { &mut m.mode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CheckAccessRequestProto>(
                "CheckAccessRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CheckAccessRequestProto {
        static instance: ::protobuf::rt::LazyV2<CheckAccessRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CheckAccessRequestProto::new)
    }
}

impl ::protobuf::Clear for CheckAccessRequestProto {
    fn clear(&mut self) {
        self.path.clear();
        self.mode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckAccessRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckAccessRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckAccessResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckAccessResponseProto {
    fn default() -> &'a CheckAccessResponseProto {
        <CheckAccessResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl CheckAccessResponseProto {
    pub fn new() -> CheckAccessResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CheckAccessResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckAccessResponseProto {
        CheckAccessResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CheckAccessResponseProto>(
                "CheckAccessResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CheckAccessResponseProto {
        static instance: ::protobuf::rt::LazyV2<CheckAccessResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CheckAccessResponseProto::new)
    }
}

impl ::protobuf::Clear for CheckAccessResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckAccessResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckAccessResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCurrentEditLogTxidRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCurrentEditLogTxidRequestProto {
    fn default() -> &'a GetCurrentEditLogTxidRequestProto {
        <GetCurrentEditLogTxidRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetCurrentEditLogTxidRequestProto {
    pub fn new() -> GetCurrentEditLogTxidRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetCurrentEditLogTxidRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCurrentEditLogTxidRequestProto {
        GetCurrentEditLogTxidRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCurrentEditLogTxidRequestProto>(
                "GetCurrentEditLogTxidRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCurrentEditLogTxidRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetCurrentEditLogTxidRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCurrentEditLogTxidRequestProto::new)
    }
}

impl ::protobuf::Clear for GetCurrentEditLogTxidRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCurrentEditLogTxidRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCurrentEditLogTxidRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCurrentEditLogTxidResponseProto {
    // message fields
    txid: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCurrentEditLogTxidResponseProto {
    fn default() -> &'a GetCurrentEditLogTxidResponseProto {
        <GetCurrentEditLogTxidResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetCurrentEditLogTxidResponseProto {
    pub fn new() -> GetCurrentEditLogTxidResponseProto {
        ::std::default::Default::default()
    }

    // required int64 txid = 1;


    pub fn get_txid(&self) -> i64 {
        self.txid.unwrap_or(0)
    }
    pub fn clear_txid(&mut self) {
        self.txid = ::std::option::Option::None;
    }

    pub fn has_txid(&self) -> bool {
        self.txid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: i64) {
        self.txid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetCurrentEditLogTxidResponseProto {
    fn is_initialized(&self) -> bool {
        if self.txid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.txid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.txid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.txid {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCurrentEditLogTxidResponseProto {
        GetCurrentEditLogTxidResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "txid",
                |m: &GetCurrentEditLogTxidResponseProto| { &m.txid },
                |m: &mut GetCurrentEditLogTxidResponseProto| { &mut m.txid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCurrentEditLogTxidResponseProto>(
                "GetCurrentEditLogTxidResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCurrentEditLogTxidResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetCurrentEditLogTxidResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCurrentEditLogTxidResponseProto::new)
    }
}

impl ::protobuf::Clear for GetCurrentEditLogTxidResponseProto {
    fn clear(&mut self) {
        self.txid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCurrentEditLogTxidResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCurrentEditLogTxidResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEditsFromTxidRequestProto {
    // message fields
    txid: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetEditsFromTxidRequestProto {
    fn default() -> &'a GetEditsFromTxidRequestProto {
        <GetEditsFromTxidRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetEditsFromTxidRequestProto {
    pub fn new() -> GetEditsFromTxidRequestProto {
        ::std::default::Default::default()
    }

    // required int64 txid = 1;


    pub fn get_txid(&self) -> i64 {
        self.txid.unwrap_or(0)
    }
    pub fn clear_txid(&mut self) {
        self.txid = ::std::option::Option::None;
    }

    pub fn has_txid(&self) -> bool {
        self.txid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: i64) {
        self.txid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetEditsFromTxidRequestProto {
    fn is_initialized(&self) -> bool {
        if self.txid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.txid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.txid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.txid {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEditsFromTxidRequestProto {
        GetEditsFromTxidRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "txid",
                |m: &GetEditsFromTxidRequestProto| { &m.txid },
                |m: &mut GetEditsFromTxidRequestProto| { &mut m.txid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetEditsFromTxidRequestProto>(
                "GetEditsFromTxidRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetEditsFromTxidRequestProto {
        static instance: ::protobuf::rt::LazyV2<GetEditsFromTxidRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetEditsFromTxidRequestProto::new)
    }
}

impl ::protobuf::Clear for GetEditsFromTxidRequestProto {
    fn clear(&mut self) {
        self.txid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEditsFromTxidRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEditsFromTxidRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEditsFromTxidResponseProto {
    // message fields
    pub eventsList: ::protobuf::SingularPtrField<super::inotify::EventsListProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetEditsFromTxidResponseProto {
    fn default() -> &'a GetEditsFromTxidResponseProto {
        <GetEditsFromTxidResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetEditsFromTxidResponseProto {
    pub fn new() -> GetEditsFromTxidResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.EventsListProto eventsList = 1;


    pub fn get_eventsList(&self) -> &super::inotify::EventsListProto {
        self.eventsList.as_ref().unwrap_or_else(|| <super::inotify::EventsListProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_eventsList(&mut self) {
        self.eventsList.clear();
    }

    pub fn has_eventsList(&self) -> bool {
        self.eventsList.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventsList(&mut self, v: super::inotify::EventsListProto) {
        self.eventsList = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventsList(&mut self) -> &mut super::inotify::EventsListProto {
        if self.eventsList.is_none() {
            self.eventsList.set_default();
        }
        self.eventsList.as_mut().unwrap()
    }

    // Take field
    pub fn take_eventsList(&mut self) -> super::inotify::EventsListProto {
        self.eventsList.take().unwrap_or_else(|| super::inotify::EventsListProto::new())
    }
}

impl ::protobuf::Message for GetEditsFromTxidResponseProto {
    fn is_initialized(&self) -> bool {
        if self.eventsList.is_none() {
            return false;
        }
        for v in &self.eventsList {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eventsList)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.eventsList.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.eventsList.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEditsFromTxidResponseProto {
        GetEditsFromTxidResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::inotify::EventsListProto>>(
                "eventsList",
                |m: &GetEditsFromTxidResponseProto| { &m.eventsList },
                |m: &mut GetEditsFromTxidResponseProto| { &mut m.eventsList },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetEditsFromTxidResponseProto>(
                "GetEditsFromTxidResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetEditsFromTxidResponseProto {
        static instance: ::protobuf::rt::LazyV2<GetEditsFromTxidResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetEditsFromTxidResponseProto::new)
    }
}

impl ::protobuf::Clear for GetEditsFromTxidResponseProto {
    fn clear(&mut self) {
        self.eventsList.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEditsFromTxidResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEditsFromTxidResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListOpenFilesRequestProto {
    // message fields
    id: ::std::option::Option<i64>,
    pub types: ::std::vec::Vec<OpenFilesTypeProto>,
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListOpenFilesRequestProto {
    fn default() -> &'a ListOpenFilesRequestProto {
        <ListOpenFilesRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ListOpenFilesRequestProto {
    pub fn new() -> ListOpenFilesRequestProto {
        ::std::default::Default::default()
    }

    // required int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    // repeated .hadoop.hdfs.OpenFilesTypeProto types = 2;


    pub fn get_types(&self) -> &[OpenFilesTypeProto] {
        &self.types
    }
    pub fn clear_types(&mut self) {
        self.types.clear();
    }

    // Param is passed by value, moved
    pub fn set_types(&mut self, v: ::std::vec::Vec<OpenFilesTypeProto>) {
        self.types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_types(&mut self) -> &mut ::std::vec::Vec<OpenFilesTypeProto> {
        &mut self.types
    }

    // Take field
    pub fn take_types(&mut self) -> ::std::vec::Vec<OpenFilesTypeProto> {
        ::std::mem::replace(&mut self.types, ::std::vec::Vec::new())
    }

    // optional string path = 3;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListOpenFilesRequestProto {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.types, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.types {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        for v in &self.types {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(v))?;
        };
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListOpenFilesRequestProto {
        ListOpenFilesRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &ListOpenFilesRequestProto| { &m.id },
                |m: &mut ListOpenFilesRequestProto| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OpenFilesTypeProto>>(
                "types",
                |m: &ListOpenFilesRequestProto| { &m.types },
                |m: &mut ListOpenFilesRequestProto| { &mut m.types },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &ListOpenFilesRequestProto| { &m.path },
                |m: &mut ListOpenFilesRequestProto| { &mut m.path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListOpenFilesRequestProto>(
                "ListOpenFilesRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListOpenFilesRequestProto {
        static instance: ::protobuf::rt::LazyV2<ListOpenFilesRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListOpenFilesRequestProto::new)
    }
}

impl ::protobuf::Clear for ListOpenFilesRequestProto {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.types.clear();
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListOpenFilesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOpenFilesRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpenFilesBatchResponseProto {
    // message fields
    id: ::std::option::Option<i64>,
    path: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    clientMachine: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpenFilesBatchResponseProto {
    fn default() -> &'a OpenFilesBatchResponseProto {
        <OpenFilesBatchResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl OpenFilesBatchResponseProto {
    pub fn new() -> OpenFilesBatchResponseProto {
        ::std::default::Default::default()
    }

    // required int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    // required string path = 2;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string clientName = 3;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string clientMachine = 4;


    pub fn get_clientMachine(&self) -> &str {
        match self.clientMachine.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientMachine(&mut self) {
        self.clientMachine.clear();
    }

    pub fn has_clientMachine(&self) -> bool {
        self.clientMachine.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientMachine(&mut self, v: ::std::string::String) {
        self.clientMachine = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientMachine(&mut self) -> &mut ::std::string::String {
        if self.clientMachine.is_none() {
            self.clientMachine.set_default();
        }
        self.clientMachine.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientMachine(&mut self) -> ::std::string::String {
        self.clientMachine.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for OpenFilesBatchResponseProto {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.path.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        if self.clientMachine.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientMachine)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.clientMachine.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.clientMachine.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpenFilesBatchResponseProto {
        OpenFilesBatchResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &OpenFilesBatchResponseProto| { &m.id },
                |m: &mut OpenFilesBatchResponseProto| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &OpenFilesBatchResponseProto| { &m.path },
                |m: &mut OpenFilesBatchResponseProto| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientName",
                |m: &OpenFilesBatchResponseProto| { &m.clientName },
                |m: &mut OpenFilesBatchResponseProto| { &mut m.clientName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientMachine",
                |m: &OpenFilesBatchResponseProto| { &m.clientMachine },
                |m: &mut OpenFilesBatchResponseProto| { &mut m.clientMachine },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpenFilesBatchResponseProto>(
                "OpenFilesBatchResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpenFilesBatchResponseProto {
        static instance: ::protobuf::rt::LazyV2<OpenFilesBatchResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpenFilesBatchResponseProto::new)
    }
}

impl ::protobuf::Clear for OpenFilesBatchResponseProto {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.path.clear();
        self.clientName.clear();
        self.clientMachine.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpenFilesBatchResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenFilesBatchResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListOpenFilesResponseProto {
    // message fields
    pub entries: ::protobuf::RepeatedField<OpenFilesBatchResponseProto>,
    hasMore: ::std::option::Option<bool>,
    pub types: ::std::vec::Vec<OpenFilesTypeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListOpenFilesResponseProto {
    fn default() -> &'a ListOpenFilesResponseProto {
        <ListOpenFilesResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ListOpenFilesResponseProto {
    pub fn new() -> ListOpenFilesResponseProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.OpenFilesBatchResponseProto entries = 1;


    pub fn get_entries(&self) -> &[OpenFilesBatchResponseProto] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<OpenFilesBatchResponseProto>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<OpenFilesBatchResponseProto> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<OpenFilesBatchResponseProto> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }

    // required bool hasMore = 2;


    pub fn get_hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }
    pub fn clear_hasMore(&mut self) {
        self.hasMore = ::std::option::Option::None;
    }

    pub fn has_hasMore(&self) -> bool {
        self.hasMore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMore(&mut self, v: bool) {
        self.hasMore = ::std::option::Option::Some(v);
    }

    // repeated .hadoop.hdfs.OpenFilesTypeProto types = 3;


    pub fn get_types(&self) -> &[OpenFilesTypeProto] {
        &self.types
    }
    pub fn clear_types(&mut self) {
        self.types.clear();
    }

    // Param is passed by value, moved
    pub fn set_types(&mut self, v: ::std::vec::Vec<OpenFilesTypeProto>) {
        self.types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_types(&mut self) -> &mut ::std::vec::Vec<OpenFilesTypeProto> {
        &mut self.types
    }

    // Take field
    pub fn take_types(&mut self) -> ::std::vec::Vec<OpenFilesTypeProto> {
        ::std::mem::replace(&mut self.types, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ListOpenFilesResponseProto {
    fn is_initialized(&self) -> bool {
        if self.hasMore.is_none() {
            return false;
        }
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasMore = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.types, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.hasMore {
            my_size += 2;
        }
        for value in &self.types {
            my_size += ::protobuf::rt::enum_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.hasMore {
            os.write_bool(2, v)?;
        }
        for v in &self.types {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListOpenFilesResponseProto {
        ListOpenFilesResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpenFilesBatchResponseProto>>(
                "entries",
                |m: &ListOpenFilesResponseProto| { &m.entries },
                |m: &mut ListOpenFilesResponseProto| { &mut m.entries },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hasMore",
                |m: &ListOpenFilesResponseProto| { &m.hasMore },
                |m: &mut ListOpenFilesResponseProto| { &mut m.hasMore },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OpenFilesTypeProto>>(
                "types",
                |m: &ListOpenFilesResponseProto| { &m.types },
                |m: &mut ListOpenFilesResponseProto| { &mut m.types },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListOpenFilesResponseProto>(
                "ListOpenFilesResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListOpenFilesResponseProto {
        static instance: ::protobuf::rt::LazyV2<ListOpenFilesResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListOpenFilesResponseProto::new)
    }
}

impl ::protobuf::Clear for ListOpenFilesResponseProto {
    fn clear(&mut self) {
        self.entries.clear();
        self.hasMore = ::std::option::Option::None;
        self.types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListOpenFilesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOpenFilesResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsyncRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsyncRequestProto {
    fn default() -> &'a MsyncRequestProto {
        <MsyncRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl MsyncRequestProto {
    pub fn new() -> MsyncRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsyncRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsyncRequestProto {
        MsyncRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsyncRequestProto>(
                "MsyncRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsyncRequestProto {
        static instance: ::protobuf::rt::LazyV2<MsyncRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsyncRequestProto::new)
    }
}

impl ::protobuf::Clear for MsyncRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsyncRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsyncRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsyncResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsyncResponseProto {
    fn default() -> &'a MsyncResponseProto {
        <MsyncResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl MsyncResponseProto {
    pub fn new() -> MsyncResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsyncResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsyncResponseProto {
        MsyncResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsyncResponseProto>(
                "MsyncResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsyncResponseProto {
        static instance: ::protobuf::rt::LazyV2<MsyncResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsyncResponseProto::new)
    }
}

impl ::protobuf::Clear for MsyncResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsyncResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsyncResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SatisfyStoragePolicyRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SatisfyStoragePolicyRequestProto {
    fn default() -> &'a SatisfyStoragePolicyRequestProto {
        <SatisfyStoragePolicyRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl SatisfyStoragePolicyRequestProto {
    pub fn new() -> SatisfyStoragePolicyRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for SatisfyStoragePolicyRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SatisfyStoragePolicyRequestProto {
        SatisfyStoragePolicyRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src",
                |m: &SatisfyStoragePolicyRequestProto| { &m.src },
                |m: &mut SatisfyStoragePolicyRequestProto| { &mut m.src },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SatisfyStoragePolicyRequestProto>(
                "SatisfyStoragePolicyRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SatisfyStoragePolicyRequestProto {
        static instance: ::protobuf::rt::LazyV2<SatisfyStoragePolicyRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SatisfyStoragePolicyRequestProto::new)
    }
}

impl ::protobuf::Clear for SatisfyStoragePolicyRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SatisfyStoragePolicyRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SatisfyStoragePolicyRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SatisfyStoragePolicyResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SatisfyStoragePolicyResponseProto {
    fn default() -> &'a SatisfyStoragePolicyResponseProto {
        <SatisfyStoragePolicyResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl SatisfyStoragePolicyResponseProto {
    pub fn new() -> SatisfyStoragePolicyResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SatisfyStoragePolicyResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SatisfyStoragePolicyResponseProto {
        SatisfyStoragePolicyResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SatisfyStoragePolicyResponseProto>(
                "SatisfyStoragePolicyResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SatisfyStoragePolicyResponseProto {
        static instance: ::protobuf::rt::LazyV2<SatisfyStoragePolicyResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SatisfyStoragePolicyResponseProto::new)
    }
}

impl ::protobuf::Clear for SatisfyStoragePolicyResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SatisfyStoragePolicyResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SatisfyStoragePolicyResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HAServiceStateRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HAServiceStateRequestProto {
    fn default() -> &'a HAServiceStateRequestProto {
        <HAServiceStateRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl HAServiceStateRequestProto {
    pub fn new() -> HAServiceStateRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for HAServiceStateRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HAServiceStateRequestProto {
        HAServiceStateRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HAServiceStateRequestProto>(
                "HAServiceStateRequestProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HAServiceStateRequestProto {
        static instance: ::protobuf::rt::LazyV2<HAServiceStateRequestProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HAServiceStateRequestProto::new)
    }
}

impl ::protobuf::Clear for HAServiceStateRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HAServiceStateRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HAServiceStateRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HAServiceStateResponseProto {
    // message fields
    state: ::std::option::Option<super::HAServiceProtocol::HAServiceStateProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HAServiceStateResponseProto {
    fn default() -> &'a HAServiceStateResponseProto {
        <HAServiceStateResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl HAServiceStateResponseProto {
    pub fn new() -> HAServiceStateResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.common.HAServiceStateProto state = 1;


    pub fn get_state(&self) -> super::HAServiceProtocol::HAServiceStateProto {
        self.state.unwrap_or(super::HAServiceProtocol::HAServiceStateProto::INITIALIZING)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: super::HAServiceProtocol::HAServiceStateProto) {
        self.state = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for HAServiceStateResponseProto {
    fn is_initialized(&self) -> bool {
        if self.state.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.state {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HAServiceStateResponseProto {
        HAServiceStateResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::HAServiceProtocol::HAServiceStateProto>>(
                "state",
                |m: &HAServiceStateResponseProto| { &m.state },
                |m: &mut HAServiceStateResponseProto| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HAServiceStateResponseProto>(
                "HAServiceStateResponseProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HAServiceStateResponseProto {
        static instance: ::protobuf::rt::LazyV2<HAServiceStateResponseProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HAServiceStateResponseProto::new)
    }
}

impl ::protobuf::Clear for HAServiceStateResponseProto {
    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HAServiceStateResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HAServiceStateResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CreateFlagProto {
    CREATE = 1,
    OVERWRITE = 2,
    APPEND = 4,
    LAZY_PERSIST = 16,
    NEW_BLOCK = 32,
    SHOULD_REPLICATE = 128,
}

impl ::protobuf::ProtobufEnum for CreateFlagProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CreateFlagProto> {
        match value {
            1 => ::std::option::Option::Some(CreateFlagProto::CREATE),
            2 => ::std::option::Option::Some(CreateFlagProto::OVERWRITE),
            4 => ::std::option::Option::Some(CreateFlagProto::APPEND),
            16 => ::std::option::Option::Some(CreateFlagProto::LAZY_PERSIST),
            32 => ::std::option::Option::Some(CreateFlagProto::NEW_BLOCK),
            128 => ::std::option::Option::Some(CreateFlagProto::SHOULD_REPLICATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CreateFlagProto] = &[
            CreateFlagProto::CREATE,
            CreateFlagProto::OVERWRITE,
            CreateFlagProto::APPEND,
            CreateFlagProto::LAZY_PERSIST,
            CreateFlagProto::NEW_BLOCK,
            CreateFlagProto::SHOULD_REPLICATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CreateFlagProto>("CreateFlagProto", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CreateFlagProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CreateFlagProto {
    fn default() -> Self {
        CreateFlagProto::CREATE
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateFlagProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AddBlockFlagProto {
    NO_LOCAL_WRITE = 1,
    IGNORE_CLIENT_LOCALITY = 2,
}

impl ::protobuf::ProtobufEnum for AddBlockFlagProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AddBlockFlagProto> {
        match value {
            1 => ::std::option::Option::Some(AddBlockFlagProto::NO_LOCAL_WRITE),
            2 => ::std::option::Option::Some(AddBlockFlagProto::IGNORE_CLIENT_LOCALITY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AddBlockFlagProto] = &[
            AddBlockFlagProto::NO_LOCAL_WRITE,
            AddBlockFlagProto::IGNORE_CLIENT_LOCALITY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AddBlockFlagProto>("AddBlockFlagProto", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AddBlockFlagProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for AddBlockFlagProto {
    fn default() -> Self {
        AddBlockFlagProto::NO_LOCAL_WRITE
    }
}

impl ::protobuf::reflect::ProtobufValue for AddBlockFlagProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DatanodeReportTypeProto {
    ALL = 1,
    LIVE = 2,
    DEAD = 3,
    DECOMMISSIONING = 4,
    ENTERING_MAINTENANCE = 5,
    IN_MAINTENANCE = 6,
}

impl ::protobuf::ProtobufEnum for DatanodeReportTypeProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DatanodeReportTypeProto> {
        match value {
            1 => ::std::option::Option::Some(DatanodeReportTypeProto::ALL),
            2 => ::std::option::Option::Some(DatanodeReportTypeProto::LIVE),
            3 => ::std::option::Option::Some(DatanodeReportTypeProto::DEAD),
            4 => ::std::option::Option::Some(DatanodeReportTypeProto::DECOMMISSIONING),
            5 => ::std::option::Option::Some(DatanodeReportTypeProto::ENTERING_MAINTENANCE),
            6 => ::std::option::Option::Some(DatanodeReportTypeProto::IN_MAINTENANCE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DatanodeReportTypeProto] = &[
            DatanodeReportTypeProto::ALL,
            DatanodeReportTypeProto::LIVE,
            DatanodeReportTypeProto::DEAD,
            DatanodeReportTypeProto::DECOMMISSIONING,
            DatanodeReportTypeProto::ENTERING_MAINTENANCE,
            DatanodeReportTypeProto::IN_MAINTENANCE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DatanodeReportTypeProto>("DatanodeReportTypeProto", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DatanodeReportTypeProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DatanodeReportTypeProto {
    fn default() -> Self {
        DatanodeReportTypeProto::ALL
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeReportTypeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SafeModeActionProto {
    SAFEMODE_LEAVE = 1,
    SAFEMODE_ENTER = 2,
    SAFEMODE_GET = 3,
    SAFEMODE_FORCE_EXIT = 4,
}

impl ::protobuf::ProtobufEnum for SafeModeActionProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SafeModeActionProto> {
        match value {
            1 => ::std::option::Option::Some(SafeModeActionProto::SAFEMODE_LEAVE),
            2 => ::std::option::Option::Some(SafeModeActionProto::SAFEMODE_ENTER),
            3 => ::std::option::Option::Some(SafeModeActionProto::SAFEMODE_GET),
            4 => ::std::option::Option::Some(SafeModeActionProto::SAFEMODE_FORCE_EXIT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SafeModeActionProto] = &[
            SafeModeActionProto::SAFEMODE_LEAVE,
            SafeModeActionProto::SAFEMODE_ENTER,
            SafeModeActionProto::SAFEMODE_GET,
            SafeModeActionProto::SAFEMODE_FORCE_EXIT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SafeModeActionProto>("SafeModeActionProto", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SafeModeActionProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SafeModeActionProto {
    fn default() -> Self {
        SafeModeActionProto::SAFEMODE_LEAVE
    }
}

impl ::protobuf::reflect::ProtobufValue for SafeModeActionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RollingUpgradeActionProto {
    QUERY = 1,
    START = 2,
    FINALIZE = 3,
}

impl ::protobuf::ProtobufEnum for RollingUpgradeActionProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RollingUpgradeActionProto> {
        match value {
            1 => ::std::option::Option::Some(RollingUpgradeActionProto::QUERY),
            2 => ::std::option::Option::Some(RollingUpgradeActionProto::START),
            3 => ::std::option::Option::Some(RollingUpgradeActionProto::FINALIZE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RollingUpgradeActionProto] = &[
            RollingUpgradeActionProto::QUERY,
            RollingUpgradeActionProto::START,
            RollingUpgradeActionProto::FINALIZE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RollingUpgradeActionProto>("RollingUpgradeActionProto", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RollingUpgradeActionProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for RollingUpgradeActionProto {
    fn default() -> Self {
        RollingUpgradeActionProto::QUERY
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpgradeActionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CacheFlagProto {
    FORCE = 1,
}

impl ::protobuf::ProtobufEnum for CacheFlagProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CacheFlagProto> {
        match value {
            1 => ::std::option::Option::Some(CacheFlagProto::FORCE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CacheFlagProto] = &[
            CacheFlagProto::FORCE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CacheFlagProto>("CacheFlagProto", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CacheFlagProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CacheFlagProto {
    fn default() -> Self {
        CacheFlagProto::FORCE
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheFlagProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OpenFilesTypeProto {
    ALL_OPEN_FILES = 1,
    BLOCKING_DECOMMISSION = 2,
}

impl ::protobuf::ProtobufEnum for OpenFilesTypeProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OpenFilesTypeProto> {
        match value {
            1 => ::std::option::Option::Some(OpenFilesTypeProto::ALL_OPEN_FILES),
            2 => ::std::option::Option::Some(OpenFilesTypeProto::BLOCKING_DECOMMISSION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OpenFilesTypeProto] = &[
            OpenFilesTypeProto::ALL_OPEN_FILES,
            OpenFilesTypeProto::BLOCKING_DECOMMISSION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OpenFilesTypeProto>("OpenFilesTypeProto", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OpenFilesTypeProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for OpenFilesTypeProto {
    fn default() -> Self {
        OpenFilesTypeProto::ALL_OPEN_FILES
    }
}

impl ::protobuf::reflect::ProtobufValue for OpenFilesTypeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cClientNamenodeProtocol.proto\x12\x0bhadoop.hdfs\x1a\x0eSecurity.pr\
    oto\x1a\nhdfs.proto\x1a\tacl.proto\x1a\x0bxattr.proto\x1a\x10encryption.\
    proto\x1a\rinotify.proto\x1a\x13erasurecoding.proto\x1a\x17HAServiceProt\
    ocol.proto\"a\n\x1dGetBlockLocationsRequestProto\x12\x10\n\x03src\x18\
    \x01\x20\x02(\tR\x03src\x12\x16\n\x06offset\x18\x02\x20\x02(\x04R\x06off\
    set\x12\x16\n\x06length\x18\x03\x20\x02(\x04R\x06length\"_\n\x1eGetBlock\
    LocationsResponseProto\x12=\n\tlocations\x18\x01\x20\x01(\x0b2\x1f.hadoo\
    p.hdfs.LocatedBlocksProtoR\tlocations\"\x1f\n\x1dGetServerDefaultsReques\
    tProto\"l\n\x1eGetServerDefaultsResponseProto\x12J\n\x0eserverDefaults\
    \x18\x01\x20\x02(\x0b2\".hadoop.hdfs.FsServerDefaultsProtoR\x0eserverDef\
    aults\"\xe7\x03\n\x12CreateRequestProto\x12\x10\n\x03src\x18\x01\x20\x02\
    (\tR\x03src\x126\n\x06masked\x18\x02\x20\x02(\x0b2\x1e.hadoop.hdfs.FsPer\
    missionProtoR\x06masked\x12\x1e\n\nclientName\x18\x03\x20\x02(\tR\nclien\
    tName\x12\x1e\n\ncreateFlag\x18\x04\x20\x02(\rR\ncreateFlag\x12\"\n\x0cc\
    reateParent\x18\x05\x20\x02(\x08R\x0ccreateParent\x12\x20\n\x0breplicati\
    on\x18\x06\x20\x02(\rR\x0breplication\x12\x1c\n\tblockSize\x18\x07\x20\
    \x02(\x04R\tblockSize\x12]\n\x15cryptoProtocolVersion\x18\x08\x20\x03(\
    \x0e2'.hadoop.hdfs.CryptoProtocolVersionProtoR\x15cryptoProtocolVersion\
    \x12:\n\x08unmasked\x18\t\x20\x01(\x0b2\x1e.hadoop.hdfs.FsPermissionProt\
    oR\x08unmasked\x12\"\n\x0cecPolicyName\x18\n\x20\x01(\tR\x0cecPolicyName\
    \x12$\n\rstoragePolicy\x18\x0b\x20\x01(\tR\rstoragePolicy\"G\n\x13Create\
    ResponseProto\x120\n\x02fs\x18\x01\x20\x01(\x0b2\x20.hadoop.hdfs.HdfsFil\
    eStatusProtoR\x02fs\"Z\n\x12AppendRequestProto\x12\x10\n\x03src\x18\x01\
    \x20\x02(\tR\x03src\x12\x1e\n\nclientName\x18\x02\x20\x02(\tR\nclientNam\
    e\x12\x12\n\x04flag\x18\x03\x20\x01(\rR\x04flag\"\x81\x01\n\x13AppendRes\
    ponseProto\x124\n\x05block\x18\x01\x20\x01(\x0b2\x1e.hadoop.hdfs.Located\
    BlockProtoR\x05block\x124\n\x04stat\x18\x02\x20\x01(\x0b2\x20.hadoop.hdf\
    s.HdfsFileStatusProtoR\x04stat\"P\n\x1aSetReplicationRequestProto\x12\
    \x10\n\x03src\x18\x01\x20\x02(\tR\x03src\x12\x20\n\x0breplication\x18\
    \x02\x20\x02(\rR\x0breplication\"5\n\x1bSetReplicationResponseProto\x12\
    \x16\n\x06result\x18\x01\x20\x02(\x08R\x06result\"P\n\x1cSetStoragePolic\
    yRequestProto\x12\x10\n\x03src\x18\x01\x20\x02(\tR\x03src\x12\x1e\n\npol\
    icyName\x18\x02\x20\x02(\tR\npolicyName\"\x1f\n\x1dSetStoragePolicyRespo\
    nseProto\"2\n\x1eUnsetStoragePolicyRequestProto\x12\x10\n\x03src\x18\x01\
    \x20\x02(\tR\x03src\"!\n\x1fUnsetStoragePolicyResponseProto\"2\n\x1cGetS\
    toragePolicyRequestProto\x12\x12\n\x04path\x18\x01\x20\x02(\tR\x04path\"\
    k\n\x1dGetStoragePolicyResponseProto\x12J\n\rstoragePolicy\x18\x01\x20\
    \x02(\x0b2$.hadoop.hdfs.BlockStoragePolicyProtoR\rstoragePolicy\"\x20\n\
    \x1eGetStoragePoliciesRequestProto\"c\n\x1fGetStoragePoliciesResponsePro\
    to\x12@\n\x08policies\x18\x01\x20\x03(\x0b2$.hadoop.hdfs.BlockStoragePol\
    icyProtoR\x08policies\"m\n\x19SetPermissionRequestProto\x12\x10\n\x03src\
    \x18\x01\x20\x02(\tR\x03src\x12>\n\npermission\x18\x02\x20\x02(\x0b2\x1e\
    .hadoop.hdfs.FsPermissionProtoR\npermission\"\x1c\n\x1aSetPermissionResp\
    onseProto\"b\n\x14SetOwnerRequestProto\x12\x10\n\x03src\x18\x01\x20\x02(\
    \tR\x03src\x12\x1a\n\x08username\x18\x02\x20\x01(\tR\x08username\x12\x1c\
    \n\tgroupname\x18\x03\x20\x01(\tR\tgroupname\"\x17\n\x15SetOwnerResponse\
    Proto\"\x8e\x01\n\x18AbandonBlockRequestProto\x12-\n\x01b\x18\x01\x20\
    \x02(\x0b2\x1f.hadoop.hdfs.ExtendedBlockProtoR\x01b\x12\x10\n\x03src\x18\
    \x02\x20\x02(\tR\x03src\x12\x16\n\x06holder\x18\x03\x20\x02(\tR\x06holde\
    r\x12\x19\n\x06fileId\x18\x04\x20\x01(\x04:\x010R\x06fileId\"\x1b\n\x19A\
    bandonBlockResponseProto\"\xbe\x02\n\x14AddBlockRequestProto\x12\x10\n\
    \x03src\x18\x01\x20\x02(\tR\x03src\x12\x1e\n\nclientName\x18\x02\x20\x02\
    (\tR\nclientName\x12;\n\x08previous\x18\x03\x20\x01(\x0b2\x1f.hadoop.hdf\
    s.ExtendedBlockProtoR\x08previous\x12B\n\x0cexcludeNodes\x18\x04\x20\x03\
    (\x0b2\x1e.hadoop.hdfs.DatanodeInfoProtoR\x0cexcludeNodes\x12\x19\n\x06f\
    ileId\x18\x05\x20\x01(\x04:\x010R\x06fileId\x12\"\n\x0cfavoredNodes\x18\
    \x06\x20\x03(\tR\x0cfavoredNodes\x124\n\x05flags\x18\x07\x20\x03(\x0e2\
    \x1e.hadoop.hdfs.AddBlockFlagProtoR\x05flags\"M\n\x15AddBlockResponsePro\
    to\x124\n\x05block\x18\x01\x20\x02(\x0b2\x1e.hadoop.hdfs.LocatedBlockPro\
    toR\x05block\"\x81\x03\n!GetAdditionalDatanodeRequestProto\x12\x10\n\x03\
    src\x18\x01\x20\x02(\tR\x03src\x121\n\x03blk\x18\x02\x20\x02(\x0b2\x1f.h\
    adoop.hdfs.ExtendedBlockProtoR\x03blk\x12<\n\texistings\x18\x03\x20\x03(\
    \x0b2\x1e.hadoop.hdfs.DatanodeInfoProtoR\texistings\x12:\n\x08excludes\
    \x18\x04\x20\x03(\x0b2\x1e.hadoop.hdfs.DatanodeInfoProtoR\x08excludes\
    \x12.\n\x12numAdditionalNodes\x18\x05\x20\x02(\rR\x12numAdditionalNodes\
    \x12\x1e\n\nclientName\x18\x06\x20\x02(\tR\nclientName\x122\n\x14existin\
    gStorageUuids\x18\x07\x20\x03(\tR\x14existingStorageUuids\x12\x19\n\x06f\
    ileId\x18\x08\x20\x01(\x04:\x010R\x06fileId\"Z\n\"GetAdditionalDatanodeR\
    esponseProto\x124\n\x05block\x18\x01\x20\x02(\x0b2\x1e.hadoop.hdfs.Locat\
    edBlockProtoR\x05block\"\x98\x01\n\x14CompleteRequestProto\x12\x10\n\x03\
    src\x18\x01\x20\x02(\tR\x03src\x12\x1e\n\nclientName\x18\x02\x20\x02(\tR\
    \nclientName\x123\n\x04last\x18\x03\x20\x01(\x0b2\x1f.hadoop.hdfs.Extend\
    edBlockProtoR\x04last\x12\x19\n\x06fileId\x18\x04\x20\x01(\x04:\x010R\
    \x06fileId\"/\n\x15CompleteResponseProto\x12\x16\n\x06result\x18\x01\x20\
    \x02(\x08R\x06result\"U\n\x1bReportBadBlocksRequestProto\x126\n\x06block\
    s\x18\x01\x20\x03(\x0b2\x1e.hadoop.hdfs.LocatedBlockProtoR\x06blocks\"\
    \x1e\n\x1cReportBadBlocksResponseProto\":\n\x12ConcatRequestProto\x12\
    \x10\n\x03trg\x18\x01\x20\x02(\tR\x03trg\x12\x12\n\x04srcs\x18\x02\x20\
    \x03(\tR\x04srcs\"\x15\n\x13ConcatResponseProto\"f\n\x14TruncateRequestP\
    roto\x12\x10\n\x03src\x18\x01\x20\x02(\tR\x03src\x12\x1c\n\tnewLength\
    \x18\x02\x20\x02(\x04R\tnewLength\x12\x1e\n\nclientName\x18\x03\x20\x02(\
    \tR\nclientName\"/\n\x15TruncateResponseProto\x12\x16\n\x06result\x18\
    \x01\x20\x02(\x08R\x06result\"8\n\x12RenameRequestProto\x12\x10\n\x03src\
    \x18\x01\x20\x02(\tR\x03src\x12\x10\n\x03dst\x18\x02\x20\x02(\tR\x03dst\
    \"-\n\x13RenameResponseProto\x12\x16\n\x06result\x18\x01\x20\x02(\x08R\
    \x06result\"\x81\x01\n\x13Rename2RequestProto\x12\x10\n\x03src\x18\x01\
    \x20\x02(\tR\x03src\x12\x10\n\x03dst\x18\x02\x20\x02(\tR\x03dst\x12$\n\r\
    overwriteDest\x18\x03\x20\x02(\x08R\roverwriteDest\x12\x20\n\x0bmoveToTr\
    ash\x18\x04\x20\x01(\x08R\x0bmoveToTrash\"\x16\n\x14Rename2ResponseProto\
    \"D\n\x12DeleteRequestProto\x12\x10\n\x03src\x18\x01\x20\x02(\tR\x03src\
    \x12\x1c\n\trecursive\x18\x02\x20\x02(\x08R\trecursive\"-\n\x13DeleteRes\
    ponseProto\x12\x16\n\x06result\x18\x01\x20\x02(\x08R\x06result\"\xbe\x01\
    \n\x12MkdirsRequestProto\x12\x10\n\x03src\x18\x01\x20\x02(\tR\x03src\x12\
    6\n\x06masked\x18\x02\x20\x02(\x0b2\x1e.hadoop.hdfs.FsPermissionProtoR\
    \x06masked\x12\"\n\x0ccreateParent\x18\x03\x20\x02(\x08R\x0ccreateParent\
    \x12:\n\x08unmasked\x18\x04\x20\x01(\x0b2\x1e.hadoop.hdfs.FsPermissionPr\
    otoR\x08unmasked\"-\n\x13MkdirsResponseProto\x12\x16\n\x06result\x18\x01\
    \x20\x02(\x08R\x06result\"n\n\x16GetListingRequestProto\x12\x10\n\x03src\
    \x18\x01\x20\x02(\tR\x03src\x12\x1e\n\nstartAfter\x18\x02\x20\x02(\x0cR\
    \nstartAfter\x12\"\n\x0cneedLocation\x18\x03\x20\x02(\x08R\x0cneedLocati\
    on\"W\n\x17GetListingResponseProto\x12<\n\x07dirList\x18\x01\x20\x01(\
    \x0b2\".hadoop.hdfs.DirectoryListingProtoR\x07dirList\"y\n\x1dGetBatched\
    ListingRequestProto\x12\x14\n\x05paths\x18\x01\x20\x03(\tR\x05paths\x12\
    \x1e\n\nstartAfter\x18\x02\x20\x02(\x0cR\nstartAfter\x12\"\n\x0cneedLoca\
    tion\x18\x03\x20\x02(\x08R\x0cneedLocation\"\xa1\x01\n\x1eGetBatchedList\
    ingResponseProto\x12E\n\x08listings\x18\x01\x20\x03(\x0b2).hadoop.hdfs.B\
    atchedDirectoryListingProtoR\x08listings\x12\x18\n\x07hasMore\x18\x02\
    \x20\x02(\x08R\x07hasMore\x12\x1e\n\nstartAfter\x18\x03\x20\x02(\x0cR\ns\
    tartAfter\"(\n&GetSnapshottableDirListingRequestProto\"\x8e\x01\n'GetSna\
    pshottableDirListingResponseProto\x12c\n\x14snapshottableDirList\x18\x01\
    \x20\x01(\x0b2/.hadoop.hdfs.SnapshottableDirectoryListingProtoR\x14snaps\
    hottableDirList\"D\n\x1eGetSnapshotListingRequestProto\x12\"\n\x0csnapsh\
    otRoot\x18\x01\x20\x02(\tR\x0csnapshotRoot\"h\n\x1fGetSnapshotListingRes\
    ponseProto\x12E\n\x0csnapshotList\x18\x01\x20\x01(\x0b2!.hadoop.hdfs.Sna\
    pshotListingProtoR\x0csnapshotList\"\x8b\x01\n!GetSnapshotDiffReportRequ\
    estProto\x12\"\n\x0csnapshotRoot\x18\x01\x20\x02(\tR\x0csnapshotRoot\x12\
    \"\n\x0cfromSnapshot\x18\x02\x20\x02(\tR\x0cfromSnapshot\x12\x1e\n\ntoSn\
    apshot\x18\x03\x20\x02(\tR\ntoSnapshot\"j\n\"GetSnapshotDiffReportRespon\
    seProto\x12D\n\ndiffReport\x18\x01\x20\x02(\x0b2$.hadoop.hdfs.SnapshotDi\
    ffReportProtoR\ndiffReport\"\xd6\x01\n(GetSnapshotDiffReportListingReque\
    stProto\x12\"\n\x0csnapshotRoot\x18\x01\x20\x02(\tR\x0csnapshotRoot\x12\
    \"\n\x0cfromSnapshot\x18\x02\x20\x02(\tR\x0cfromSnapshot\x12\x1e\n\ntoSn\
    apshot\x18\x03\x20\x02(\tR\ntoSnapshot\x12B\n\x06cursor\x18\x04\x20\x01(\
    \x0b2*.hadoop.hdfs.SnapshotDiffReportCursorProtoR\x06cursor\"x\n)GetSnap\
    shotDiffReportListingResponseProto\x12K\n\ndiffReport\x18\x01\x20\x02(\
    \x0b2+.hadoop.hdfs.SnapshotDiffReportListingProtoR\ndiffReport\"8\n\x16R\
    enewLeaseRequestProto\x12\x1e\n\nclientName\x18\x01\x20\x02(\tR\nclientN\
    ame\"\x19\n\x17RenewLeaseResponseProto\"L\n\x18RecoverLeaseRequestProto\
    \x12\x10\n\x03src\x18\x01\x20\x02(\tR\x03src\x12\x1e\n\nclientName\x18\
    \x02\x20\x02(\tR\nclientName\"3\n\x19RecoverLeaseResponseProto\x12\x16\n\
    \x06result\x18\x01\x20\x02(\x08R\x06result\"\x19\n\x17GetFsStatusRequest\
    Proto\"\xf9\x02\n\x17GetFsStatsResponseProto\x12\x1a\n\x08capacity\x18\
    \x01\x20\x02(\x04R\x08capacity\x12\x12\n\x04used\x18\x02\x20\x02(\x04R\
    \x04used\x12\x1c\n\tremaining\x18\x03\x20\x02(\x04R\tremaining\x12)\n\
    \x10under_replicated\x18\x04\x20\x02(\x04R\x0funderReplicated\x12%\n\x0e\
    corrupt_blocks\x18\x05\x20\x02(\x04R\rcorruptBlocks\x12%\n\x0emissing_bl\
    ocks\x18\x06\x20\x02(\x04R\rmissingBlocks\x125\n\x17missing_repl_one_blo\
    cks\x18\x07\x20\x01(\x04R\x14missingReplOneBlocks\x12(\n\x10blocks_in_fu\
    ture\x18\x08\x20\x01(\x04R\x0eblocksInFuture\x126\n\x17pending_deletion_\
    blocks\x18\t\x20\x01(\x04R\x15pendingDeletionBlocks\"'\n%GetFsReplicated\
    BlockStatsRequestProto\"\x82\x03\n&GetFsReplicatedBlockStatsResponseProt\
    o\x12%\n\x0elow_redundancy\x18\x01\x20\x02(\x04R\rlowRedundancy\x12%\n\
    \x0ecorrupt_blocks\x18\x02\x20\x02(\x04R\rcorruptBlocks\x12%\n\x0emissin\
    g_blocks\x18\x03\x20\x02(\x04R\rmissingBlocks\x125\n\x17missing_repl_one\
    _blocks\x18\x04\x20\x02(\x04R\x14missingReplOneBlocks\x12(\n\x10blocks_i\
    n_future\x18\x05\x20\x02(\x04R\x0eblocksInFuture\x126\n\x17pending_delet\
    ion_blocks\x18\x06\x20\x02(\x04R\x15pendingDeletionBlocks\x12J\n\"highes\
    t_prio_low_redundancy_blocks\x18\x07\x20\x01(\x04R\x1ehighestPrioLowRedu\
    ndancyBlocks\"$\n\"GetFsECBlockGroupStatsRequestProto\"\xc8\x02\n#GetFsE\
    CBlockGroupStatsResponseProto\x12%\n\x0elow_redundancy\x18\x01\x20\x02(\
    \x04R\rlowRedundancy\x12%\n\x0ecorrupt_blocks\x18\x02\x20\x02(\x04R\rcor\
    ruptBlocks\x12%\n\x0emissing_blocks\x18\x03\x20\x02(\x04R\rmissingBlocks\
    \x12(\n\x10blocks_in_future\x18\x04\x20\x02(\x04R\x0eblocksInFuture\x126\
    \n\x17pending_deletion_blocks\x18\x05\x20\x02(\x04R\x15pendingDeletionBl\
    ocks\x12J\n\"highest_prio_low_redundancy_blocks\x18\x06\x20\x01(\x04R\
    \x1ehighestPrioLowRedundancyBlocks\"Y\n\x1dGetDatanodeReportRequestProto\
    \x128\n\x04type\x18\x01\x20\x02(\x0e2$.hadoop.hdfs.DatanodeReportTypePro\
    toR\x04type\"P\n\x1eGetDatanodeReportResponseProto\x12.\n\x02di\x18\x01\
    \x20\x03(\x0b2\x1e.hadoop.hdfs.DatanodeInfoProtoR\x02di\"`\n$GetDatanode\
    StorageReportRequestProto\x128\n\x04type\x18\x01\x20\x02(\x0e2$.hadoop.h\
    dfs.DatanodeReportTypeProtoR\x04type\"\xa9\x01\n\x1aDatanodeStorageRepor\
    tProto\x12B\n\x0cdatanodeInfo\x18\x01\x20\x02(\x0b2\x1e.hadoop.hdfs.Data\
    nodeInfoProtoR\x0cdatanodeInfo\x12G\n\x0estorageReports\x18\x02\x20\x03(\
    \x0b2\x1f.hadoop.hdfs.StorageReportProtoR\x0estorageReports\"\x88\x01\n%\
    GetDatanodeStorageReportResponseProto\x12_\n\x16datanodeStorageReports\
    \x18\x01\x20\x03(\x0b2'.hadoop.hdfs.DatanodeStorageReportProtoR\x16datan\
    odeStorageReports\"?\n!GetPreferredBlockSizeRequestProto\x12\x1a\n\x08fi\
    lename\x18\x01\x20\x02(\tR\x08filename\":\n\"GetPreferredBlockSizeRespon\
    seProto\x12\x14\n\x05bsize\x18\x01\x20\x02(\x04R\x05bsize\"t\n\x17SetSaf\
    eModeRequestProto\x128\n\x06action\x18\x01\x20\x02(\x0e2\x20.hadoop.hdfs\
    .SafeModeActionProtoR\x06action\x12\x1f\n\x07checked\x18\x02\x20\x01(\
    \x08:\x05falseR\x07checked\"2\n\x18SetSafeModeResponseProto\x12\x16\n\
    \x06result\x18\x01\x20\x02(\x08R\x06result\"W\n\x19SaveNamespaceRequestP\
    roto\x12!\n\ntimeWindow\x18\x01\x20\x01(\x04:\x010R\ntimeWindow\x12\x17\
    \n\x05txGap\x18\x02\x20\x01(\x04:\x010R\x05txGap\"8\n\x1aSaveNamespaceRe\
    sponseProto\x12\x1a\n\x05saved\x18\x01\x20\x01(\x08:\x04trueR\x05saved\"\
    \x17\n\x15RollEditsRequestProto\"@\n\x16RollEditsResponseProto\x12&\n\
    \x0enewSegmentTxId\x18\x01\x20\x02(\x04R\x0enewSegmentTxId\"4\n\x20Resto\
    reFailedStorageRequestProto\x12\x10\n\x03arg\x18\x01\x20\x02(\tR\x03arg\
    \";\n!RestoreFailedStorageResponseProto\x12\x16\n\x06result\x18\x01\x20\
    \x02(\x08R\x06result\"\x1a\n\x18RefreshNodesRequestProto\"\x1b\n\x19Refr\
    eshNodesResponseProto\"\x1d\n\x1bFinalizeUpgradeRequestProto\"\x1e\n\x1c\
    FinalizeUpgradeResponseProto\"\x1b\n\x19UpgradeStatusRequestProto\"H\n\
    \x1aUpgradeStatusResponseProto\x12*\n\x10upgradeFinalized\x18\x01\x20\
    \x02(\x08R\x10upgradeFinalized\"\\\n\x1aRollingUpgradeRequestProto\x12>\
    \n\x06action\x18\x01\x20\x02(\x0e2&.hadoop.hdfs.RollingUpgradeActionProt\
    oR\x06action\"\xd1\x01\n\x17RollingUpgradeInfoProto\x12>\n\x06status\x18\
    \x01\x20\x02(\x0b2&.hadoop.hdfs.RollingUpgradeStatusProtoR\x06status\x12\
    \x1c\n\tstartTime\x18\x02\x20\x02(\x04R\tstartTime\x12\"\n\x0cfinalizeTi\
    me\x18\x03\x20\x02(\x04R\x0cfinalizeTime\x124\n\x15createdRollbackImages\
    \x18\x04\x20\x02(\x08R\x15createdRollbackImages\"s\n\x1bRollingUpgradeRe\
    sponseProto\x12T\n\x12rollingUpgradeInfo\x18\x01\x20\x01(\x0b2$.hadoop.h\
    dfs.RollingUpgradeInfoProtoR\x12rollingUpgradeInfo\"O\n!ListCorruptFileB\
    locksRequestProto\x12\x12\n\x04path\x18\x01\x20\x02(\tR\x04path\x12\x16\
    \n\x06cookie\x18\x02\x20\x01(\tR\x06cookie\"c\n\"ListCorruptFileBlocksRe\
    sponseProto\x12=\n\x07corrupt\x18\x01\x20\x02(\x0b2#.hadoop.hdfs.Corrupt\
    FileBlocksProtoR\x07corrupt\"2\n\x14MetaSaveRequestProto\x12\x1a\n\x08fi\
    lename\x18\x01\x20\x02(\tR\x08filename\"\x17\n\x15MetaSaveResponseProto\
    \"+\n\x17GetFileInfoRequestProto\x12\x10\n\x03src\x18\x01\x20\x02(\tR\
    \x03src\"L\n\x18GetFileInfoResponseProto\x120\n\x02fs\x18\x01\x20\x01(\
    \x0b2\x20.hadoop.hdfs.HdfsFileStatusProtoR\x02fs\"a\n\x1eGetLocatedFileI\
    nfoRequestProto\x12\x10\n\x03src\x18\x01\x20\x01(\tR\x03src\x12-\n\x0ene\
    edBlockToken\x18\x02\x20\x01(\x08:\x05falseR\x0eneedBlockToken\"S\n\x1fG\
    etLocatedFileInfoResponseProto\x120\n\x02fs\x18\x01\x20\x01(\x0b2\x20.ha\
    doop.hdfs.HdfsFileStatusProtoR\x02fs\",\n\x18IsFileClosedRequestProto\
    \x12\x10\n\x03src\x18\x01\x20\x02(\tR\x03src\"3\n\x19IsFileClosedRespons\
    eProto\x12\x16\n\x06result\x18\x01\x20\x02(\x08R\x06result\"\xc3\x01\n\
    \x17CacheDirectiveInfoProto\x12\x0e\n\x02id\x18\x01\x20\x01(\x03R\x02id\
    \x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12\x20\n\x0breplication\
    \x18\x03\x20\x01(\rR\x0breplication\x12\x12\n\x04pool\x18\x04\x20\x01(\t\
    R\x04pool\x12N\n\nexpiration\x18\x05\x20\x01(\x0b2..hadoop.hdfs.CacheDir\
    ectiveInfoExpirationProtoR\nexpiration\"[\n!CacheDirectiveInfoExpiration\
    Proto\x12\x16\n\x06millis\x18\x01\x20\x02(\x03R\x06millis\x12\x1e\n\nisR\
    elative\x18\x02\x20\x02(\x08R\nisRelative\"\xc2\x01\n\x18CacheDirectiveS\
    tatsProto\x12\x20\n\x0bbytesNeeded\x18\x01\x20\x02(\x03R\x0bbytesNeeded\
    \x12\x20\n\x0bbytesCached\x18\x02\x20\x02(\x03R\x0bbytesCached\x12\x20\n\
    \x0bfilesNeeded\x18\x03\x20\x02(\x03R\x0bfilesNeeded\x12\x20\n\x0bfilesC\
    ached\x18\x04\x20\x02(\x03R\x0bfilesCached\x12\x1e\n\nhasExpired\x18\x05\
    \x20\x02(\x08R\nhasExpired\"y\n\x1dAddCacheDirectiveRequestProto\x128\n\
    \x04info\x18\x01\x20\x02(\x0b2$.hadoop.hdfs.CacheDirectiveInfoProtoR\x04\
    info\x12\x1e\n\ncacheFlags\x18\x02\x20\x01(\rR\ncacheFlags\"0\n\x1eAddCa\
    cheDirectiveResponseProto\x12\x0e\n\x02id\x18\x01\x20\x02(\x03R\x02id\"|\
    \n\x20ModifyCacheDirectiveRequestProto\x128\n\x04info\x18\x01\x20\x02(\
    \x0b2$.hadoop.hdfs.CacheDirectiveInfoProtoR\x04info\x12\x1e\n\ncacheFlag\
    s\x18\x02\x20\x01(\rR\ncacheFlags\"#\n!ModifyCacheDirectiveResponseProto\
    \"2\n\x20RemoveCacheDirectiveRequestProto\x12\x0e\n\x02id\x18\x01\x20\
    \x02(\x03R\x02id\"#\n!RemoveCacheDirectiveResponseProto\"w\n\x1fListCach\
    eDirectivesRequestProto\x12\x16\n\x06prevId\x18\x01\x20\x02(\x03R\x06pre\
    vId\x12<\n\x06filter\x18\x02\x20\x02(\x0b2$.hadoop.hdfs.CacheDirectiveIn\
    foProtoR\x06filter\"\x91\x01\n\x18CacheDirectiveEntryProto\x128\n\x04inf\
    o\x18\x01\x20\x02(\x0b2$.hadoop.hdfs.CacheDirectiveInfoProtoR\x04info\
    \x12;\n\x05stats\x18\x02\x20\x02(\x0b2%.hadoop.hdfs.CacheDirectiveStatsP\
    rotoR\x05stats\"\x7f\n\x20ListCacheDirectivesResponseProto\x12A\n\x08ele\
    ments\x18\x01\x20\x03(\x0b2%.hadoop.hdfs.CacheDirectiveEntryProtoR\x08el\
    ements\x12\x18\n\x07hasMore\x18\x02\x20\x02(\x08R\x07hasMore\"\xf7\x01\n\
    \x12CachePoolInfoProto\x12\x1a\n\x08poolName\x18\x01\x20\x01(\tR\x08pool\
    Name\x12\x1c\n\townerName\x18\x02\x20\x01(\tR\townerName\x12\x1c\n\tgrou\
    pName\x18\x03\x20\x01(\tR\tgroupName\x12\x12\n\x04mode\x18\x04\x20\x01(\
    \x05R\x04mode\x12\x14\n\x05limit\x18\x05\x20\x01(\x03R\x05limit\x12,\n\
    \x11maxRelativeExpiry\x18\x06\x20\x01(\x03R\x11maxRelativeExpiry\x121\n\
    \x12defaultReplication\x18\x07\x20\x01(\r:\x011R\x12defaultReplication\"\
    \xc5\x01\n\x13CachePoolStatsProto\x12\x20\n\x0bbytesNeeded\x18\x01\x20\
    \x02(\x03R\x0bbytesNeeded\x12\x20\n\x0bbytesCached\x18\x02\x20\x02(\x03R\
    \x0bbytesCached\x12&\n\x0ebytesOverlimit\x18\x03\x20\x02(\x03R\x0ebytesO\
    verlimit\x12\x20\n\x0bfilesNeeded\x18\x04\x20\x02(\x03R\x0bfilesNeeded\
    \x12\x20\n\x0bfilesCached\x18\x05\x20\x02(\x03R\x0bfilesCached\"O\n\x18A\
    ddCachePoolRequestProto\x123\n\x04info\x18\x01\x20\x02(\x0b2\x1f.hadoop.\
    hdfs.CachePoolInfoProtoR\x04info\"\x1b\n\x19AddCachePoolResponseProto\"R\
    \n\x1bModifyCachePoolRequestProto\x123\n\x04info\x18\x01\x20\x02(\x0b2\
    \x1f.hadoop.hdfs.CachePoolInfoProtoR\x04info\"\x1e\n\x1cModifyCachePoolR\
    esponseProto\"9\n\x1bRemoveCachePoolRequestProto\x12\x1a\n\x08poolName\
    \x18\x01\x20\x02(\tR\x08poolName\"\x1e\n\x1cRemoveCachePoolResponseProto\
    \"@\n\x1aListCachePoolsRequestProto\x12\"\n\x0cprevPoolName\x18\x01\x20\
    \x02(\tR\x0cprevPoolName\"s\n\x1bListCachePoolsResponseProto\x12:\n\x07e\
    ntries\x18\x01\x20\x03(\x0b2\x20.hadoop.hdfs.CachePoolEntryProtoR\x07ent\
    ries\x12\x18\n\x07hasMore\x18\x02\x20\x02(\x08R\x07hasMore\"\x82\x01\n\
    \x13CachePoolEntryProto\x123\n\x04info\x18\x01\x20\x02(\x0b2\x1f.hadoop.\
    hdfs.CachePoolInfoProtoR\x04info\x126\n\x05stats\x18\x02\x20\x02(\x0b2\
    \x20.hadoop.hdfs.CachePoolStatsProtoR\x05stats\"/\n\x1bGetFileLinkInfoRe\
    questProto\x12\x10\n\x03src\x18\x01\x20\x02(\tR\x03src\"P\n\x1cGetFileLi\
    nkInfoResponseProto\x120\n\x02fs\x18\x01\x20\x01(\x0b2\x20.hadoop.hdfs.H\
    dfsFileStatusProtoR\x02fs\"3\n\x1dGetContentSummaryRequestProto\x12\x12\
    \n\x04path\x18\x01\x20\x02(\tR\x04path\"\\\n\x1eGetContentSummaryRespons\
    eProto\x12:\n\x07summary\x18\x01\x20\x02(\x0b2\x20.hadoop.hdfs.ContentSu\
    mmaryProtoR\x07summary\"/\n\x19GetQuotaUsageRequestProto\x12\x12\n\x04pa\
    th\x18\x01\x20\x02(\tR\x04path\"P\n\x1aGetQuotaUsageResponseProto\x122\n\
    \x05usage\x18\x01\x20\x02(\x0b2\x1c.hadoop.hdfs.QuotaUsageProtoR\x05usag\
    e\"\xc1\x01\n\x14SetQuotaRequestProto\x12\x12\n\x04path\x18\x01\x20\x02(\
    \tR\x04path\x12&\n\x0enamespaceQuota\x18\x02\x20\x02(\x04R\x0enamespaceQ\
    uota\x12,\n\x11storagespaceQuota\x18\x03\x20\x02(\x04R\x11storagespaceQu\
    ota\x12?\n\x0bstorageType\x18\x04\x20\x01(\x0e2\x1d.hadoop.hdfs.StorageT\
    ypeProtoR\x0bstorageType\"\x17\n\x15SetQuotaResponseProto\"\x86\x01\n\
    \x11FsyncRequestProto\x12\x10\n\x03src\x18\x01\x20\x02(\tR\x03src\x12\
    \x16\n\x06client\x18\x02\x20\x02(\tR\x06client\x12,\n\x0flastBlockLength\
    \x18\x03\x20\x01(\x12:\x02-1R\x0flastBlockLength\x12\x19\n\x06fileId\x18\
    \x04\x20\x01(\x04:\x010R\x06fileId\"\x14\n\x12FsyncResponseProto\"T\n\
    \x14SetTimesRequestProto\x12\x10\n\x03src\x18\x01\x20\x02(\tR\x03src\x12\
    \x14\n\x05mtime\x18\x02\x20\x02(\x04R\x05mtime\x12\x14\n\x05atime\x18\
    \x03\x20\x02(\x04R\x05atime\"\x17\n\x15SetTimesResponseProto\"\xa5\x01\n\
    \x19CreateSymlinkRequestProto\x12\x16\n\x06target\x18\x01\x20\x02(\tR\
    \x06target\x12\x12\n\x04link\x18\x02\x20\x02(\tR\x04link\x128\n\x07dirPe\
    rm\x18\x03\x20\x02(\x0b2\x1e.hadoop.hdfs.FsPermissionProtoR\x07dirPerm\
    \x12\"\n\x0ccreateParent\x18\x04\x20\x02(\x08R\x0ccreateParent\"\x1c\n\
    \x1aCreateSymlinkResponseProto\"/\n\x19GetLinkTargetRequestProto\x12\x12\
    \n\x04path\x18\x01\x20\x02(\tR\x04path\"<\n\x1aGetLinkTargetResponseProt\
    o\x12\x1e\n\ntargetPath\x18\x01\x20\x01(\tR\ntargetPath\"{\n\"UpdateBloc\
    kForPipelineRequestProto\x125\n\x05block\x18\x01\x20\x02(\x0b2\x1f.hadoo\
    p.hdfs.ExtendedBlockProtoR\x05block\x12\x1e\n\nclientName\x18\x02\x20\
    \x02(\tR\nclientName\"[\n#UpdateBlockForPipelineResponseProto\x124\n\x05\
    block\x18\x01\x20\x02(\x0b2\x1e.hadoop.hdfs.LocatedBlockProtoR\x05block\
    \"\x90\x02\n\x1aUpdatePipelineRequestProto\x12\x1e\n\nclientName\x18\x01\
    \x20\x02(\tR\nclientName\x12;\n\x08oldBlock\x18\x02\x20\x02(\x0b2\x1f.ha\
    doop.hdfs.ExtendedBlockProtoR\x08oldBlock\x12;\n\x08newBlock\x18\x03\x20\
    \x02(\x0b2\x1f.hadoop.hdfs.ExtendedBlockProtoR\x08newBlock\x128\n\x08new\
    Nodes\x18\x04\x20\x03(\x0b2\x1c.hadoop.hdfs.DatanodeIDProtoR\x08newNodes\
    \x12\x1e\n\nstorageIDs\x18\x05\x20\x03(\tR\nstorageIDs\"\x1d\n\x1bUpdate\
    PipelineResponseProto\"@\n\x20SetBalancerBandwidthRequestProto\x12\x1c\n\
    \tbandwidth\x18\x01\x20\x02(\x03R\tbandwidth\"#\n!SetBalancerBandwidthRe\
    sponseProto\"\"\n\x20GetDataEncryptionKeyRequestProto\"v\n!GetDataEncryp\
    tionKeyResponseProto\x12Q\n\x11dataEncryptionKey\x18\x01\x20\x01(\x0b2#.\
    hadoop.hdfs.DataEncryptionKeyProtoR\x11dataEncryptionKey\"d\n\x1aCreateS\
    napshotRequestProto\x12\"\n\x0csnapshotRoot\x18\x01\x20\x02(\tR\x0csnaps\
    hotRoot\x12\"\n\x0csnapshotName\x18\x02\x20\x01(\tR\x0csnapshotName\"A\n\
    \x1bCreateSnapshotResponseProto\x12\"\n\x0csnapshotPath\x18\x01\x20\x02(\
    \tR\x0csnapshotPath\"\x94\x01\n\x1aRenameSnapshotRequestProto\x12\"\n\
    \x0csnapshotRoot\x18\x01\x20\x02(\tR\x0csnapshotRoot\x12(\n\x0fsnapshotO\
    ldName\x18\x02\x20\x02(\tR\x0fsnapshotOldName\x12(\n\x0fsnapshotNewName\
    \x18\x03\x20\x02(\tR\x0fsnapshotNewName\"\x1d\n\x1bRenameSnapshotRespons\
    eProto\"?\n\x19AllowSnapshotRequestProto\x12\"\n\x0csnapshotRoot\x18\x01\
    \x20\x02(\tR\x0csnapshotRoot\"\x1c\n\x1aAllowSnapshotResponseProto\"B\n\
    \x1cDisallowSnapshotRequestProto\x12\"\n\x0csnapshotRoot\x18\x01\x20\x02\
    (\tR\x0csnapshotRoot\"\x1f\n\x1dDisallowSnapshotResponseProto\"d\n\x1aDe\
    leteSnapshotRequestProto\x12\"\n\x0csnapshotRoot\x18\x01\x20\x02(\tR\x0c\
    snapshotRoot\x12\"\n\x0csnapshotName\x18\x02\x20\x02(\tR\x0csnapshotName\
    \"\x1d\n\x1bDeleteSnapshotResponseProto\"k\n\x17CheckAccessRequestProto\
    \x12\x12\n\x04path\x18\x01\x20\x02(\tR\x04path\x12<\n\x04mode\x18\x02\
    \x20\x02(\x0e2(.hadoop.hdfs.AclEntryProto.FsActionProtoR\x04mode\"\x1a\n\
    \x18CheckAccessResponseProto\"#\n!GetCurrentEditLogTxidRequestProto\"8\n\
    \"GetCurrentEditLogTxidResponseProto\x12\x12\n\x04txid\x18\x01\x20\x02(\
    \x03R\x04txid\"2\n\x1cGetEditsFromTxidRequestProto\x12\x12\n\x04txid\x18\
    \x01\x20\x02(\x03R\x04txid\"]\n\x1dGetEditsFromTxidResponseProto\x12<\n\
    \neventsList\x18\x01\x20\x02(\x0b2\x1c.hadoop.hdfs.EventsListProtoR\neve\
    ntsList\"v\n\x19ListOpenFilesRequestProto\x12\x0e\n\x02id\x18\x01\x20\
    \x02(\x03R\x02id\x125\n\x05types\x18\x02\x20\x03(\x0e2\x1f.hadoop.hdfs.O\
    penFilesTypeProtoR\x05types\x12\x12\n\x04path\x18\x03\x20\x01(\tR\x04pat\
    h\"\x87\x01\n\x1bOpenFilesBatchResponseProto\x12\x0e\n\x02id\x18\x01\x20\
    \x02(\x03R\x02id\x12\x12\n\x04path\x18\x02\x20\x02(\tR\x04path\x12\x1e\n\
    \nclientName\x18\x03\x20\x02(\tR\nclientName\x12$\n\rclientMachine\x18\
    \x04\x20\x02(\tR\rclientMachine\"\xb1\x01\n\x1aListOpenFilesResponseProt\
    o\x12B\n\x07entries\x18\x01\x20\x03(\x0b2(.hadoop.hdfs.OpenFilesBatchRes\
    ponseProtoR\x07entries\x12\x18\n\x07hasMore\x18\x02\x20\x02(\x08R\x07has\
    More\x125\n\x05types\x18\x03\x20\x03(\x0e2\x1f.hadoop.hdfs.OpenFilesType\
    ProtoR\x05types\"\x13\n\x11MsyncRequestProto\"\x14\n\x12MsyncResponsePro\
    to\"4\n\x20SatisfyStoragePolicyRequestProto\x12\x10\n\x03src\x18\x01\x20\
    \x02(\tR\x03src\"#\n!SatisfyStoragePolicyResponseProto\"\x1c\n\x1aHAServ\
    iceStateRequestProto\"W\n\x1bHAServiceStateResponseProto\x128\n\x05state\
    \x18\x01\x20\x02(\x0e2\".hadoop.common.HAServiceStateProtoR\x05state*p\n\
    \x0fCreateFlagProto\x12\n\n\x06CREATE\x10\x01\x12\r\n\tOVERWRITE\x10\x02\
    \x12\n\n\x06APPEND\x10\x04\x12\x10\n\x0cLAZY_PERSIST\x10\x10\x12\r\n\tNE\
    W_BLOCK\x10\x20\x12\x15\n\x10SHOULD_REPLICATE\x10\x80\x01*C\n\x11AddBloc\
    kFlagProto\x12\x12\n\x0eNO_LOCAL_WRITE\x10\x01\x12\x1a\n\x16IGNORE_CLIEN\
    T_LOCALITY\x10\x02*y\n\x17DatanodeReportTypeProto\x12\x07\n\x03ALL\x10\
    \x01\x12\x08\n\x04LIVE\x10\x02\x12\x08\n\x04DEAD\x10\x03\x12\x13\n\x0fDE\
    COMMISSIONING\x10\x04\x12\x18\n\x14ENTERING_MAINTENANCE\x10\x05\x12\x12\
    \n\x0eIN_MAINTENANCE\x10\x06*h\n\x13SafeModeActionProto\x12\x12\n\x0eSAF\
    EMODE_LEAVE\x10\x01\x12\x12\n\x0eSAFEMODE_ENTER\x10\x02\x12\x10\n\x0cSAF\
    EMODE_GET\x10\x03\x12\x17\n\x13SAFEMODE_FORCE_EXIT\x10\x04*?\n\x19Rollin\
    gUpgradeActionProto\x12\t\n\x05QUERY\x10\x01\x12\t\n\x05START\x10\x02\
    \x12\x0c\n\x08FINALIZE\x10\x03*\x1b\n\x0eCacheFlagProto\x12\t\n\x05FORCE\
    \x10\x01*C\n\x12OpenFilesTypeProto\x12\x12\n\x0eALL_OPEN_FILES\x10\x01\
    \x12\x19\n\x15BLOCKING_DECOMMISSION\x10\x022\xedY\n\x16ClientNamenodePro\
    tocol\x12l\n\x11getBlockLocations\x12*.hadoop.hdfs.GetBlockLocationsRequ\
    estProto\x1a+.hadoop.hdfs.GetBlockLocationsResponseProto\x12l\n\x11getSe\
    rverDefaults\x12*.hadoop.hdfs.GetServerDefaultsRequestProto\x1a+.hadoop.\
    hdfs.GetServerDefaultsResponseProto\x12K\n\x06create\x12\x1f.hadoop.hdfs\
    .CreateRequestProto\x1a\x20.hadoop.hdfs.CreateResponseProto\x12K\n\x06ap\
    pend\x12\x1f.hadoop.hdfs.AppendRequestProto\x1a\x20.hadoop.hdfs.AppendRe\
    sponseProto\x12c\n\x0esetReplication\x12'.hadoop.hdfs.SetReplicationRequ\
    estProto\x1a(.hadoop.hdfs.SetReplicationResponseProto\x12i\n\x10setStora\
    gePolicy\x12).hadoop.hdfs.SetStoragePolicyRequestProto\x1a*.hadoop.hdfs.\
    SetStoragePolicyResponseProto\x12o\n\x12unsetStoragePolicy\x12+.hadoop.h\
    dfs.UnsetStoragePolicyRequestProto\x1a,.hadoop.hdfs.UnsetStoragePolicyRe\
    sponseProto\x12i\n\x10getStoragePolicy\x12).hadoop.hdfs.GetStoragePolicy\
    RequestProto\x1a*.hadoop.hdfs.GetStoragePolicyResponseProto\x12o\n\x12ge\
    tStoragePolicies\x12+.hadoop.hdfs.GetStoragePoliciesRequestProto\x1a,.ha\
    doop.hdfs.GetStoragePoliciesResponseProto\x12`\n\rsetPermission\x12&.had\
    oop.hdfs.SetPermissionRequestProto\x1a'.hadoop.hdfs.SetPermissionRespons\
    eProto\x12Q\n\x08setOwner\x12!.hadoop.hdfs.SetOwnerRequestProto\x1a\".ha\
    doop.hdfs.SetOwnerResponseProto\x12]\n\x0cabandonBlock\x12%.hadoop.hdfs.\
    AbandonBlockRequestProto\x1a&.hadoop.hdfs.AbandonBlockResponseProto\x12Q\
    \n\x08addBlock\x12!.hadoop.hdfs.AddBlockRequestProto\x1a\".hadoop.hdfs.A\
    ddBlockResponseProto\x12x\n\x15getAdditionalDatanode\x12..hadoop.hdfs.Ge\
    tAdditionalDatanodeRequestProto\x1a/.hadoop.hdfs.GetAdditionalDatanodeRe\
    sponseProto\x12Q\n\x08complete\x12!.hadoop.hdfs.CompleteRequestProto\x1a\
    \".hadoop.hdfs.CompleteResponseProto\x12f\n\x0freportBadBlocks\x12(.hado\
    op.hdfs.ReportBadBlocksRequestProto\x1a).hadoop.hdfs.ReportBadBlocksResp\
    onseProto\x12K\n\x06concat\x12\x1f.hadoop.hdfs.ConcatRequestProto\x1a\
    \x20.hadoop.hdfs.ConcatResponseProto\x12Q\n\x08truncate\x12!.hadoop.hdfs\
    .TruncateRequestProto\x1a\".hadoop.hdfs.TruncateResponseProto\x12K\n\x06\
    rename\x12\x1f.hadoop.hdfs.RenameRequestProto\x1a\x20.hadoop.hdfs.Rename\
    ResponseProto\x12N\n\x07rename2\x12\x20.hadoop.hdfs.Rename2RequestProto\
    \x1a!.hadoop.hdfs.Rename2ResponseProto\x12K\n\x06delete\x12\x1f.hadoop.h\
    dfs.DeleteRequestProto\x1a\x20.hadoop.hdfs.DeleteResponseProto\x12K\n\
    \x06mkdirs\x12\x1f.hadoop.hdfs.MkdirsRequestProto\x1a\x20.hadoop.hdfs.Mk\
    dirsResponseProto\x12W\n\ngetListing\x12#.hadoop.hdfs.GetListingRequestP\
    roto\x1a$.hadoop.hdfs.GetListingResponseProto\x12l\n\x11getBatchedListin\
    g\x12*.hadoop.hdfs.GetBatchedListingRequestProto\x1a+.hadoop.hdfs.GetBat\
    chedListingResponseProto\x12W\n\nrenewLease\x12#.hadoop.hdfs.RenewLeaseR\
    equestProto\x1a$.hadoop.hdfs.RenewLeaseResponseProto\x12]\n\x0crecoverLe\
    ase\x12%.hadoop.hdfs.RecoverLeaseRequestProto\x1a&.hadoop.hdfs.RecoverLe\
    aseResponseProto\x12X\n\ngetFsStats\x12$.hadoop.hdfs.GetFsStatusRequestP\
    roto\x1a$.hadoop.hdfs.GetFsStatsResponseProto\x12\x84\x01\n\x19getFsRepl\
    icatedBlockStats\x122.hadoop.hdfs.GetFsReplicatedBlockStatsRequestProto\
    \x1a3.hadoop.hdfs.GetFsReplicatedBlockStatsResponseProto\x12{\n\x16getFs\
    ECBlockGroupStats\x12/.hadoop.hdfs.GetFsECBlockGroupStatsRequestProto\
    \x1a0.hadoop.hdfs.GetFsECBlockGroupStatsResponseProto\x12l\n\x11getDatan\
    odeReport\x12*.hadoop.hdfs.GetDatanodeReportRequestProto\x1a+.hadoop.hdf\
    s.GetDatanodeReportResponseProto\x12\x81\x01\n\x18getDatanodeStorageRepo\
    rt\x121.hadoop.hdfs.GetDatanodeStorageReportRequestProto\x1a2.hadoop.hdf\
    s.GetDatanodeStorageReportResponseProto\x12x\n\x15getPreferredBlockSize\
    \x12..hadoop.hdfs.GetPreferredBlockSizeRequestProto\x1a/.hadoop.hdfs.Get\
    PreferredBlockSizeResponseProto\x12Z\n\x0bsetSafeMode\x12$.hadoop.hdfs.S\
    etSafeModeRequestProto\x1a%.hadoop.hdfs.SetSafeModeResponseProto\x12`\n\
    \rsaveNamespace\x12&.hadoop.hdfs.SaveNamespaceRequestProto\x1a'.hadoop.h\
    dfs.SaveNamespaceResponseProto\x12T\n\trollEdits\x12\".hadoop.hdfs.RollE\
    ditsRequestProto\x1a#.hadoop.hdfs.RollEditsResponseProto\x12u\n\x14resto\
    reFailedStorage\x12-.hadoop.hdfs.RestoreFailedStorageRequestProto\x1a..h\
    adoop.hdfs.RestoreFailedStorageResponseProto\x12]\n\x0crefreshNodes\x12%\
    .hadoop.hdfs.RefreshNodesRequestProto\x1a&.hadoop.hdfs.RefreshNodesRespo\
    nseProto\x12f\n\x0ffinalizeUpgrade\x12(.hadoop.hdfs.FinalizeUpgradeReque\
    stProto\x1a).hadoop.hdfs.FinalizeUpgradeResponseProto\x12`\n\rupgradeSta\
    tus\x12&.hadoop.hdfs.UpgradeStatusRequestProto\x1a'.hadoop.hdfs.UpgradeS\
    tatusResponseProto\x12c\n\x0erollingUpgrade\x12'.hadoop.hdfs.RollingUpgr\
    adeRequestProto\x1a(.hadoop.hdfs.RollingUpgradeResponseProto\x12x\n\x15l\
    istCorruptFileBlocks\x12..hadoop.hdfs.ListCorruptFileBlocksRequestProto\
    \x1a/.hadoop.hdfs.ListCorruptFileBlocksResponseProto\x12Q\n\x08metaSave\
    \x12!.hadoop.hdfs.MetaSaveRequestProto\x1a\".hadoop.hdfs.MetaSaveRespons\
    eProto\x12Z\n\x0bgetFileInfo\x12$.hadoop.hdfs.GetFileInfoRequestProto\
    \x1a%.hadoop.hdfs.GetFileInfoResponseProto\x12o\n\x12getLocatedFileInfo\
    \x12+.hadoop.hdfs.GetLocatedFileInfoRequestProto\x1a,.hadoop.hdfs.GetLoc\
    atedFileInfoResponseProto\x12l\n\x11addCacheDirective\x12*.hadoop.hdfs.A\
    ddCacheDirectiveRequestProto\x1a+.hadoop.hdfs.AddCacheDirectiveResponseP\
    roto\x12u\n\x14modifyCacheDirective\x12-.hadoop.hdfs.ModifyCacheDirectiv\
    eRequestProto\x1a..hadoop.hdfs.ModifyCacheDirectiveResponseProto\x12u\n\
    \x14removeCacheDirective\x12-.hadoop.hdfs.RemoveCacheDirectiveRequestPro\
    to\x1a..hadoop.hdfs.RemoveCacheDirectiveResponseProto\x12r\n\x13listCach\
    eDirectives\x12,.hadoop.hdfs.ListCacheDirectivesRequestProto\x1a-.hadoop\
    .hdfs.ListCacheDirectivesResponseProto\x12]\n\x0caddCachePool\x12%.hadoo\
    p.hdfs.AddCachePoolRequestProto\x1a&.hadoop.hdfs.AddCachePoolResponsePro\
    to\x12f\n\x0fmodifyCachePool\x12(.hadoop.hdfs.ModifyCachePoolRequestProt\
    o\x1a).hadoop.hdfs.ModifyCachePoolResponseProto\x12f\n\x0fremoveCachePoo\
    l\x12(.hadoop.hdfs.RemoveCachePoolRequestProto\x1a).hadoop.hdfs.RemoveCa\
    chePoolResponseProto\x12c\n\x0elistCachePools\x12'.hadoop.hdfs.ListCache\
    PoolsRequestProto\x1a(.hadoop.hdfs.ListCachePoolsResponseProto\x12f\n\
    \x0fgetFileLinkInfo\x12(.hadoop.hdfs.GetFileLinkInfoRequestProto\x1a).ha\
    doop.hdfs.GetFileLinkInfoResponseProto\x12l\n\x11getContentSummary\x12*.\
    hadoop.hdfs.GetContentSummaryRequestProto\x1a+.hadoop.hdfs.GetContentSum\
    maryResponseProto\x12Q\n\x08setQuota\x12!.hadoop.hdfs.SetQuotaRequestPro\
    to\x1a\".hadoop.hdfs.SetQuotaResponseProto\x12H\n\x05fsync\x12\x1e.hadoo\
    p.hdfs.FsyncRequestProto\x1a\x1f.hadoop.hdfs.FsyncResponseProto\x12Q\n\
    \x08setTimes\x12!.hadoop.hdfs.SetTimesRequestProto\x1a\".hadoop.hdfs.Set\
    TimesResponseProto\x12`\n\rcreateSymlink\x12&.hadoop.hdfs.CreateSymlinkR\
    equestProto\x1a'.hadoop.hdfs.CreateSymlinkResponseProto\x12`\n\rgetLinkT\
    arget\x12&.hadoop.hdfs.GetLinkTargetRequestProto\x1a'.hadoop.hdfs.GetLin\
    kTargetResponseProto\x12{\n\x16updateBlockForPipeline\x12/.hadoop.hdfs.U\
    pdateBlockForPipelineRequestProto\x1a0.hadoop.hdfs.UpdateBlockForPipelin\
    eResponseProto\x12c\n\x0eupdatePipeline\x12'.hadoop.hdfs.UpdatePipelineR\
    equestProto\x1a(.hadoop.hdfs.UpdatePipelineResponseProto\x12s\n\x12getDe\
    legationToken\x12-.hadoop.common.GetDelegationTokenRequestProto\x1a..had\
    oop.common.GetDelegationTokenResponseProto\x12y\n\x14renewDelegationToke\
    n\x12/.hadoop.common.RenewDelegationTokenRequestProto\x1a0.hadoop.common\
    .RenewDelegationTokenResponseProto\x12|\n\x15cancelDelegationToken\x120.\
    hadoop.common.CancelDelegationTokenRequestProto\x1a1.hadoop.common.Cance\
    lDelegationTokenResponseProto\x12u\n\x14setBalancerBandwidth\x12-.hadoop\
    .hdfs.SetBalancerBandwidthRequestProto\x1a..hadoop.hdfs.SetBalancerBandw\
    idthResponseProto\x12u\n\x14getDataEncryptionKey\x12-.hadoop.hdfs.GetDat\
    aEncryptionKeyRequestProto\x1a..hadoop.hdfs.GetDataEncryptionKeyResponse\
    Proto\x12c\n\x0ecreateSnapshot\x12'.hadoop.hdfs.CreateSnapshotRequestPro\
    to\x1a(.hadoop.hdfs.CreateSnapshotResponseProto\x12c\n\x0erenameSnapshot\
    \x12'.hadoop.hdfs.RenameSnapshotRequestProto\x1a(.hadoop.hdfs.RenameSnap\
    shotResponseProto\x12`\n\rallowSnapshot\x12&.hadoop.hdfs.AllowSnapshotRe\
    questProto\x1a'.hadoop.hdfs.AllowSnapshotResponseProto\x12i\n\x10disallo\
    wSnapshot\x12).hadoop.hdfs.DisallowSnapshotRequestProto\x1a*.hadoop.hdfs\
    .DisallowSnapshotResponseProto\x12\x87\x01\n\x1agetSnapshottableDirListi\
    ng\x123.hadoop.hdfs.GetSnapshottableDirListingRequestProto\x1a4.hadoop.h\
    dfs.GetSnapshottableDirListingResponseProto\x12o\n\x12getSnapshotListing\
    \x12+.hadoop.hdfs.GetSnapshotListingRequestProto\x1a,.hadoop.hdfs.GetSna\
    pshotListingResponseProto\x12c\n\x0edeleteSnapshot\x12'.hadoop.hdfs.Dele\
    teSnapshotRequestProto\x1a(.hadoop.hdfs.DeleteSnapshotResponseProto\x12x\
    \n\x15getSnapshotDiffReport\x12..hadoop.hdfs.GetSnapshotDiffReportReques\
    tProto\x1a/.hadoop.hdfs.GetSnapshotDiffReportResponseProto\x12\x8d\x01\n\
    \x1cgetSnapshotDiffReportListing\x125.hadoop.hdfs.GetSnapshotDiffReportL\
    istingRequestProto\x1a6.hadoop.hdfs.GetSnapshotDiffReportListingResponse\
    Proto\x12]\n\x0cisFileClosed\x12%.hadoop.hdfs.IsFileClosedRequestProto\
    \x1a&.hadoop.hdfs.IsFileClosedResponseProto\x12i\n\x10modifyAclEntries\
    \x12).hadoop.hdfs.ModifyAclEntriesRequestProto\x1a*.hadoop.hdfs.ModifyAc\
    lEntriesResponseProto\x12i\n\x10removeAclEntries\x12).hadoop.hdfs.Remove\
    AclEntriesRequestProto\x1a*.hadoop.hdfs.RemoveAclEntriesResponseProto\
    \x12i\n\x10removeDefaultAcl\x12).hadoop.hdfs.RemoveDefaultAclRequestProt\
    o\x1a*.hadoop.hdfs.RemoveDefaultAclResponseProto\x12T\n\tremoveAcl\x12\"\
    .hadoop.hdfs.RemoveAclRequestProto\x1a#.hadoop.hdfs.RemoveAclResponsePro\
    to\x12K\n\x06setAcl\x12\x1f.hadoop.hdfs.SetAclRequestProto\x1a\x20.hadoo\
    p.hdfs.SetAclResponseProto\x12]\n\x0cgetAclStatus\x12%.hadoop.hdfs.GetAc\
    lStatusRequestProto\x1a&.hadoop.hdfs.GetAclStatusResponseProto\x12Q\n\
    \x08setXAttr\x12!.hadoop.hdfs.SetXAttrRequestProto\x1a\".hadoop.hdfs.Set\
    XAttrResponseProto\x12T\n\tgetXAttrs\x12\".hadoop.hdfs.GetXAttrsRequestP\
    roto\x1a#.hadoop.hdfs.GetXAttrsResponseProto\x12W\n\nlistXAttrs\x12#.had\
    oop.hdfs.ListXAttrsRequestProto\x1a$.hadoop.hdfs.ListXAttrsResponseProto\
    \x12Z\n\x0bremoveXAttr\x12$.hadoop.hdfs.RemoveXAttrRequestProto\x1a%.had\
    oop.hdfs.RemoveXAttrResponseProto\x12Z\n\x0bcheckAccess\x12$.hadoop.hdfs\
    .CheckAccessRequestProto\x1a%.hadoop.hdfs.CheckAccessResponseProto\x12u\
    \n\x14createEncryptionZone\x12-.hadoop.hdfs.CreateEncryptionZoneRequestP\
    roto\x1a..hadoop.hdfs.CreateEncryptionZoneResponseProto\x12r\n\x13listEn\
    cryptionZones\x12,.hadoop.hdfs.ListEncryptionZonesRequestProto\x1a-.hado\
    op.hdfs.ListEncryptionZonesResponseProto\x12~\n\x17reencryptEncryptionZo\
    ne\x120.hadoop.hdfs.ReencryptEncryptionZoneRequestProto\x1a1.hadoop.hdfs\
    .ReencryptEncryptionZoneResponseProto\x12{\n\x16listReencryptionStatus\
    \x12/.hadoop.hdfs.ListReencryptionStatusRequestProto\x1a0.hadoop.hdfs.Li\
    stReencryptionStatusResponseProto\x12]\n\x0cgetEZForPath\x12%.hadoop.hdf\
    s.GetEZForPathRequestProto\x1a&.hadoop.hdfs.GetEZForPathResponseProto\
    \x12{\n\x16setErasureCodingPolicy\x12/.hadoop.hdfs.SetErasureCodingPolic\
    yRequestProto\x1a0.hadoop.hdfs.SetErasureCodingPolicyResponseProto\x12\
    \x81\x01\n\x18unsetErasureCodingPolicy\x121.hadoop.hdfs.UnsetErasureCodi\
    ngPolicyRequestProto\x1a2.hadoop.hdfs.UnsetErasureCodingPolicyResponsePr\
    oto\x12\x93\x01\n\x1egetECTopologyResultForPolicies\x127.hadoop.hdfs.Get\
    ECTopologyResultForPoliciesRequestProto\x1a8.hadoop.hdfs.GetECTopologyRe\
    sultForPoliciesResponseProto\x12x\n\x15getCurrentEditLogTxid\x12..hadoop\
    .hdfs.GetCurrentEditLogTxidRequestProto\x1a/.hadoop.hdfs.GetCurrentEditL\
    ogTxidResponseProto\x12i\n\x10getEditsFromTxid\x12).hadoop.hdfs.GetEdits\
    FromTxidRequestProto\x1a*.hadoop.hdfs.GetEditsFromTxidResponseProto\x12\
    \x81\x01\n\x18getErasureCodingPolicies\x121.hadoop.hdfs.GetErasureCoding\
    PoliciesRequestProto\x1a2.hadoop.hdfs.GetErasureCodingPoliciesResponsePr\
    oto\x12\x81\x01\n\x18addErasureCodingPolicies\x121.hadoop.hdfs.AddErasur\
    eCodingPoliciesRequestProto\x1a2.hadoop.hdfs.AddErasureCodingPoliciesRes\
    ponseProto\x12\x84\x01\n\x19removeErasureCodingPolicy\x122.hadoop.hdfs.R\
    emoveErasureCodingPolicyRequestProto\x1a3.hadoop.hdfs.RemoveErasureCodin\
    gPolicyResponseProto\x12\x84\x01\n\x19enableErasureCodingPolicy\x122.had\
    oop.hdfs.EnableErasureCodingPolicyRequestProto\x1a3.hadoop.hdfs.EnableEr\
    asureCodingPolicyResponseProto\x12\x87\x01\n\x1adisableErasureCodingPoli\
    cy\x123.hadoop.hdfs.DisableErasureCodingPolicyRequestProto\x1a4.hadoop.h\
    dfs.DisableErasureCodingPolicyResponseProto\x12{\n\x16getErasureCodingPo\
    licy\x12/.hadoop.hdfs.GetErasureCodingPolicyRequestProto\x1a0.hadoop.hdf\
    s.GetErasureCodingPolicyResponseProto\x12{\n\x16getErasureCodingCodecs\
    \x12/.hadoop.hdfs.GetErasureCodingCodecsRequestProto\x1a0.hadoop.hdfs.Ge\
    tErasureCodingCodecsResponseProto\x12`\n\rgetQuotaUsage\x12&.hadoop.hdfs\
    .GetQuotaUsageRequestProto\x1a'.hadoop.hdfs.GetQuotaUsageResponseProto\
    \x12`\n\rlistOpenFiles\x12&.hadoop.hdfs.ListOpenFilesRequestProto\x1a'.h\
    adoop.hdfs.ListOpenFilesResponseProto\x12H\n\x05msync\x12\x1e.hadoop.hdf\
    s.MsyncRequestProto\x1a\x1f.hadoop.hdfs.MsyncResponseProto\x12u\n\x14sat\
    isfyStoragePolicy\x12-.hadoop.hdfs.SatisfyStoragePolicyRequestProto\x1a.\
    .hadoop.hdfs.SatisfyStoragePolicyResponseProto\x12f\n\x11getHAServiceSta\
    te\x12'.hadoop.hdfs.HAServiceStateRequestProto\x1a(.hadoop.hdfs.HAServic\
    eStateResponseProtoBK\n%org.apache.hadoop.hdfs.protocol.protoB\x1cClient\
    NamenodeProtocolProtos\xa0\x01\x01\x88\x01\x01\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
